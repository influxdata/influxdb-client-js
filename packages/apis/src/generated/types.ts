// This file is generated by [oats][0] and should not be edited by hand.
//
// [0]: https://github.com/influxdata/oats

export interface Error {
  /** code is the machine-readable error code. */
  readonly code:
    | 'internal error'
    | 'not found'
    | 'conflict'
    | 'invalid'
    | 'unprocessable entity'
    | 'empty value'
    | 'unavailable'
    | 'forbidden'
    | 'too many requests'
    | 'unauthorized'
    | 'method not allowed'
    | 'request too large'
    | 'unsupported media type'
  /** Human-readable message. */
  readonly message?: string
  /** Describes the logical code operation when the error occurred. Useful for debugging. */
  readonly op?: string
  /** Stack of errors that occurred during processing of the request. Useful for debugging. */
  readonly err?: string
}

export interface Routes {
  authorizations?: string
  buckets?: string
  dashboards?: string
  external?: {
    statusFeed?: string
  }
  variables?: string
  me?: string
  flags?: string
  orgs?: string
  query?: {
    self?: string
    ast?: string
    analyze?: string
    suggestions?: string
  }
  setup?: string
  signin?: string
  signout?: string
  sources?: string
  system?: {
    metrics?: string
    debug?: string
    health?: string
  }
  tasks?: string
  telegrafs?: string
  users?: string
  write?: string
}

export interface DBRPs {
  content?: DBRP[]
}

export interface DBRP {
  /** The ID of the DBRP mapping. */
  readonly id: string
  /** The ID of the organization. */
  orgID: string
  /** The ID of the bucket used as the target for the translation. */
  bucketID: string
  /** InfluxDB v1 database */
  database: string
  /** InfluxDB v1 retention policy */
  retention_policy: string
  /** Mapping represents the default retention policy for the database specified. */
  default: boolean
  /** Indicates an autogenerated, virtual mapping based on the bucket name. Currently only available in OSS. */
  virtual?: boolean
  links?: Links
}

/**
 * URI pointers for additional paged results.

*/
export interface Links {
  next?: Link
  self: Link
  prev?: Link
}

/**
 * URI of resource.
 */
export type Link = string

export interface DBRPCreate {
  /** The ID of the organization. */
  orgID?: string
  /** The name of the organization that owns this mapping. */
  org?: string
  /** The ID of the bucket used as the target for the translation. */
  bucketID: string
  /** InfluxDB v1 database */
  database: string
  /** InfluxDB v1 retention policy */
  retention_policy: string
  /** Mapping represents the default retention policy for the database specified. */
  default?: boolean
}

export interface DBRPGet {
  content?: DBRP
}

export interface DBRPUpdate {
  /** InfluxDB v1 retention policy */
  retention_policy?: string
  default?: boolean
}

export interface TelegrafPlugins {
  version?: string
  os?: string
  plugins?: TelegrafPlugin[]
}

export interface TelegrafPlugin {
  type?: string
  name?: string
  description?: string
  config?: string
}

export interface Telegrafs {
  configurations?: Telegraf[]
}

export type Telegraf = TelegrafRequest & {
  readonly id?: string
  readonly links?: {
    self?: Link
    labels?: Link
    members?: Link
    owners?: Link
  }
  readonly labels?: Labels
}

export interface TelegrafRequest {
  name?: string
  description?: string
  metadata?: {
    buckets?: string[]
  }
  config?: string
  orgID?: string
}

export type Labels = Label[]

export interface Label {
  readonly id?: string
  readonly orgID?: string
  name?: string
  /** Key-value pairs associated with this label.
To remove a property, send an update with an empty value (`""`) for the key.
 */
  properties?: any
}

export interface TelegrafPluginRequest {
  name?: string
  description?: string
  plugins?: Array<{
    type?: string
    name?: string
    alias?: string
    description?: string
    config?: string
  }>
  metadata?: {
    buckets?: string[]
  }
  config?: string
  orgID?: string
}

export interface LabelsResponse {
  labels?: Labels
  links?: Links
}

export interface LabelMapping {
  /** Label ID.
The ID of the label to attach.
 */
  labelID?: string
}

export interface LabelResponse {
  label?: Label
  links?: Links
}

export interface ResourceMembers {
  links?: {
    self?: string
  }
  users?: ResourceMember[]
}

export type ResourceMember = UserResponse & {
  role?: 'member'
}

export interface UserResponse {
  /** The ID of the user.
   */
  readonly id?: string
  /** The name of the user.
   */
  name: string
  /** The status of a user. An inactive user won't have access to resources.
   */
  status?: 'active' | 'inactive'
  readonly links?: {
    self?: string
  }
}

export interface AddResourceMemberRequestBody {
  /** The ID of the user to add to the resource.
   */
  id: string
  /** The name of the user to add to the resource.
   */
  name?: string
}

export interface ResourceOwners {
  links?: {
    self?: string
  }
  users?: ResourceOwner[]
}

export type ResourceOwner = UserResponse & {
  role?: 'owner'
}

export interface LineProtocolError {
  /** Code is the machine-readable error code. */
  readonly code:
    | 'internal error'
    | 'not found'
    | 'conflict'
    | 'invalid'
    | 'empty value'
    | 'unavailable'
  /** Human-readable message. */
  readonly message?: string
  /** Describes the logical code operation when the error occurred. Useful for debugging. */
  readonly op?: string
  /** Stack of errors that occurred during processing of the request. Useful for debugging. */
  readonly err?: string
  /** First line in the request body that contains malformed data. */
  readonly line?: number
}

export interface LineProtocolLengthError {
  /** Code is the machine-readable error code. */
  readonly code: 'invalid'
  /** Human-readable message. */
  readonly message: string
}

/**
 * The delete predicate request.
 */
export interface DeletePredicateRequest {
  /** A timestamp ([RFC3339 date/time format](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#rfc3339-timestamp)).
The earliest time to delete from.
 */
  start: string
  /** A timestamp ([RFC3339 date/time format](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#rfc3339-timestamp)).
The latest time to delete from.
 */
  stop: string
  /** An expression in [delete predicate syntax](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/delete-predicate/).
   */
  predicate?: string
}

export interface LabelCreateRequest {
  orgID: string
  name: string
  /** Key-value pairs associated with this label.

To remove a property, send an update with an empty value (`""`) for the key.
 */
  properties?: any
}

export interface LabelUpdate {
  name?: string
  properties?: any
}

export type Dashboard = CreateDashboardRequest & {
  links?: {
    self?: Link
    cells?: Link
    members?: Link
    owners?: Link
    labels?: Link
    org?: Link
  }
  readonly id?: string
  meta?: {
    createdAt?: string
    updatedAt?: string
  }
  cells?: Cells
  labels?: Labels
}

export interface CreateDashboardRequest {
  /** The ID of the organization that owns the dashboard. */
  orgID: string
  /** The user-facing name of the dashboard. */
  name: string
  /** The user-facing description of the dashboard. */
  description?: string
}

export type Cells = Cell[]

export interface Cell {
  id?: string
  links?: {
    self?: string
    view?: string
  }
  x?: number
  y?: number
  w?: number
  h?: number
  /** The reference to a view from the views API. */
  viewID?: string
}

export type DashboardWithViewProperties = CreateDashboardRequest & {
  links?: {
    self?: Link
    cells?: Link
    members?: Link
    owners?: Link
    labels?: Link
    org?: Link
  }
  readonly id?: string
  meta?: {
    createdAt?: string
    updatedAt?: string
  }
  cells?: CellsWithViewProperties
  labels?: Labels
}

export type CellsWithViewProperties = CellWithViewProperties[]

export type CellWithViewProperties = Cell & {
  name?: string
  properties?: ViewProperties
}

export type ViewProperties =
  | LinePlusSingleStatProperties
  | XYViewProperties
  | SingleStatViewProperties
  | HistogramViewProperties
  | GaugeViewProperties
  | TableViewProperties
  | SimpleTableViewProperties
  | MarkdownViewProperties
  | CheckViewProperties
  | ScatterViewProperties
  | HeatmapViewProperties
  | MosaicViewProperties
  | BandViewProperties
  | GeoViewProperties

export interface LinePlusSingleStatProperties {
  adaptiveZoomHide?: boolean
  timeFormat?: string
  type: 'line-plus-single-stat'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  axes: Axes
  staticLegend?: StaticLegend
  xColumn?: string
  generateXAxisTicks?: string[]
  xTotalTicks?: number
  xTickStart?: number
  xTickStep?: number
  yColumn?: string
  generateYAxisTicks?: string[]
  yTotalTicks?: number
  yTickStart?: number
  yTickStep?: number
  shadeBelow?: boolean
  hoverDimension?: 'auto' | 'x' | 'y' | 'xy'
  position: 'overlaid' | 'stacked'
  prefix: string
  suffix: string
  decimalPlaces: DecimalPlaces
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export interface DashboardQuery {
  /** The text of the Flux query. */
  text?: string
  editMode?: QueryEditMode
  name?: string
  builderConfig?: BuilderConfig
}

export type QueryEditMode = 'builder' | 'advanced'

export interface BuilderConfig {
  buckets?: string[]
  tags?: BuilderTagsType[]
  functions?: BuilderFunctionsType[]
  aggregateWindow?: {
    period?: string
    fillValues?: boolean
  }
}

export interface BuilderTagsType {
  key?: string
  values?: string[]
  aggregateFunctionType?: BuilderAggregateFunctionType
}

export type BuilderAggregateFunctionType = 'filter' | 'group'

export interface BuilderFunctionsType {
  name?: string
}

/**
 * Defines an encoding of data value into color space.
 */
export interface DashboardColor {
  /** The unique ID of the view color. */
  id: string
  /** Type is how the color is used. */
  type: 'min' | 'max' | 'threshold' | 'scale' | 'text' | 'background'
  /** The hex number of the color */
  hex: string
  /** The user-facing name of the hex color. */
  name: string
  /** The data value mapped to this color. */
  value: number
}

/**
 * The viewport for a View's visualizations
 */
export interface Axes {
  x: Axis
  y: Axis
}

/**
 * Axis used in a visualization.
 */
export interface Axis {
  /** The extents of the axis in the form [lower, upper]. Clients determine whether bounds are inclusive or exclusive of their limits. */
  bounds?: string[]
  /** Description of the axis. */
  label?: string
  /** Label prefix for formatting axis values. */
  prefix?: string
  /** Label suffix for formatting axis values. */
  suffix?: string
  /** Radix for formatting axis values. */
  base?: '' | '2' | '10'
  scale?: AxisScale
}

/**
 * Scale is the axis formatting scale. Supported: "log", "linear"
 */
export type AxisScale = 'log' | 'linear'

/**
 * StaticLegend represents the options specific to the static legend
 */
export interface StaticLegend {
  colorizeRows?: boolean
  heightRatio?: number
  show?: boolean
  opacity?: number
  orientationThreshold?: number
  valueAxis?: string
  widthRatio?: number
}

/**
 * Indicates whether decimal places should be enforced, and how many digits it should show.
 */
export interface DecimalPlaces {
  /** Indicates whether decimal point setting should be enforced */
  isEnforced?: boolean
  /** The number of digits after decimal to display */
  digits?: number
}

export interface XYViewProperties {
  adaptiveZoomHide?: boolean
  timeFormat?: string
  type: 'xy'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  /** An object that contains information about the color mapping */
  colorMapping?: ColorMapping
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  axes: Axes
  staticLegend?: StaticLegend
  xColumn?: string
  generateXAxisTicks?: string[]
  xTotalTicks?: number
  xTickStart?: number
  xTickStep?: number
  yColumn?: string
  generateYAxisTicks?: string[]
  yTotalTicks?: number
  yTickStart?: number
  yTickStep?: number
  shadeBelow?: boolean
  hoverDimension?: 'auto' | 'x' | 'y' | 'xy'
  position: 'overlaid' | 'stacked'
  geom: XYGeom
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

/**
 * A color mapping is an object that maps time series data to a UI color scheme to allow the UI to render graphs consistent colors across reloads.
 */
export type ColorMapping = any

export type XYGeom =
  | 'line'
  | 'step'
  | 'stacked'
  | 'bar'
  | 'monotoneX'
  | 'stepBefore'
  | 'stepAfter'

export interface SingleStatViewProperties {
  type: 'single-stat'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  prefix: string
  tickPrefix: string
  suffix: string
  tickSuffix: string
  staticLegend?: StaticLegend
  decimalPlaces: DecimalPlaces
}

export interface HistogramViewProperties {
  type: 'histogram'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  xColumn: string
  fillColumns: string[]
  xDomain: number[]
  xAxisLabel: string
  position: 'overlaid' | 'stacked'
  binCount: number
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export interface GaugeViewProperties {
  type: 'gauge'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  prefix: string
  tickPrefix: string
  suffix: string
  tickSuffix: string
  decimalPlaces: DecimalPlaces
}

export interface TableViewProperties {
  type: 'table'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  tableOptions: {
    /** verticalTimeAxis describes the orientation of the table by indicating whether the time axis will be displayed vertically */
    verticalTimeAxis?: boolean
    sortBy?: RenamableField
    /** Wrapping describes the text wrapping style to be used in table views */
    wrapping?: 'truncate' | 'wrap' | 'single-line'
    /** fixFirstColumn indicates whether the first column of the table should be locked */
    fixFirstColumn?: boolean
  }
  /** fieldOptions represent the fields retrieved by the query with customization options */
  fieldOptions: RenamableField[]
  /** timeFormat describes the display format for time values according to moment.js date formatting */
  timeFormat: string
  decimalPlaces: DecimalPlaces
}

/**
 * Describes a field that can be renamed and made visible or invisible.
 */
export interface RenamableField {
  /** The calculated name of a field. */
  readonly internalName?: string
  /** The name that a field is renamed to by the user. */
  displayName?: string
  /** Indicates whether this field should be visible on the table. */
  visible?: boolean
}

export interface SimpleTableViewProperties {
  type: 'simple-table'
  showAll: boolean
  queries: DashboardQuery[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
}

export interface MarkdownViewProperties {
  type: 'markdown'
  shape: 'chronograf-v2'
  note: string
}

export interface CheckViewProperties {
  adaptiveZoomHide?: boolean
  type: 'check'
  shape: 'chronograf-v2'
  checkID: string
  check?: Check
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export type Check = CheckDiscriminator

export type CheckDiscriminator =
  | (DeadmanCheck & {type: string})
  | (ThresholdCheck & {type: string})
  | (CustomCheck & {type: string})

export type DeadmanCheck = CheckBase & {
  type: 'deadman'
  /** String duration before deadman triggers. */
  timeSince?: string
  /** String duration for time that a series is considered stale and should not trigger deadman. */
  staleTime?: string
  /** If only zero values reported since time, trigger an alert */
  reportZero?: boolean
  level?: CheckStatusLevel
  /** Check repetition interval. */
  every?: string
  /** Duration to delay after the schedule, before executing check. */
  offset?: string
  /** List of tags to write to each status. */
  tags?: Array<{
    key?: string
    value?: string
  }>
  /** The template used to generate and write a status message. */
  statusMessageTemplate?: string
}

export interface CheckBase {
  readonly id?: string
  name: string
  /** The ID of the organization that owns this check. */
  orgID: string
  /** The ID of the task associated with this check. */
  taskID?: string
  /** The ID of creator used to create this check. */
  readonly ownerID?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  query: DashboardQuery
  status?: TaskStatusType
  /** An optional description of the check. */
  description?: string
  /** A timestamp ([RFC3339 date/time format](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#rfc3339-timestamp)) of the latest scheduled and completed run. */
  readonly latestCompleted?: string
  readonly lastRunStatus?: 'failed' | 'success' | 'canceled'
  readonly lastRunError?: string
  labels?: Labels
  readonly links?: {
    /** URL for this check */
    self?: Link
    /** URL to retrieve labels for this check */
    labels?: Link
    /** URL to retrieve members for this check */
    members?: Link
    /** URL to retrieve owners for this check */
    owners?: Link
    /** URL to retrieve flux script for this check */
    query?: Link
  }
}

/**
 * `inactive` cancels scheduled runs and prevents manual runs of the task.

*/
export type TaskStatusType = 'active' | 'inactive'

/**
 * The state to record if check matches a criteria.
 */
export type CheckStatusLevel = 'UNKNOWN' | 'OK' | 'INFO' | 'CRIT' | 'WARN'

export type ThresholdCheck = CheckBase & {
  type: 'threshold'
  thresholds?: Threshold[]
  /** Check repetition interval. */
  every?: string
  /** Duration to delay after the schedule, before executing check. */
  offset?: string
  /** List of tags to write to each status. */
  tags?: Array<{
    key?: string
    value?: string
  }>
  /** The template used to generate and write a status message. */
  statusMessageTemplate?: string
}

export type Threshold =
  | (GreaterThreshold & {type: string})
  | (LesserThreshold & {type: string})
  | (RangeThreshold & {type: string})

export type GreaterThreshold = ThresholdBase & {
  type: 'greater'
  value: number
}

export interface ThresholdBase {
  level?: CheckStatusLevel
  /** If true, only alert if all values meet threshold. */
  allValues?: boolean
}

export type LesserThreshold = ThresholdBase & {
  type: 'lesser'
  value: number
}

export type RangeThreshold = ThresholdBase & {
  type: 'range'
  min: number
  max: number
  within: boolean
}

export type CustomCheck = CheckBase & {
  type: 'custom'
}

export interface ScatterViewProperties {
  adaptiveZoomHide?: boolean
  timeFormat?: string
  type: 'scatter'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: string[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  xColumn: string
  generateXAxisTicks?: string[]
  xTotalTicks?: number
  xTickStart?: number
  xTickStep?: number
  yColumn: string
  generateYAxisTicks?: string[]
  yTotalTicks?: number
  yTickStart?: number
  yTickStep?: number
  fillColumns: string[]
  symbolColumns: string[]
  xDomain: number[]
  yDomain: number[]
  xAxisLabel: string
  yAxisLabel: string
  xPrefix: string
  xSuffix: string
  yPrefix: string
  ySuffix: string
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export interface HeatmapViewProperties {
  adaptiveZoomHide?: boolean
  timeFormat?: string
  type: 'heatmap'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: string[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  xColumn: string
  generateXAxisTicks?: string[]
  xTotalTicks?: number
  xTickStart?: number
  xTickStep?: number
  yColumn: string
  generateYAxisTicks?: string[]
  yTotalTicks?: number
  yTickStart?: number
  yTickStep?: number
  xDomain: number[]
  yDomain: number[]
  xAxisLabel: string
  yAxisLabel: string
  xPrefix: string
  xSuffix: string
  yPrefix: string
  ySuffix: string
  binSize: number
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export interface MosaicViewProperties {
  timeFormat?: string
  type: 'mosaic'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: string[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  xColumn: string
  generateXAxisTicks?: string[]
  xTotalTicks?: number
  xTickStart?: number
  xTickStep?: number
  yLabelColumnSeparator?: string
  yLabelColumns?: string[]
  ySeriesColumns: string[]
  fillColumns: string[]
  xDomain: number[]
  yDomain: number[]
  xAxisLabel: string
  yAxisLabel: string
  xPrefix: string
  xSuffix: string
  yPrefix: string
  ySuffix: string
  hoverDimension?: 'auto' | 'x' | 'y' | 'xy'
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export interface BandViewProperties {
  adaptiveZoomHide?: boolean
  timeFormat?: string
  type: 'band'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  axes: Axes
  staticLegend?: StaticLegend
  xColumn?: string
  generateXAxisTicks?: string[]
  xTotalTicks?: number
  xTickStart?: number
  xTickStep?: number
  yColumn?: string
  generateYAxisTicks?: string[]
  yTotalTicks?: number
  yTickStart?: number
  yTickStep?: number
  upperColumn?: string
  mainColumn?: string
  lowerColumn?: string
  hoverDimension?: 'auto' | 'x' | 'y' | 'xy'
  geom: XYGeom
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export interface GeoViewProperties {
  type: 'geo'
  queries: DashboardQuery[]
  shape: 'chronograf-v2'
  /** Coordinates of the center of the map */
  center: {
    /** Latitude of the center of the map */
    lat: number
    /** Longitude of the center of the map */
    lon: number
  }
  /** Zoom level used for initial display of the map */
  zoom: number
  /** If true, map zoom and pan controls are enabled on the dashboard view */
  allowPanAndZoom: boolean
  /** If true, search results get automatically regroupped so that lon,lat and value are treated as columns */
  detectCoordinateFields: boolean
  /** If true, S2 column is used to calculate lat/lon */
  useS2CellID?: boolean
  /** String to define the column */
  s2Column?: string
  latLonColumns?: LatLonColumns
  /** Define map type - regular, satellite etc. */
  mapStyle?: string
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  /** Colors define color encoding of data into a visualization */
  colors?: DashboardColor[]
  /** List of individual layers shown in the map */
  layers: GeoViewLayer[]
}

/**
 * Object type to define lat/lon columns
 */
export interface LatLonColumns {
  lat: LatLonColumn
  lon: LatLonColumn
}

/**
 * Object type for key and column definitions
 */
export interface LatLonColumn {
  /** Key to determine whether the column is tag/field */
  key: string
  /** Column to look up Lat/Lon */
  column: string
}

export type GeoViewLayer =
  | GeoCircleViewLayer
  | GeoHeatMapViewLayer
  | GeoPointMapViewLayer
  | GeoTrackMapViewLayer

export type GeoCircleViewLayer = GeoViewLayerProperties & {
  /** Radius field */
  radiusField: string
  radiusDimension: Axis
  /** Circle color field */
  colorField: string
  colorDimension: Axis
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  /** Maximum radius size in pixels */
  radius?: number
  /** Interpolate circle color based on displayed value */
  interpolateColors?: boolean
}

export interface GeoViewLayerProperties {
  type: 'heatmap' | 'circleMap' | 'pointMap' | 'trackMap'
}

export type GeoHeatMapViewLayer = GeoViewLayerProperties & {
  /** Intensity field */
  intensityField: string
  intensityDimension: Axis
  /** Radius size in pixels */
  radius: number
  /** Blur for heatmap points */
  blur: number
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
}

export type GeoPointMapViewLayer = GeoViewLayerProperties & {
  /** Marker color field */
  colorField: string
  colorDimension: Axis
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  /** Cluster close markers together */
  isClustered?: boolean
  /** An array for which columns to display in tooltip */
  tooltipColumns?: string[]
}

export type GeoTrackMapViewLayer = GeoViewLayerProperties & any

export interface CreateCell {
  name?: string
  x?: number
  y?: number
  w?: number
  h?: number
  /** Makes a copy of the provided view. */
  usingView?: string
}

export interface CellUpdate {
  x?: number
  y?: number
  w?: number
  h?: number
}

export interface View {
  readonly links?: {
    self?: string
  }
  readonly id?: string
  name: string
  properties: ViewProperties
}

/**
 * Flux query to be analyzed.
 */
export interface LanguageRequest {
  /** The Flux query script to be analyzed.
   */
  query: string
}

/**
 * Contains the AST for the supplied Flux query
 */
export interface ASTResponse {
  ast?: Package
}

/**
 * Represents a complete package source tree.
 */
export interface Package {
  type?: NodeType
  /** Package import path */
  path?: string
  /** Package name */
  package?: string
  /** Package files */
  files?: File[]
}

/**
 * Type of AST node
 */
export type NodeType = string

/**
 * Represents a source from a single file
 */
export interface File {
  type?: NodeType
  /** The name of the file. */
  name?: string
  package?: PackageClause
  /** A list of package imports */
  imports?: ImportDeclaration[]
  /** List of Flux statements */
  body?: Statement[]
}

/**
 * Defines a package identifier
 */
export interface PackageClause {
  type?: NodeType
  name?: Identifier
}

/**
 * A valid Flux identifier
 */
export interface Identifier {
  type?: NodeType
  name?: string
}

/**
 * Declares a package import
 */
export interface ImportDeclaration {
  type?: NodeType
  as?: Identifier
  path?: StringLiteral
}

/**
 * Expressions begin and end with double quote marks
 */
export interface StringLiteral {
  type?: NodeType
  value?: string
}

export type Statement =
  | BadStatement
  | VariableAssignment
  | MemberAssignment
  | ExpressionStatement
  | ReturnStatement
  | OptionStatement
  | BuiltinStatement
  | TestStatement

/**
 * A placeholder for statements for which no correct statement nodes can be created
 */
export interface BadStatement {
  type?: NodeType
  /** Raw source text */
  text?: string
}

/**
 * Represents the declaration of a variable
 */
export interface VariableAssignment {
  type?: NodeType
  id?: Identifier
  init?: Expression
}

export type Expression =
  | ArrayExpression
  | DictExpression
  | FunctionExpression
  | BinaryExpression
  | CallExpression
  | ConditionalExpression
  | LogicalExpression
  | MemberExpression
  | IndexExpression
  | ObjectExpression
  | ParenExpression
  | PipeExpression
  | UnaryExpression
  | BooleanLiteral
  | DateTimeLiteral
  | DurationLiteral
  | FloatLiteral
  | IntegerLiteral
  | PipeLiteral
  | RegexpLiteral
  | StringLiteral
  | UnsignedIntegerLiteral
  | Identifier

/**
 * Used to create and directly specify the elements of an array object
 */
export interface ArrayExpression {
  type?: NodeType
  /** Elements of the array */
  elements?: Expression[]
}

/**
 * Used to create and directly specify the elements of a dictionary
 */
export interface DictExpression {
  type?: NodeType
  /** Elements of the dictionary */
  elements?: DictItem[]
}

/**
 * A key-value pair in a dictionary.
 */
export interface DictItem {
  type?: NodeType
  key?: Expression
  val?: Expression
}

/**
 * Function expression
 */
export interface FunctionExpression {
  type?: NodeType
  /** Function parameters */
  params?: Property[]
  body?: Node
}

/**
 * The value associated with a key
 */
export interface Property {
  type?: NodeType
  key?: PropertyKey
  value?: Expression
}

export type PropertyKey = Identifier | StringLiteral

export type Node = Expression | Block

/**
 * A set of statements
 */
export interface Block {
  type?: NodeType
  /** Block body */
  body?: Statement[]
}

/**
 * uses binary operators to act on two operands in an expression
 */
export interface BinaryExpression {
  type?: NodeType
  operator?: string
  left?: Expression
  right?: Expression
}

/**
 * Represents a function call
 */
export interface CallExpression {
  type?: NodeType
  callee?: Expression
  /** Function arguments */
  arguments?: Expression[]
}

/**
 * Selects one of two expressions, `Alternate` or `Consequent`, depending on a third boolean expression, `Test`
 */
export interface ConditionalExpression {
  type?: NodeType
  test?: Expression
  alternate?: Expression
  consequent?: Expression
}

/**
 * Represents the rule conditions that collectively evaluate to either true or false
 */
export interface LogicalExpression {
  type?: NodeType
  operator?: string
  left?: Expression
  right?: Expression
}

/**
 * Represents accessing a property of an object
 */
export interface MemberExpression {
  type?: NodeType
  object?: Expression
  property?: PropertyKey
}

/**
 * Represents indexing into an array
 */
export interface IndexExpression {
  type?: NodeType
  array?: Expression
  index?: Expression
}

/**
 * Allows the declaration of an anonymous object within a declaration
 */
export interface ObjectExpression {
  type?: NodeType
  /** Object properties */
  properties?: Property[]
}

/**
 * Represents an expression wrapped in parenthesis
 */
export interface ParenExpression {
  type?: NodeType
  expression?: Expression
}

/**
 * Call expression with pipe argument
 */
export interface PipeExpression {
  type?: NodeType
  argument?: Expression
  call?: CallExpression
}

/**
 * Uses operators to act on a single operand in an expression
 */
export interface UnaryExpression {
  type?: NodeType
  operator?: string
  argument?: Expression
}

/**
 * Represents boolean values
 */
export interface BooleanLiteral {
  type?: NodeType
  value?: boolean
}

/**
 * Represents an instant in time with nanosecond precision in [RFC3339Nano date/time format](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#rfc3339nano-timestamp).
 */
export interface DateTimeLiteral {
  type?: NodeType
  value?: string
}

/**
 * Represents the elapsed time between two instants as an int64 nanosecond count with syntax of golang's time.Duration
 */
export interface DurationLiteral {
  type?: NodeType
  /** Duration values */
  values?: Duration[]
}

/**
 * A pair consisting of length of time and the unit of time measured. It is the atomic unit from which all duration literals are composed.
 */
export interface Duration {
  type?: NodeType
  magnitude?: number
  unit?: string
}

/**
 * Represents floating point numbers according to the double representations defined by the IEEE-754-1985
 */
export interface FloatLiteral {
  type?: NodeType
  value?: number
}

/**
 * Represents integer numbers
 */
export interface IntegerLiteral {
  type?: NodeType
  value?: string
}

/**
 * Represents a specialized literal value, indicating the left hand value of a pipe expression
 */
export interface PipeLiteral {
  type?: NodeType
}

/**
 * Expressions begin and end with `/` and are regular expressions with syntax accepted by RE2
 */
export interface RegexpLiteral {
  type?: NodeType
  value?: string
}

/**
 * Represents integer numbers
 */
export interface UnsignedIntegerLiteral {
  type?: NodeType
  value?: string
}

/**
 * Object property assignment
 */
export interface MemberAssignment {
  type?: NodeType
  member?: MemberExpression
  init?: Expression
}

/**
 * May consist of an expression that doesn't return a value and is executed solely for its side-effects
 */
export interface ExpressionStatement {
  type?: NodeType
  expression?: Expression
}

/**
 * Defines an expression to return
 */
export interface ReturnStatement {
  type?: NodeType
  argument?: Expression
}

/**
 * A single variable declaration
 */
export interface OptionStatement {
  type?: NodeType
  assignment?: VariableAssignment | MemberAssignment
}

/**
 * Declares a builtin identifier and its type
 */
export interface BuiltinStatement {
  type?: NodeType
  id?: Identifier
}

/**
 * Declares a Flux test case
 */
export interface TestStatement {
  type?: NodeType
  assignment?: VariableAssignment
}

export interface FluxSuggestions {
  funcs?: FluxSuggestion[]
}

export interface FluxSuggestion {
  name?: string
  params?: any
}

/**
 * Query InfluxDB with the Flux language
 */
export interface Query {
  extern?: File
  /** The query script to execute. */
  query: string
  /** The type of query. Must be "flux". */
  type?: 'flux'
  /** Key-value pairs passed as parameters during query execution.

To use parameters in your query, pass a _`query`_ with `params` references (in dot notation)--for example:

```json
  query: "from(bucket: params.mybucket) |> range(start: params.rangeStart) |> limit(n:1)"
```

and pass _`params`_ with the key-value pairs--for example:

```json
  params: {
    "mybucket": "environment",
    "rangeStart": "-30d"
  }
```

During query execution, InfluxDB passes _`params`_ to your script and substitutes the values.

#### Limitations

- If you use _`params`_, you can't use _`extern`_.
 */
  params?: any
  dialect?: Dialect
  /** Specifies the time that should be reported as `now` in the query.
Default is the server `now` time.
 */
  now?: string
}

/**
 * Options for tabular data output.
Default output is [annotated CSV](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/annotated-csv/#csv-response-format) with headers.

For more information about tabular data **dialect**,
see [W3 metadata vocabulary for tabular data](https://www.w3.org/TR/2015/REC-tabular-metadata-20151217/#dialect-descriptions).

*/
export interface Dialect {
  /** If true, the results contain a header row. */
  header?: boolean
  /** The separator used between cells. Default is a comma (`,`). */
  delimiter?: string
  /** Annotation rows to include in the results.
An _annotation_ is metadata associated with an object (column) in the data model.

#### Related guides

- See [Annotated CSV annotations](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/annotated-csv/#annotations) for examples and more information.

For more information about **annotations** in tabular data,
see [W3 metadata vocabulary for tabular data](https://www.w3.org/TR/2015/REC-tabular-data-model-20151217/#columns).
 */
  annotations?: Array<'group' | 'datatype' | 'default'>
  /** The character prefixed to comment strings. Default is a number sign (`#`). */
  commentPrefix?: string
  /** The format for timestamps in results.
Default is [`RFC3339` date/time format](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#rfc3339-timestamp).
To include nanoseconds in timestamps, use `RFC3339Nano`.

#### Example formatted date/time values

| Format      | Value                       |
|:------------|:----------------------------|
| `RFC3339`    | `"2006-01-02T15:04:05Z07:00"` |
| `RFC3339Nano` | `"2006-01-02T15:04:05.999999999Z07:00"` |
 */
  dateTimeFormat?: 'RFC3339' | 'RFC3339Nano'
}

export interface AnalyzeQueryResponse {
  errors?: Array<{
    line?: number
    column?: number
    character?: number
    message?: string
  }>
}

export interface Buckets {
  readonly links?: Links
  buckets?: Bucket[]
}

export interface Bucket {
  readonly links?: {
    /** URL to retrieve labels for this bucket. */
    labels?: Link
    /** URL to retrieve members that can read this bucket. */
    members?: Link
    /** URL to retrieve parent organization for this bucket. */
    org?: Link
    /** URL to retrieve owners that can read and write to this bucket. */
    owners?: Link
    /** URL for this bucket. */
    self?: Link
    /** URL to write line protocol to this bucket. */
    write?: Link
  }
  readonly id?: string
  readonly type?: 'user' | 'system'
  name: string
  description?: string
  orgID?: string
  rp?: string
  schemaType?: SchemaType
  readonly createdAt?: string
  readonly updatedAt?: string
  retentionRules: RetentionRules
  labels?: Labels
}

export type SchemaType = 'implicit' | 'explicit'

/**
 * Retention rules to expire or retain data.
#### InfluxDB Cloud

- `retentionRules` is required.

#### InfluxDB OSS

- `retentionRules` isn't required.

*/
export type RetentionRules = RetentionRule[]

export interface RetentionRule {
  type?: 'expire'
  /** The duration in seconds for how long data will be kept in the database.
The default duration is 2592000 (30 days).
0 represents infinite retention.
 */
  everySeconds: number
  /** The shard group duration.
The duration or interval (in seconds) that each shard group covers.

#### InfluxDB Cloud

- Does not use `shardGroupDurationsSeconds`.

#### InfluxDB OSS

- Default value depends on the
[bucket retention period](https://docs.influxdata.com/influxdb/v2.3/v2.3/reference/internals/shards/#shard-group-duration).
 */
  shardGroupDurationSeconds?: number
}

export interface PostBucketRequest {
  /** Organization ID.
The ID of the organization.
 */
  orgID: string
  /** The name of the bucket.
   */
  name: string
  /** A description of the bucket.
   */
  description?: string
  /** Retention policy is an InfluxDB 1.x concept that represents the duration
of time that each data point in the retention policy persists. Use `rp`
for compatibility with InfluxDB 1.x.
The InfluxDB 2.x and Cloud equivalent is
[retention period](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#retention-period).
 */
  rp?: string
  retentionRules?: RetentionRules
  /** Schema Type.
Use `explicit` to enforce column names, tags, fields, and data types for
your data.

#### InfluxDB Cloud

- Default is `implicit`.

#### InfluxDB OSS

- Doesn't support `schemaType`.
 */
  schemaType?: SchemaType
}

/**
 * An object that contains updated bucket properties to apply.

*/
export interface PatchBucketRequest {
  /** The name of the bucket.
   */
  name?: string
  /** A description of the bucket.
   */
  description?: string
  retentionRules?: PatchRetentionRules
}

/**
 * Updates to rules to expire or retain data. No rules means no updates.
 */
export type PatchRetentionRules = PatchRetentionRule[]

export interface PatchRetentionRule {
  type?: 'expire'
  /** The number of seconds to keep data.
Default duration is `2592000` (30 days).
`0` represents infinite retention.
 */
  everySeconds: number
  /** The [shard group duration](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#shard).
The number of seconds that each shard group covers.

#### InfluxDB Cloud

- Doesn't use `shardGroupDurationsSeconds`.

#### InfluxDB OSS

- Default value depends on the [bucket retention period](https://docs.influxdata.com/influxdb/v2.3/reference/internals/shards/#shard-group-duration).

#### Related guides

- InfluxDB [shards and shard groups](https://docs.influxdata.com/influxdb/v2.3/reference/internals/shards/)
 */
  shardGroupDurationSeconds?: number
}

export interface Organizations {
  links?: Links
  orgs?: Organization[]
}

export interface Organization {
  readonly links?: {
    self?: Link
    members?: Link
    owners?: Link
    labels?: Link
    secrets?: Link
    buckets?: Link
    tasks?: Link
    dashboards?: Link
  }
  readonly id?: string
  name: string
  description?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  /** If inactive the organization is inactive. */
  status?: 'active' | 'inactive'
}

export interface PostOrganizationRequest {
  /** The name of the organization.
   */
  name: string
  /** The description of the organization.
   */
  description?: string
}

/**
 * An object that contains updated organization properties to apply.

*/
export interface PatchOrganizationRequest {
  /** The name of the organization.
   */
  name?: string
  /** The description of the organization.
   */
  description?: string
}

export type SecretKeysResponse = SecretKeys & {
  readonly links?: {
    self?: string
    org?: string
  }
}

export interface SecretKeys {
  secrets?: string[]
}

export type Secrets = any

export interface Stack {
  id?: string
  orgID?: string
  readonly createdAt?: string
  events?: Array<{
    eventType?: string
    name?: string
    description?: string
    sources?: string[]
    resources?: Array<{
      apiVersion?: string
      resourceID?: string
      kind?: TemplateKind
      templateMetaName?: string
      associations?: Array<{
        kind?: TemplateKind
        metaName?: string
      }>
      links?: {
        self?: string
      }
    }>
    urls?: string[]
    readonly updatedAt?: string
  }>
}

export type TemplateKind =
  | 'Bucket'
  | 'Check'
  | 'CheckDeadman'
  | 'CheckThreshold'
  | 'Dashboard'
  | 'Label'
  | 'NotificationEndpoint'
  | 'NotificationEndpointHTTP'
  | 'NotificationEndpointPagerDuty'
  | 'NotificationEndpointSlack'
  | 'NotificationRule'
  | 'Task'
  | 'Telegraf'
  | 'Variable'

export interface TemplateApply {
  /** Only applies a dry run of the templates passed in the request.

- Validates the template and generates a resource diff and summary.
- Doesn't install templates or make changes to the InfluxDB instance.
 */
  dryRun?: boolean
  /** Organization ID.
InfluxDB applies templates to this organization.
The organization owns all resources created by the template.

To find your organization, see how to
[view organizations](https://docs.influxdata.com/influxdb/v2.3/organizations/view-orgs/).
 */
  orgID?: string
  /** ID of the stack to update.

To apply templates to an existing stack in the organization, use the `stackID` parameter.
If you apply templates without providing a stack ID,
InfluxDB initializes a new stack with all new resources.

To find a stack ID, use the InfluxDB [`/api/v2/stacks` API endpoint](#operation/ListStacks) to list stacks.

#### Related guides

- [Stacks](https://docs.influxdata.com/influxdb/v2.3/influxdb-templates/stacks/)
- [View stacks](https://docs.influxdata.com/influxdb/v2.3/influxdb-templates/stacks/view/)
 */
  stackID?: string
  /** A template object to apply.
A template object has a `contents` property
with an array of InfluxDB resource configurations.

Pass `template` to apply only one template object.
If you use `template`, you can't use the `templates` parameter.
If you want to apply multiple template objects, use `templates` instead.
 */
  template?: {
    contentType?: string
    sources?: string[]
    contents?: Template
  }
  /** A list of template objects to apply.
A template object has a `contents` property
with an array of InfluxDB resource configurations.

Use the `templates` parameter to apply multiple template objects.
If you use `templates`, you can't use the `template` parameter.
 */
  templates?: Array<{
    contentType?: string
    sources?: string[]
    contents?: Template
  }>
  /** An object with key-value pairs that map to **environment references** in templates.

Environment references in templates are `envRef` objects with an `envRef.key`
property.
To substitute a custom environment reference value when applying templates,
pass `envRefs` with the `envRef.key` and the value.

When you apply a template, InfluxDB replaces `envRef` objects in the template
with the values that you provide in the `envRefs` parameter.
For more examples, see how to [define environment references](https://docs.influxdata.com/influxdb/v2.3/influxdb-templates/use/#define-environment-references).

The following template fields may use environment references:

  - `metadata.name`
  - `spec.endpointName`
  - `spec.associations.name`

For more information about including environment references in template fields, see how to
[include user-definable resource names](https://docs.influxdata.com/influxdb/v2.3/influxdb-templates/create/#include-user-definable-resource-names).
 */
  envRefs?: any
  /** An object with key-value pairs that map to **secrets** in queries.

Queries may reference secrets stored in InfluxDB--for example,
the following Flux script retrieves `POSTGRES_USERNAME` and `POSTGRES_PASSWORD`
secrets and then uses them to connect to a PostgreSQL database:

  ```js
  import "sql"
  import "influxdata/influxdb/secrets"

  username = secrets.get(key: "POSTGRES_USERNAME")
  password = secrets.get(key: "POSTGRES_PASSWORD")

  sql.from(
    driverName: "postgres",
    dataSourceName: "postgresql://${username}:${password}@localhost:5432",
    query: "SELECT * FROM example_table",
  )
  ```

To define secret values in your `/api/v2/templates/apply` request,
pass the `secrets` parameter with key-value pairs--for example:

  ```json
  {
    ...
    "secrets": {
      "POSTGRES_USERNAME": "pguser",
      "POSTGRES_PASSWORD": "foo"
    }
    ...
  }
  ```

InfluxDB stores the key-value pairs as secrets that you can access with `secrets.get()`.
Once stored, you can't view secret values in InfluxDB.

#### Related guides

- [How to pass secrets when installing a template](https://docs.influxdata.com/influxdb/v2.3/influxdb-templates/use/#pass-secrets-when-installing-a-template)
 */
  secrets?: any
  /** A list of URLs for template files.

To apply a template manifest file located at a URL, pass `remotes`
with an array that contains the URL.
 */
  remotes?: Array<{
    url: string
    contentType?: string
  }>
  /** A list of `action` objects.
Actions let you customize how InfluxDB applies templates in the request.

You can use the following actions to prevent creating or updating resources:

- A `skipKind` action skips template resources of a specified `kind`.
- A `skipResource` action skips template resources with a specified `metadata.name`
  and `kind`.
 */
  actions?: Array<
    | {
        action?: 'skipKind'
        properties?: {
          kind: TemplateKind
        }
      }
    | {
        action?: 'skipResource'
        properties?: {
          kind: TemplateKind
          resourceTemplateName: string
        }
      }
  >
}

export type Template = Array<{
  apiVersion?: string
  kind?: TemplateKind
  /** Metadata properties used for the resource when the template is applied.
   */
  metadata?: {
    name?: string
  }
  /** Configuration properties used for the resource when the template is applied.
Key-value pairs map to the specification for the resource.

The following code samples show `spec` configurations for template resources:

- A bucket:

  ```json
  { "spec": {
      "name": "iot_center",
      "retentionRules": [{
          "everySeconds": 2.592e+06,
          "type": "expire"
        }]
    }
  }
  ```

- A variable:

  ```json
  { "spec": {
      "language": "flux",
      "name": "Node_Service",
      "query": "import \"influxdata/influxdb/v1\"\r\nv1.tagValues(bucket: \"iot_center\",
          tag: \"service\")",
      "type": "query"
    }
  }
  ```
 */
  spec?: any
}>

export interface TemplateSummary {
  sources?: string[]
  stackID?: string
  summary?: {
    buckets?: Array<{
      id?: string
      orgID?: string
      kind?: TemplateKind
      templateMetaName?: string
      name?: string
      description?: string
      retentionPeriod?: number
      labelAssociations?: TemplateSummaryLabel[]
      envReferences?: TemplateEnvReferences
    }>
    checks?: Array<
      CheckDiscriminator & {
        kind?: TemplateKind
        templateMetaName?: string
        labelAssociations?: TemplateSummaryLabel[]
        envReferences?: TemplateEnvReferences
      }
    >
    dashboards?: Array<{
      id?: string
      orgID?: string
      kind?: TemplateKind
      templateMetaName?: string
      name?: string
      description?: string
      labelAssociations?: TemplateSummaryLabel[]
      charts?: TemplateChart[]
      envReferences?: TemplateEnvReferences
    }>
    labels?: TemplateSummaryLabel[]
    labelMappings?: Array<{
      status?: string
      resourceTemplateMetaName?: string
      resourceName?: string
      resourceID?: string
      resourceType?: string
      labelTemplateMetaName?: string
      labelName?: string
      labelID?: string
    }>
    missingEnvRefs?: string[]
    missingSecrets?: string[]
    notificationEndpoints?: Array<
      NotificationEndpointDiscriminator & {
        kind?: TemplateKind
        templateMetaName?: string
        labelAssociations?: TemplateSummaryLabel[]
        envReferences?: TemplateEnvReferences
      }
    >
    notificationRules?: Array<{
      kind?: TemplateKind
      templateMetaName?: string
      name?: string
      description?: string
      endpointTemplateMetaName?: string
      endpointID?: string
      endpointType?: string
      every?: string
      offset?: string
      messageTemplate?: string
      status?: string
      statusRules?: Array<{
        currentLevel?: string
        previousLevel?: string
      }>
      tagRules?: Array<{
        key?: string
        value?: string
        operator?: string
      }>
      labelAssociations?: TemplateSummaryLabel[]
      envReferences?: TemplateEnvReferences
    }>
    tasks?: Array<{
      kind?: TemplateKind
      templateMetaName?: string
      id?: string
      name?: string
      cron?: string
      description?: string
      every?: string
      offset?: string
      query?: string
      status?: string
      envReferences?: TemplateEnvReferences
    }>
    telegrafConfigs?: Array<
      TelegrafRequest & {
        kind?: TemplateKind
        templateMetaName?: string
        labelAssociations?: TemplateSummaryLabel[]
        envReferences?: TemplateEnvReferences
      }
    >
    variables?: Array<{
      kind?: TemplateKind
      templateMetaName?: string
      id?: string
      orgID?: string
      name?: string
      description?: string
      arguments?: VariableProperties
      labelAssociations?: TemplateSummaryLabel[]
      envReferences?: TemplateEnvReferences
    }>
  }
  diff?: {
    buckets?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: {
        name?: string
        description?: string
        retentionRules?: RetentionRules
      }
      old?: {
        name?: string
        description?: string
        retentionRules?: RetentionRules
      }
    }>
    checks?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: CheckDiscriminator
      old?: CheckDiscriminator
    }>
    dashboards?: Array<{
      stateStatus?: string
      id?: string
      kind?: TemplateKind
      templateMetaName?: string
      new?: {
        name?: string
        description?: string
        charts?: TemplateChart[]
      }
      old?: {
        name?: string
        description?: string
        charts?: TemplateChart[]
      }
    }>
    labels?: Array<{
      stateStatus?: string
      kind?: TemplateKind
      id?: string
      templateMetaName?: string
      new?: {
        name?: string
        color?: string
        description?: string
      }
      old?: {
        name?: string
        color?: string
        description?: string
      }
    }>
    labelMappings?: Array<{
      status?: string
      resourceType?: string
      resourceID?: string
      resourceTemplateMetaName?: string
      resourceName?: string
      labelID?: string
      labelTemplateMetaName?: string
      labelName?: string
    }>
    notificationEndpoints?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: NotificationEndpointDiscriminator
      old?: NotificationEndpointDiscriminator
    }>
    notificationRules?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: {
        name?: string
        description?: string
        endpointName?: string
        endpointID?: string
        endpointType?: string
        every?: string
        offset?: string
        messageTemplate?: string
        status?: string
        statusRules?: Array<{
          currentLevel?: string
          previousLevel?: string
        }>
        tagRules?: Array<{
          key?: string
          value?: string
          operator?: string
        }>
      }
      old?: {
        name?: string
        description?: string
        endpointName?: string
        endpointID?: string
        endpointType?: string
        every?: string
        offset?: string
        messageTemplate?: string
        status?: string
        statusRules?: Array<{
          currentLevel?: string
          previousLevel?: string
        }>
        tagRules?: Array<{
          key?: string
          value?: string
          operator?: string
        }>
      }
    }>
    tasks?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: {
        name?: string
        cron?: string
        description?: string
        every?: string
        offset?: string
        query?: string
        status?: string
      }
      old?: {
        name?: string
        cron?: string
        description?: string
        every?: string
        offset?: string
        query?: string
        status?: string
      }
    }>
    telegrafConfigs?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: TelegrafRequest
      old?: TelegrafRequest
    }>
    variables?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: {
        name?: string
        description?: string
        args?: VariableProperties
      }
      old?: {
        name?: string
        description?: string
        args?: VariableProperties
      }
    }>
  }
  errors?: Array<{
    kind?: TemplateKind
    reason?: string
    fields?: string[]
    indexes?: number[]
  }>
}

export interface TemplateSummaryLabel {
  id?: string
  orgID?: string
  kind?: TemplateKind
  templateMetaName?: string
  name?: string
  properties?: {
    color?: string
    description?: string
  }
  envReferences?: TemplateEnvReferences
}

export type TemplateEnvReferences = Array<{
  /** Field the environment reference corresponds too */
  resourceField: string
  /** Key identified as environment reference and is the key identified in the template */
  envRefKey: string
  /** Value provided to fulfill reference */
  value?: string | number | number | boolean
  /** Default value that will be provided for the reference when no value is provided */
  defaultValue?: string | number | number | boolean
}>

export interface TemplateChart {
  xPos?: number
  yPos?: number
  height?: number
  width?: number
  properties?: ViewProperties
}

export type NotificationEndpointDiscriminator =
  | (SlackNotificationEndpoint & {type: string})
  | (PagerDutyNotificationEndpoint & {type: string})
  | (HTTPNotificationEndpoint & {type: string})
  | (TelegramNotificationEndpoint & {type: string})

export type SlackNotificationEndpoint = NotificationEndpointBase & {
  /** Specifies the URL of the Slack endpoint. Specify either `URL` or `Token`. */
  url?: string
  /** Specifies the API token string. Specify either `URL` or `Token`. */
  token?: string
}

export interface NotificationEndpointBase {
  id?: string
  orgID?: string
  userID?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  /** An optional description of the notification endpoint. */
  description?: string
  name: string
  /** The status of the endpoint. */
  status?: 'active' | 'inactive'
  labels?: Labels
  readonly links?: {
    /** URL for this endpoint. */
    self?: Link
    /** URL to retrieve labels for this endpoint. */
    labels?: Link
    /** URL to retrieve members for this endpoint. */
    members?: Link
    /** URL to retrieve owners for this endpoint. */
    owners?: Link
  }
  type: NotificationEndpointType
}

export type NotificationEndpointType =
  | 'slack'
  | 'pagerduty'
  | 'http'
  | 'telegram'

export type PagerDutyNotificationEndpoint = NotificationEndpointBase & {
  clientURL?: string
  routingKey: string
}

export type HTTPNotificationEndpoint = NotificationEndpointBase & {
  url: string
  username?: string
  password?: string
  token?: string
  method: 'POST' | 'GET' | 'PUT'
  authMethod: 'none' | 'basic' | 'bearer'
  contentTemplate?: string
  /** Customized headers. */
  headers?: any
}

export type TelegramNotificationEndpoint = NotificationEndpointBase & {
  /** Specifies the Telegram bot token. See https://core.telegram.org/bots#creating-a-new-bot . */
  token: string
  /** The ID of the telegram channel; a chat_id in https://core.telegram.org/bots/api#sendmessage . */
  channel: string
}

export type VariableProperties =
  | QueryVariableProperties
  | ConstantVariableProperties
  | MapVariableProperties

export interface QueryVariableProperties {
  type?: 'query'
  values?: {
    query?: string
    language?: string
  }
}

export interface ConstantVariableProperties {
  type?: 'constant'
  values?: string[]
}

export interface MapVariableProperties {
  type?: 'map'
  values?: any
}

export interface TemplateExportByID {
  stackID?: string
  orgIDs?: Array<{
    orgID?: string
    resourceFilters?: {
      byLabel?: string[]
      byResourceKind?: TemplateKind[]
    }
  }>
  resources?: Array<{
    id: string
    kind: TemplateKind
    /** if defined with id, name is used for resource exported by id. if defined independently, resources strictly matching name are exported */
    name?: string
  }>
}

export interface TemplateExportByName {
  stackID?: string
  orgIDs?: Array<{
    orgID?: string
    resourceFilters?: {
      byLabel?: string[]
      byResourceKind?: TemplateKind[]
    }
  }>
  resources?: Array<{
    kind: TemplateKind
    name: string
  }>
}

export interface Runs {
  links?: Links
  runs?: Run[]
}

export interface Run {
  readonly id?: string
  readonly taskID?: string
  readonly status?: 'scheduled' | 'started' | 'failed' | 'success' | 'canceled'
  /** The time [RFC3339 date/time format](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#rfc3339-timestamp) used for the run's `now` option. */
  scheduledFor?: string
  /** An array of logs associated with the run. */
  readonly log?: LogEvent[]
  /** Flux used for the task */
  readonly flux?: string
  /** The time ([RFC3339Nano date/time format](https://go.dev/src/time/format.go)) the run started executing. */
  readonly startedAt?: string
  /** The time ([RFC3339Nano date/time format](https://go.dev/src/time/format.go)) the run finished executing. */
  readonly finishedAt?: string
  /** The time ([RFC3339Nano date/time format](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#rfc3339nano-timestamp)) the run was manually requested. */
  readonly requestedAt?: string
  readonly links?: {
    self?: string
    task?: string
    retry?: string
  }
}

export interface LogEvent {
  /** The time ([RFC3339Nano date/time format](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#rfc3339nano-timestamp)) that the event occurred. */
  readonly time?: string
  /** A description of the event that occurred. */
  readonly message?: string
  /** The ID of the task run that generated the event. */
  readonly runID?: string
}

export interface RunManually {
  /** The time [RFC3339 date/time format](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#rfc3339-timestamp)
used for the run's `now` option.
Default is the server _now_ time.
 */
  scheduledFor?: string
}

export interface Logs {
  readonly events?: LogEvent[]
}

export type Flags = any

export interface PasswordResetBody {
  password: string
}

export interface Checks {
  checks?: Check[]
  links?: Links
}

export type PostCheck = CheckDiscriminator

export interface CheckPatch {
  name?: string
  description?: string
  status?: 'active' | 'inactive'
}

export interface NotificationRules {
  notificationRules?: NotificationRule[]
  links?: Links
}

export type NotificationRule = NotificationRuleDiscriminator

export type NotificationRuleDiscriminator =
  | (SlackNotificationRule & {type: string})
  | (SMTPNotificationRule & {type: string})
  | (PagerDutyNotificationRule & {type: string})
  | (HTTPNotificationRule & {type: string})
  | (TelegramNotificationRule & {type: string})

export type SlackNotificationRule = NotificationRuleBase &
  SlackNotificationRuleBase

export interface NotificationRuleBase {
  /** A timestamp ([RFC3339 date/time format](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#rfc3339-timestamp)) of the latest scheduled and completed run. */
  readonly latestCompleted?: string
  readonly lastRunStatus?: 'failed' | 'success' | 'canceled'
  readonly lastRunError?: string
  readonly id?: string
  endpointID: string
  /** The ID of the organization that owns this notification rule. */
  orgID: string
  /** The ID of the task associated with this notification rule. */
  taskID?: string
  /** The ID of creator used to create this notification rule. */
  readonly ownerID?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  status: TaskStatusType
  /** Human-readable name describing the notification rule. */
  name: string
  sleepUntil?: string
  /** The notification repetition interval. */
  every?: string
  /** Duration to delay after the schedule, before executing check. */
  offset?: string
  runbookLink?: string
  /** Don't notify me more than <limit> times every <limitEvery> seconds. If set, limit cannot be empty. */
  limitEvery?: number
  /** Don't notify me more than <limit> times every <limitEvery> seconds. If set, limitEvery cannot be empty. */
  limit?: number
  /** List of tag rules the notification rule attempts to match. */
  tagRules?: TagRule[]
  /** An optional description of the notification rule. */
  description?: string
  /** List of status rules the notification rule attempts to match. */
  statusRules: StatusRule[]
  labels?: Labels
  readonly links?: {
    /** URL for this endpoint. */
    self?: Link
    /** URL to retrieve labels for this notification rule. */
    labels?: Link
    /** URL to retrieve members for this notification rule. */
    members?: Link
    /** URL to retrieve owners for this notification rule. */
    owners?: Link
    /** URL to retrieve flux script for this notification rule. */
    query?: Link
  }
}

export interface TagRule {
  key?: string
  value?: string
  operator?: 'equal' | 'notequal' | 'equalregex' | 'notequalregex'
}

export interface StatusRule {
  currentLevel?: RuleStatusLevel
  previousLevel?: RuleStatusLevel
  count?: number
  period?: string
}

/**
 * The state to record if check matches a criteria.
 */
export type RuleStatusLevel =
  | 'UNKNOWN'
  | 'OK'
  | 'INFO'
  | 'CRIT'
  | 'WARN'
  | 'ANY'

export interface SlackNotificationRuleBase {
  type: 'slack'
  channel?: string
  messageTemplate: string
}

export type SMTPNotificationRule = NotificationRuleBase &
  SMTPNotificationRuleBase

export interface SMTPNotificationRuleBase {
  type: 'smtp'
  subjectTemplate: string
  bodyTemplate?: string
  to: string
}

export type PagerDutyNotificationRule = NotificationRuleBase &
  PagerDutyNotificationRuleBase

export interface PagerDutyNotificationRuleBase {
  type: 'pagerduty'
  messageTemplate: string
}

export type HTTPNotificationRule = NotificationRuleBase &
  HTTPNotificationRuleBase

export interface HTTPNotificationRuleBase {
  type: 'http'
  url?: string
}

export type TelegramNotificationRule = NotificationRuleBase &
  TelegramNotificationRuleBase

export interface TelegramNotificationRuleBase {
  /** The discriminator between other types of notification rules is "telegram". */
  type: 'telegram'
  /** The message template as a flux interpolated string. */
  messageTemplate: string
  /** Parse mode of the message text per https://core.telegram.org/bots/api#formatting-options. Defaults to "MarkdownV2". */
  parseMode?: 'MarkdownV2' | 'HTML' | 'Markdown'
  /** Disables preview of web links in the sent messages when "true". Defaults to "false". */
  disableWebPagePreview?: boolean
}

export type PostNotificationRule = NotificationRuleDiscriminator

/**
 * Rendered flux that backs the check or notification.
 */
export interface FluxResponse {
  flux?: string
}

export interface NotificationRuleUpdate {
  name?: string
  description?: string
  status?: 'active' | 'inactive'
}

export interface NotificationEndpoints {
  notificationEndpoints?: NotificationEndpoint[]
  links?: Links
}

export type NotificationEndpoint = NotificationEndpointDiscriminator

export type PostNotificationEndpoint = NotificationEndpointDiscriminator

export interface NotificationEndpointUpdate {
  name?: string
  description?: string
  status?: 'active' | 'inactive'
}

export interface HealthCheck {
  name: string
  message?: string
  checks?: HealthCheck[]
  status: 'pass' | 'fail'
  version?: string
  commit?: string
}

export interface Ready {
  status?: 'ready'
  started?: string
  up?: string
}

export interface Users {
  links?: {
    self?: string
  }
  users?: UserResponse[]
}

export interface User {
  readonly id?: string
  oauthID?: string
  name: string
  /** If inactive the user is inactive. */
  status?: 'active' | 'inactive'
}

export interface IsOnboarding {
  /** If `true`, the InfluxDB instance hasn't had initial setup;
`false` otherwise.
 */
  allowed?: boolean
}

export interface OnboardingRequest {
  username: string
  password?: string
  org: string
  bucket: string
  retentionPeriodSeconds?: number
  /** Retention period *in nanoseconds* for the new bucket. This key's name has been misleading since OSS 2.0 GA, please transition to use `retentionPeriodSeconds`
   */
  retentionPeriodHrs?: number
  /** Authentication token to set on the initial user. If not specified, the server will generate a token.
   */
  token?: string
}

export interface OnboardingResponse {
  user?: UserResponse
  org?: Organization
  bucket?: Bucket
  auth?: Authorization
}

export type Authorization = AuthorizationUpdateRequest & {
  readonly createdAt?: string
  readonly updatedAt?: string
  /** The ID of the organization. */
  orgID?: string
  /** A list of permissions for an authorization.
An authorization must have at least one permission.
 */
  permissions?: Permission[]
  readonly id?: string
  /** The API token for authenticating InfluxDB API and CLI requests.
   */
  readonly token?: string
  /** The ID of the user that the token is scoped to. */
  readonly userID?: string
  /** The name of the user that the token is scoped to. */
  readonly user?: string
  /** The name of the organization that owns the token. */
  readonly org?: string
  readonly links?: {
    readonly self?: Link
    readonly user?: Link
  }
}

export interface AuthorizationUpdateRequest {
  /** Status of the token. If `inactive`, requests using the token will be rejected. */
  status?: 'active' | 'inactive'
  /** A description of the token. */
  description?: string
}

export interface Permission {
  action: 'read' | 'write'
  resource: Resource
}

export interface Resource {
  /** The type of resource.
In a `permission`, applies the permission to all resources of this type.
 */
  type:
    | 'authorizations'
    | 'buckets'
    | 'dashboards'
    | 'orgs'
    | 'sources'
    | 'tasks'
    | 'telegrafs'
    | 'users'
    | 'variables'
    | 'scrapers'
    | 'secrets'
    | 'labels'
    | 'views'
    | 'documents'
    | 'notificationRules'
    | 'notificationEndpoints'
    | 'checks'
    | 'dbrp'
    | 'notebooks'
    | 'annotations'
    | 'remotes'
    | 'replications'
    | 'instance'
    | 'flows'
    | 'functions'
  /** The ID of a specific resource.
In a `permission`, applies the permission to only the resource with this ID.
 */
  id?: string
  /** Optional: A name for the resource.
Not all resource types have a name field.
 */
  name?: string
  /** The ID of the organization that owns the resource.
In a `permission`, applies the permission to all resources of `type` owned by this organization.
 */
  orgID?: string
  /** Optional: The name of the organization with `orgID`.
   */
  org?: string
}

export interface Authorizations {
  readonly links?: Links
  authorizations?: Authorization[]
}

export type AuthorizationPostRequest = AuthorizationUpdateRequest & {
  /** The ID of the organization that owns the authorization.
   */
  orgID?: string
  /** The ID of the user that the authorization is scoped to.
   */
  userID?: string
  /** A list of permissions for an authorization.
An authorization must have at least one permission.
 */
  permissions?: Permission[]
}

export interface Variables {
  variables?: Variable[]
}

export interface Variable {
  readonly links?: {
    self?: string
    org?: string
    labels?: string
  }
  readonly id?: string
  orgID: string
  name: string
  description?: string
  selected?: string[]
  labels?: Labels
  arguments: VariableProperties
  createdAt?: string
  updatedAt?: string
}

export interface Sources {
  links?: {
    self?: string
  }
  sources?: Source[]
}

export interface Source {
  links?: {
    self?: string
    query?: string
    health?: string
    buckets?: string
  }
  id?: string
  orgID?: string
  default?: boolean
  name?: string
  type?: 'v1' | 'v2' | 'self'
  url?: string
  insecureSkipVerify?: boolean
  telegraf?: string
  token?: string
  username?: string
  password?: string
  sharedSecret?: string
  metaUrl?: string
  defaultRP?: string
  readonly languages?: Array<'flux' | 'influxql'>
}

export interface ScraperTargetResponses {
  configurations?: ScraperTargetResponse[]
}

export type ScraperTargetResponse = ScraperTargetRequest & {
  readonly id?: string
  /** The name of the organization. */
  org?: string
  /** The bucket name. */
  bucket?: string
  readonly links?: {
    self?: Link
    members?: Link
    owners?: Link
    bucket?: Link
    organization?: Link
  }
}

export interface ScraperTargetRequest {
  /** The name of the scraper target. */
  name?: string
  /** The type of the metrics to be parsed. */
  type?: 'prometheus'
  /** The URL of the metrics endpoint. */
  url?: string
  /** The organization ID. */
  orgID?: string
  /** The ID of the bucket to write to. */
  bucketID?: string
  /** Skip TLS verification on endpoint. */
  allowInsecure?: boolean
}

export interface MetadataBackup {
  kv: string
  sql: string
  buckets: BucketMetadataManifests
}

export type BucketMetadataManifests = BucketMetadataManifest[]

export interface BucketMetadataManifest {
  organizationID: string
  organizationName: string
  bucketID: string
  bucketName: string
  description?: string
  defaultRetentionPolicy: string
  retentionPolicies: RetentionPolicyManifests
}

export type RetentionPolicyManifests = RetentionPolicyManifest[]

export interface RetentionPolicyManifest {
  name: string
  replicaN: number
  duration: number
  shardGroupDuration: number
  shardGroups: ShardGroupManifests
  subscriptions: SubscriptionManifests
}

export type ShardGroupManifests = ShardGroupManifest[]

export interface ShardGroupManifest {
  id: number
  startTime: string
  endTime: string
  deletedAt?: string
  truncatedAt?: string
  shards: ShardManifests
}

export type ShardManifests = ShardManifest[]

export interface ShardManifest {
  id: number
  shardOwners: ShardOwners
}

export type ShardOwners = ShardOwner[]

export interface ShardOwner {
  /** The ID of the node that owns the shard. */
  nodeID: number
}

export type SubscriptionManifests = SubscriptionManifest[]

export interface SubscriptionManifest {
  name: string
  mode: string
  destinations: string[]
}

export interface RestoredBucketMappings {
  /** New ID of the restored bucket */
  id: string
  name: string
  shardMappings: BucketShardMappings
}

export type BucketShardMappings = BucketShardMapping[]

export interface BucketShardMapping {
  oldId: number
  newId: number
}

export interface Config {
  config?: any
}

export interface RemoteConnections {
  remotes?: RemoteConnection[]
}

export interface RemoteConnection {
  id: string
  name: string
  orgID: string
  description?: string
  remoteURL: string
  remoteOrgID: string
  allowInsecureTLS: boolean
}

export interface RemoteConnectionCreationRequest {
  name: string
  description?: string
  orgID: string
  remoteURL: string
  remoteAPIToken: string
  remoteOrgID: string
  allowInsecureTLS: boolean
}

export interface RemoteConnectionUpdateRequest {
  name?: string
  description?: string
  remoteURL?: string
  remoteAPIToken?: string
  remoteOrgID?: string
  allowInsecureTLS?: boolean
}

export interface Replications {
  replications?: Replication[]
}

export interface Replication {
  id: string
  name: string
  description?: string
  orgID: string
  remoteID: string
  localBucketID: string
  remoteBucketID?: string
  remoteBucketName?: string
  maxQueueSizeBytes: number
  currentQueueSizeBytes: number
  latestResponseCode?: number
  latestErrorMessage?: string
  dropNonRetryableData?: boolean
}

export interface ReplicationCreationRequest {
  name: string
  description?: string
  orgID: string
  remoteID: string
  localBucketID: string
  remoteBucketID?: string
  remoteBucketName?: string
  maxQueueSizeBytes: number
  dropNonRetryableData?: boolean
  maxAgeSeconds: number
}

export interface ReplicationUpdateRequest {
  name?: string
  description?: string
  remoteID?: string
  remoteBucketID?: string
  remoteBucketName?: string
  maxQueueSizeBytes?: number
  dropNonRetryableData?: boolean
  maxAgeSeconds?: number
}

export interface Dashboards {
  links?: Links
  dashboards?: Dashboard[]
}

export interface Tasks {
  readonly links?: Links
  tasks?: Task[]
}

export interface Task {
  readonly id: string
  /** An [organization](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#organization) ID.
Specifies the organization that owns the task.
 */
  orgID: string
  /** An [organization](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#organization) name.
Specifies the organization that owns the task.
 */
  org?: string
  /** The name of the task. */
  name: string
  /** A [user](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#user) ID.
Specifies the owner of the task.

To find a user ID, you can use the
[`GET /api/v2/users` endpoint](#operation/GetUsers) to
list users.
 */
  ownerID?: string
  /** A description of the task. */
  description?: string
  status?: TaskStatusType
  labels?: Labels
  /** An authorization ID.
Specifies the authorization used when the task communicates with the query engine.

To find an authorization ID, you can use the
[`GET /api/v2/authorizations` endpoint](#operation/GetAuthorizations) to
list authorizations.
 */
  authorizationID?: string
  /** The Flux script that the task executes. */
  flux: string
  /** The interval ([duration literal](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#rfc3339-timestamp)) at which the task runs. `every` also determines when the task first runs, depending on the specified time. */
  every?: string
  /** A [Cron expression](https://en.wikipedia.org/wiki/Cron#Overview) that defines the schedule on which the task runs. InfluxDB uses the system time when evaluating Cron expressions. */
  cron?: string
  /** A [duration](https://docs.influxdata.com/flux/v0.x/spec/lexical-elements/#duration-literals) to delay execution of the task after the scheduled time has elapsed. `0` removes the offset. */
  offset?: string
  /** A timestamp ([RFC3339 date/time format](https://docs.influxdata.com/influxdb/v2.3/reference/glossary/#rfc3339-timestamp)) of the latest scheduled and completed run. */
  readonly latestCompleted?: string
  readonly lastRunStatus?: 'failed' | 'success' | 'canceled'
  readonly lastRunError?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  readonly links?: {
    self?: Link
    owners?: Link
    members?: Link
    runs?: Link
    logs?: Link
    labels?: Link
  }
}

export interface TaskCreateRequest {
  /** The ID of the organization that owns this Task. */
  orgID?: string
  /** The name of the organization that owns this Task. */
  org?: string
  status?: TaskStatusType
  /** The Flux script to run for this task. */
  flux: string
  /** An optional description of the task. */
  description?: string
}

export interface TaskUpdateRequest {
  status?: TaskStatusType
  /** The Flux script that the task runs. */
  flux?: string
  /** Update the 'name' option in the flux script. */
  name?: string
  /** Update the 'every' option in the flux script. */
  every?: string
  /** Update the 'cron' option in the flux script. */
  cron?: string
  /** Update the 'offset' option in the flux script. */
  offset?: string
  /** Update the description of the task. */
  description?: string
}

export interface Scripts {
  scripts?: Script[]
}

export interface Script {
  readonly id?: string
  name: string
  description?: string
  orgID: string
  /** The script to execute. */
  script: string
  language?: ScriptLanguage
  /** The invocation endpoint address. */
  url?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  /** The list of label names associated with the script. */
  labels?: string[]
}

export type ScriptLanguage = 'flux'

export interface ScriptCreateRequest {
  /** Script name. The name must be unique within the organization. */
  name: string
  /** Script description. A description of the script. */
  description: string
  /** The script to execute. */
  script: string
  language: ScriptLanguage
}

export interface ScriptUpdateRequest {
  name?: string
  description?: string
  /** script is script to be executed */
  script?: string
}

export interface ScriptInvocationParams {
  /** The script parameters.
`params` contains key-value pairs that map values to the **params.keys**
in a script.
When you invoke a script with `params`, InfluxDB passes the values as
invocation parameters to the script.
 */
  params?: any
}

/**
 * The response body contains the results of the executed script.
The response is user-defined and dynamic.

*/
export type ScriptHTTPResponseData = string
