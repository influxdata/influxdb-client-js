// This file is generated by [oats][0] and should not be edited by hand.
//
// [0]: https://github.com/influxdata/oats

export interface Error {
  /** code is the machine-readable error code. */
  readonly code:
    | 'internal error'
    | 'not found'
    | 'conflict'
    | 'invalid'
    | 'unprocessable entity'
    | 'empty value'
    | 'unavailable'
    | 'forbidden'
    | 'too many requests'
    | 'unauthorized'
    | 'method not allowed'
    | 'request too large'
    | 'unsupported media type'
  /** message is a human-readable message. */
  readonly message: string
  /** op describes the logical code operation during error. Useful for debugging. */
  readonly op?: string
  /** err is a stack of errors that occurred during processing of the request. Useful for debugging. */
  readonly err?: string
}

export interface Routes {
  authorizations?: string
  buckets?: string
  dashboards?: string
  external?: {
    statusFeed?: string
  }
  variables?: string
  me?: string
  flags?: string
  orgs?: string
  query?: {
    self?: string
    ast?: string
    analyze?: string
    suggestions?: string
  }
  setup?: string
  signin?: string
  signout?: string
  sources?: string
  system?: {
    metrics?: string
    debug?: string
    health?: string
  }
  tasks?: string
  telegrafs?: string
  users?: string
  write?: string
}

export interface DBRPs {
  content?: DBRP[]
}

export interface DBRP {
  /** the mapping identifier */
  readonly id: string
  /** the organization ID that owns this mapping. */
  orgID: string
  /** the bucket ID used as target for the translation. */
  bucketID: string
  /** InfluxDB v1 database */
  database: string
  /** InfluxDB v1 retention policy */
  retention_policy: string
  /** Specify if this mapping represents the default retention policy for the database specificed. */
  default: boolean
  links?: Links
}

export interface Links {
  next?: Link
  self: Link
  prev?: Link
}

/**
 * URI of resource.
 */
export type Link = string

export interface DBRPCreate {
  /** the organization ID that owns this mapping. */
  orgID?: string
  /** the organization that owns this mapping. */
  org?: string
  /** the bucket ID used as target for the translation. */
  bucketID: string
  /** InfluxDB v1 database */
  database: string
  /** InfluxDB v1 retention policy */
  retention_policy: string
  /** Specify if this mapping represents the default retention policy for the database specificed. */
  default?: boolean
}

export interface DBRPGet {
  content?: DBRP
}

export interface DBRPUpdate {
  /** InfluxDB v1 retention policy */
  retention_policy?: string
  default?: boolean
}

export interface TelegrafPlugins {
  version?: string
  os?: string
  plugins?: TelegrafPlugin[]
}

export interface TelegrafPlugin {
  type?: string
  name?: string
  description?: string
  config?: string
}

export interface Telegrafs {
  configurations?: Telegraf[]
}

export type Telegraf = TelegrafRequest & {
  readonly id?: string
  readonly links?: {
    self?: Link
    labels?: Link
    members?: Link
    owners?: Link
  }
  readonly labels?: Labels
}

export interface TelegrafRequest {
  name?: string
  description?: string
  metadata?: {
    buckets?: string[]
  }
  config?: string
  orgID?: string
}

export type Labels = Label[]

export interface Label {
  readonly id?: string
  readonly orgID?: string
  name?: string
  /** Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value. */
  properties?: any
}

export interface TelegrafPluginRequest {
  name?: string
  description?: string
  plugins?: Array<{
    type?: string
    name?: string
    alias?: string
    description?: string
    config?: string
  }>
  metadata?: {
    buckets?: string[]
  }
  config?: string
  orgID?: string
}

export interface LabelsResponse {
  labels?: Labels
  links?: Links
}

export interface LabelMapping {
  labelID?: string
}

export interface LabelResponse {
  label?: Label
  links?: Links
}

export interface ResourceMembers {
  links?: {
    self?: string
  }
  users?: ResourceMember[]
}

export type ResourceMember = UserResponse & {
  role?: 'member'
}

export interface UserResponse {
  readonly id?: string
  oauthID?: string
  name: string
  /** If inactive the user is inactive. */
  status?: 'active' | 'inactive'
  readonly links?: {
    self?: string
  }
}

export interface AddResourceMemberRequestBody {
  id: string
  name?: string
}

export interface ResourceOwners {
  links?: {
    self?: string
  }
  users?: ResourceOwner[]
}

export type ResourceOwner = UserResponse & {
  role?: 'owner'
}

export interface LineProtocolError {
  /** Code is the machine-readable error code. */
  readonly code:
    | 'internal error'
    | 'not found'
    | 'conflict'
    | 'invalid'
    | 'empty value'
    | 'unavailable'
  /** Message is a human-readable message. */
  readonly message: string
  /** Op describes the logical code operation during error. Useful for debugging. */
  readonly op: string
  /** Err is a stack of errors that occurred during processing of the request. Useful for debugging. */
  readonly err: string
  /** First line within sent body containing malformed data */
  readonly line?: number
}

export interface LineProtocolLengthError {
  /** Code is the machine-readable error code. */
  readonly code: 'invalid'
  /** Message is a human-readable message. */
  readonly message: string
}

/**
 * The delete predicate request.
 */
export interface DeletePredicateRequest {
  /** RFC3339Nano */
  start: string
  /** RFC3339Nano */
  stop: string
  /** InfluxQL-like delete statement */
  predicate?: string
}

export interface LabelCreateRequest {
  orgID: string
  name: string
  /** Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value. */
  properties?: any
}

export interface LabelUpdate {
  name?: string
  /** Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value. */
  properties?: any
}

export type Dashboard = CreateDashboardRequest & {
  links?: {
    self?: Link
    cells?: Link
    members?: Link
    owners?: Link
    labels?: Link
    org?: Link
  }
  readonly id?: string
  meta?: {
    createdAt?: string
    updatedAt?: string
  }
  cells?: Cells
  labels?: Labels
}

export interface CreateDashboardRequest {
  /** The ID of the organization that owns the dashboard. */
  orgID: string
  /** The user-facing name of the dashboard. */
  name: string
  /** The user-facing description of the dashboard. */
  description?: string
}

export type Cells = Cell[]

export interface Cell {
  id?: string
  links?: {
    self?: string
    view?: string
  }
  x?: number
  y?: number
  w?: number
  h?: number
  /** The reference to a view from the views API. */
  viewID?: string
}

export type DashboardWithViewProperties = CreateDashboardRequest & {
  links?: {
    self?: Link
    cells?: Link
    members?: Link
    owners?: Link
    labels?: Link
    org?: Link
  }
  readonly id?: string
  meta?: {
    createdAt?: string
    updatedAt?: string
  }
  cells?: CellsWithViewProperties
  labels?: Labels
}

export type CellsWithViewProperties = CellWithViewProperties[]

export type CellWithViewProperties = Cell & {
  name?: string
  properties?: ViewProperties
}

export type ViewProperties =
  | LinePlusSingleStatProperties
  | XYViewProperties
  | SingleStatViewProperties
  | HistogramViewProperties
  | GaugeViewProperties
  | TableViewProperties
  | SimpleTableViewProperties
  | MarkdownViewProperties
  | CheckViewProperties
  | ScatterViewProperties
  | HeatmapViewProperties
  | MosaicViewProperties
  | BandViewProperties
  | GeoViewProperties

export interface LinePlusSingleStatProperties {
  timeFormat?: string
  type: 'line-plus-single-stat'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  axes: Axes
  staticLegend?: StaticLegend
  xColumn?: string
  generateXAxisTicks?: string[]
  xTotalTicks?: number
  xTickStart?: number
  xTickStep?: number
  yColumn?: string
  generateYAxisTicks?: string[]
  yTotalTicks?: number
  yTickStart?: number
  yTickStep?: number
  shadeBelow?: boolean
  hoverDimension?: 'auto' | 'x' | 'y' | 'xy'
  position: 'overlaid' | 'stacked'
  prefix: string
  suffix: string
  decimalPlaces: DecimalPlaces
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export interface DashboardQuery {
  /** The text of the Flux query. */
  text?: string
  editMode?: QueryEditMode
  name?: string
  builderConfig?: BuilderConfig
}

export type QueryEditMode = 'builder' | 'advanced'

export interface BuilderConfig {
  buckets?: string[]
  tags?: BuilderTagsType[]
  functions?: BuilderFunctionsType[]
  aggregateWindow?: {
    period?: string
    fillValues?: boolean
  }
}

export interface BuilderTagsType {
  key?: string
  values?: string[]
  aggregateFunctionType?: BuilderAggregateFunctionType
}

export type BuilderAggregateFunctionType = 'filter' | 'group'

export interface BuilderFunctionsType {
  name?: string
}

/**
 * Defines an encoding of data value into color space.
 */
export interface DashboardColor {
  /** The unique ID of the view color. */
  id: string
  /** Type is how the color is used. */
  type: 'min' | 'max' | 'threshold' | 'scale' | 'text' | 'background'
  /** The hex number of the color */
  hex: string
  /** The user-facing name of the hex color. */
  name: string
  /** The data value mapped to this color. */
  value: number
}

/**
 * The viewport for a View's visualizations
 */
export interface Axes {
  x: Axis
  y: Axis
}

/**
 * The description of a particular axis for a visualization.
 */
export interface Axis {
  /** The extents of an axis in the form [lower, upper]. Clients determine whether bounds are to be inclusive or exclusive of their limits */
  bounds?: string[]
  /** Label is a description of this Axis */
  label?: string
  /** Prefix represents a label prefix for formatting axis values. */
  prefix?: string
  /** Suffix represents a label suffix for formatting axis values. */
  suffix?: string
  /** Base represents the radix for formatting axis values. */
  base?: '' | '2' | '10'
  scale?: AxisScale
}

/**
 * Scale is the axis formatting scale. Supported: "log", "linear"
 */
export type AxisScale = 'log' | 'linear'

/**
 * StaticLegend represents the options specific to the static legend
 */
export interface StaticLegend {
  colorizeRows?: boolean
  heightRatio?: number
  show?: boolean
  opacity?: number
  orientationThreshold?: number
  valueAxis?: string
  widthRatio?: number
}

/**
 * Indicates whether decimal places should be enforced, and how many digits it should show.
 */
export interface DecimalPlaces {
  /** Indicates whether decimal point setting should be enforced */
  isEnforced?: boolean
  /** The number of digits after decimal to display */
  digits?: number
}

export interface XYViewProperties {
  timeFormat?: string
  type: 'xy'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  /** An object that contains information about the color mapping */
  colorMapping?: ColorMapping
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  axes: Axes
  staticLegend?: StaticLegend
  xColumn?: string
  generateXAxisTicks?: string[]
  xTotalTicks?: number
  xTickStart?: number
  xTickStep?: number
  yColumn?: string
  generateYAxisTicks?: string[]
  yTotalTicks?: number
  yTickStart?: number
  yTickStep?: number
  shadeBelow?: boolean
  hoverDimension?: 'auto' | 'x' | 'y' | 'xy'
  position: 'overlaid' | 'stacked'
  geom: XYGeom
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

/**
 * A color mapping is an object that maps time series data to a UI color scheme to allow the UI to render graphs consistent colors across reloads.
 */
export type ColorMapping = any

export type XYGeom = 'line' | 'step' | 'stacked' | 'bar' | 'monotoneX'

export interface SingleStatViewProperties {
  type: 'single-stat'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  prefix: string
  tickPrefix: string
  suffix: string
  tickSuffix: string
  staticLegend?: StaticLegend
  decimalPlaces: DecimalPlaces
}

export interface HistogramViewProperties {
  type: 'histogram'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  xColumn: string
  fillColumns: string[]
  xDomain: number[]
  xAxisLabel: string
  position: 'overlaid' | 'stacked'
  binCount: number
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export interface GaugeViewProperties {
  type: 'gauge'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  prefix: string
  tickPrefix: string
  suffix: string
  tickSuffix: string
  decimalPlaces: DecimalPlaces
}

export interface TableViewProperties {
  type: 'table'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  tableOptions: {
    /** verticalTimeAxis describes the orientation of the table by indicating whether the time axis will be displayed vertically */
    verticalTimeAxis?: boolean
    sortBy?: RenamableField
    /** Wrapping describes the text wrapping style to be used in table views */
    wrapping?: 'truncate' | 'wrap' | 'single-line'
    /** fixFirstColumn indicates whether the first column of the table should be locked */
    fixFirstColumn?: boolean
  }
  /** fieldOptions represent the fields retrieved by the query with customization options */
  fieldOptions: RenamableField[]
  /** timeFormat describes the display format for time values according to moment.js date formatting */
  timeFormat: string
  decimalPlaces: DecimalPlaces
}

/**
 * Describes a field that can be renamed and made visible or invisible.
 */
export interface RenamableField {
  /** The calculated name of a field. */
  readonly internalName?: string
  /** The name that a field is renamed to by the user. */
  displayName?: string
  /** Indicates whether this field should be visible on the table. */
  visible?: boolean
}

export interface SimpleTableViewProperties {
  type: 'simple-table'
  showAll: boolean
  queries: DashboardQuery[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
}

export interface MarkdownViewProperties {
  type: 'markdown'
  shape: 'chronograf-v2'
  note: string
}

export interface CheckViewProperties {
  type: 'check'
  shape: 'chronograf-v2'
  checkID: string
  check?: Check
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export type Check = CheckDiscriminator

export type CheckDiscriminator =
  | (DeadmanCheck & {type: string})
  | (ThresholdCheck & {type: string})
  | (CustomCheck & {type: string})

export type DeadmanCheck = CheckBase & {
  type: 'deadman'
  /** String duration before deadman triggers. */
  timeSince?: string
  /** String duration for time that a series is considered stale and should not trigger deadman. */
  staleTime?: string
  /** If only zero values reported since time, trigger an alert */
  reportZero?: boolean
  level?: CheckStatusLevel
  /** Check repetition interval. */
  every?: string
  /** Duration to delay after the schedule, before executing check. */
  offset?: string
  /** List of tags to write to each status. */
  tags?: Array<{
    key?: string
    value?: string
  }>
  /** The template used to generate and write a status message. */
  statusMessageTemplate?: string
}

export interface CheckBase {
  readonly id?: string
  name: string
  /** The ID of the organization that owns this check. */
  orgID: string
  /** The ID of the task associated with this check. */
  taskID?: string
  /** The ID of creator used to create this check. */
  readonly ownerID?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  query: DashboardQuery
  status?: TaskStatusType
  /** An optional description of the check. */
  description?: string
  /** Timestamp of latest scheduled, completed run, RFC3339. */
  readonly latestCompleted?: string
  readonly lastRunStatus?: 'failed' | 'success' | 'canceled'
  readonly lastRunError?: string
  labels?: Labels
  readonly links?: {
    /** URL for this check */
    self?: Link
    /** URL to retrieve labels for this check */
    labels?: Link
    /** URL to retrieve members for this check */
    members?: Link
    /** URL to retrieve owners for this check */
    owners?: Link
    /** URL to retrieve flux script for this check */
    query?: Link
  }
}

export type TaskStatusType = 'active' | 'inactive'

/**
 * The state to record if check matches a criteria.
 */
export type CheckStatusLevel = 'UNKNOWN' | 'OK' | 'INFO' | 'CRIT' | 'WARN'

export type ThresholdCheck = CheckBase & {
  type: 'threshold'
  thresholds?: Threshold[]
  /** Check repetition interval. */
  every?: string
  /** Duration to delay after the schedule, before executing check. */
  offset?: string
  /** List of tags to write to each status. */
  tags?: Array<{
    key?: string
    value?: string
  }>
  /** The template used to generate and write a status message. */
  statusMessageTemplate?: string
}

export type Threshold =
  | (GreaterThreshold & {type: string})
  | (LesserThreshold & {type: string})
  | (RangeThreshold & {type: string})

export type GreaterThreshold = ThresholdBase & {
  type: 'greater'
  value: number
}

export interface ThresholdBase {
  level?: CheckStatusLevel
  /** If true, only alert if all values meet threshold. */
  allValues?: boolean
}

export type LesserThreshold = ThresholdBase & {
  type: 'lesser'
  value: number
}

export type RangeThreshold = ThresholdBase & {
  type: 'range'
  min: number
  max: number
  within: boolean
}

export type CustomCheck = CheckBase & {
  type: 'custom'
}

export interface ScatterViewProperties {
  timeFormat?: string
  type: 'scatter'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: string[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  xColumn: string
  generateXAxisTicks?: string[]
  xTotalTicks?: number
  xTickStart?: number
  xTickStep?: number
  yColumn: string
  generateYAxisTicks?: string[]
  yTotalTicks?: number
  yTickStart?: number
  yTickStep?: number
  fillColumns: string[]
  symbolColumns: string[]
  xDomain: number[]
  yDomain: number[]
  xAxisLabel: string
  yAxisLabel: string
  xPrefix: string
  xSuffix: string
  yPrefix: string
  ySuffix: string
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export interface HeatmapViewProperties {
  timeFormat?: string
  type: 'heatmap'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: string[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  xColumn: string
  generateXAxisTicks?: string[]
  xTotalTicks?: number
  xTickStart?: number
  xTickStep?: number
  yColumn: string
  generateYAxisTicks?: string[]
  yTotalTicks?: number
  yTickStart?: number
  yTickStep?: number
  xDomain: number[]
  yDomain: number[]
  xAxisLabel: string
  yAxisLabel: string
  xPrefix: string
  xSuffix: string
  yPrefix: string
  ySuffix: string
  binSize: number
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export interface MosaicViewProperties {
  timeFormat?: string
  type: 'mosaic'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: string[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  xColumn: string
  generateXAxisTicks?: string[]
  xTotalTicks?: number
  xTickStart?: number
  xTickStep?: number
  yLabelColumnSeparator?: string
  yLabelColumns?: string[]
  ySeriesColumns: string[]
  fillColumns: string[]
  xDomain: number[]
  yDomain: number[]
  xAxisLabel: string
  yAxisLabel: string
  xPrefix: string
  xSuffix: string
  yPrefix: string
  ySuffix: string
  hoverDimension?: 'auto' | 'x' | 'y' | 'xy'
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export interface BandViewProperties {
  timeFormat?: string
  type: 'band'
  queries: DashboardQuery[]
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  shape: 'chronograf-v2'
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  axes: Axes
  staticLegend?: StaticLegend
  xColumn?: string
  generateXAxisTicks?: string[]
  xTotalTicks?: number
  xTickStart?: number
  xTickStep?: number
  yColumn?: string
  generateYAxisTicks?: string[]
  yTotalTicks?: number
  yTickStart?: number
  yTickStep?: number
  upperColumn?: string
  mainColumn?: string
  lowerColumn?: string
  hoverDimension?: 'auto' | 'x' | 'y' | 'xy'
  geom: XYGeom
  legendColorizeRows?: boolean
  legendHide?: boolean
  legendOpacity?: number
  legendOrientationThreshold?: number
}

export interface GeoViewProperties {
  type: 'geo'
  queries: DashboardQuery[]
  shape: 'chronograf-v2'
  /** Coordinates of the center of the map */
  center: {
    /** Latitude of the center of the map */
    lat: number
    /** Longitude of the center of the map */
    lon: number
  }
  /** Zoom level used for initial display of the map */
  zoom: number
  /** If true, map zoom and pan controls are enabled on the dashboard view */
  allowPanAndZoom: boolean
  /** If true, search results get automatically regroupped so that lon,lat and value are treated as columns */
  detectCoordinateFields: boolean
  /** If true, S2 column is used to calculate lat/lon */
  useS2CellID?: boolean
  /** String to define the column */
  s2Column?: string
  latLonColumns?: LatLonColumns
  /** Define map type - regular, satellite etc. */
  mapStyle?: string
  note: string
  /** If true, will display note when empty */
  showNoteWhenEmpty: boolean
  /** Colors define color encoding of data into a visualization */
  colors?: DashboardColor[]
  /** List of individual layers shown in the map */
  layers: GeoViewLayer[]
}

/**
 * Object type to define lat/lon columns
 */
export interface LatLonColumns {
  lat: LatLonColumn
  lon: LatLonColumn
}

/**
 * Object type for key and column definitions
 */
export interface LatLonColumn {
  /** Key to determine whether the column is tag/field */
  key: string
  /** Column to look up Lat/Lon */
  column: string
}

export type GeoViewLayer =
  | GeoCircleViewLayer
  | GeoHeatMapViewLayer
  | GeoPointMapViewLayer
  | GeoTrackMapViewLayer

export type GeoCircleViewLayer = GeoViewLayerProperties & {
  /** Radius field */
  radiusField: string
  radiusDimension: Axis
  /** Circle color field */
  colorField: string
  colorDimension: Axis
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  /** Maximum radius size in pixels */
  radius?: number
  /** Interpolate circle color based on displayed value */
  interpolateColors?: boolean
}

export interface GeoViewLayerProperties {
  type: 'heatmap' | 'circleMap' | 'pointMap' | 'trackMap'
}

export type GeoHeatMapViewLayer = GeoViewLayerProperties & {
  /** Intensity field */
  intensityField: string
  intensityDimension: Axis
  /** Radius size in pixels */
  radius: number
  /** Blur for heatmap points */
  blur: number
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
}

export type GeoPointMapViewLayer = GeoViewLayerProperties & {
  /** Marker color field */
  colorField: string
  colorDimension: Axis
  /** Colors define color encoding of data into a visualization */
  colors: DashboardColor[]
  /** Cluster close markers together */
  isClustered?: boolean
  /** An array for which columns to display in tooltip */
  tooltipColumns?: string[]
}

export interface GeoTrackMapViewLayer {
  /** Width of the track */
  trackWidth?: number
  /** Speed of the track animation */
  speed?: number
  /** Assign different colors to different tracks */
  randomColors?: boolean
  /** Colors define color encoding of data into a visualization */
  colors?: DashboardColor[]
}

export interface CreateCell {
  name?: string
  x?: number
  y?: number
  w?: number
  h?: number
  /** Makes a copy of the provided view. */
  usingView?: string
}

export interface CellUpdate {
  x?: number
  y?: number
  w?: number
  h?: number
}

export interface View {
  readonly links?: {
    self?: string
  }
  readonly id?: string
  name: string
  properties: ViewProperties
}

/**
 * Flux query to be analyzed.
 */
export interface LanguageRequest {
  /** Flux query script to be analyzed */
  query: string
}

/**
 * Contains the AST for the supplied Flux query
 */
export interface ASTResponse {
  ast?: Package
}

/**
 * Represents a complete package source tree.
 */
export interface Package {
  type?: NodeType
  /** Package import path */
  path?: string
  /** Package name */
  package?: string
  /** Package files */
  files?: File[]
}

/**
 * Type of AST node
 */
export type NodeType = string

/**
 * Represents a source from a single file
 */
export interface File {
  type?: NodeType
  /** The name of the file. */
  name?: string
  package?: PackageClause
  /** A list of package imports */
  imports?: ImportDeclaration[]
  /** List of Flux statements */
  body?: Statement[]
}

/**
 * Defines a package identifier
 */
export interface PackageClause {
  type?: NodeType
  name?: Identifier
}

/**
 * A valid Flux identifier
 */
export interface Identifier {
  type?: NodeType
  name?: string
}

/**
 * Declares a package import
 */
export interface ImportDeclaration {
  type?: NodeType
  as?: Identifier
  path?: StringLiteral
}

/**
 * Expressions begin and end with double quote marks
 */
export interface StringLiteral {
  type?: NodeType
  value?: string
}

export type Statement =
  | BadStatement
  | VariableAssignment
  | MemberAssignment
  | ExpressionStatement
  | ReturnStatement
  | OptionStatement
  | BuiltinStatement
  | TestStatement

/**
 * A placeholder for statements for which no correct statement nodes can be created
 */
export interface BadStatement {
  type?: NodeType
  /** Raw source text */
  text?: string
}

/**
 * Represents the declaration of a variable
 */
export interface VariableAssignment {
  type?: NodeType
  id?: Identifier
  init?: Expression
}

export type Expression =
  | ArrayExpression
  | DictExpression
  | FunctionExpression
  | BinaryExpression
  | CallExpression
  | ConditionalExpression
  | LogicalExpression
  | MemberExpression
  | IndexExpression
  | ObjectExpression
  | ParenExpression
  | PipeExpression
  | UnaryExpression
  | BooleanLiteral
  | DateTimeLiteral
  | DurationLiteral
  | FloatLiteral
  | IntegerLiteral
  | PipeLiteral
  | RegexpLiteral
  | StringLiteral
  | UnsignedIntegerLiteral
  | Identifier

/**
 * Used to create and directly specify the elements of an array object
 */
export interface ArrayExpression {
  type?: NodeType
  /** Elements of the array */
  elements?: Expression[]
}

/**
 * Used to create and directly specify the elements of a dictionary
 */
export interface DictExpression {
  type?: NodeType
  /** Elements of the dictionary */
  elements?: DictItem[]
}

/**
 * A key/value pair in a dictionary
 */
export interface DictItem {
  type?: NodeType
  key?: Expression
  val?: Expression
}

/**
 * Function expression
 */
export interface FunctionExpression {
  type?: NodeType
  /** Function parameters */
  params?: Property[]
  body?: Node
}

/**
 * The value associated with a key
 */
export interface Property {
  type?: NodeType
  key?: PropertyKey
  value?: Expression
}

export type PropertyKey = Identifier | StringLiteral

export type Node = Expression | Block

/**
 * A set of statements
 */
export interface Block {
  type?: NodeType
  /** Block body */
  body?: Statement[]
}

/**
 * uses binary operators to act on two operands in an expression
 */
export interface BinaryExpression {
  type?: NodeType
  operator?: string
  left?: Expression
  right?: Expression
}

/**
 * Represents a function call
 */
export interface CallExpression {
  type?: NodeType
  callee?: Expression
  /** Function arguments */
  arguments?: Expression[]
}

/**
 * Selects one of two expressions, `Alternate` or `Consequent`, depending on a third boolean expression, `Test`
 */
export interface ConditionalExpression {
  type?: NodeType
  test?: Expression
  alternate?: Expression
  consequent?: Expression
}

/**
 * Represents the rule conditions that collectively evaluate to either true or false
 */
export interface LogicalExpression {
  type?: NodeType
  operator?: string
  left?: Expression
  right?: Expression
}

/**
 * Represents accessing a property of an object
 */
export interface MemberExpression {
  type?: NodeType
  object?: Expression
  property?: PropertyKey
}

/**
 * Represents indexing into an array
 */
export interface IndexExpression {
  type?: NodeType
  array?: Expression
  index?: Expression
}

/**
 * Allows the declaration of an anonymous object within a declaration
 */
export interface ObjectExpression {
  type?: NodeType
  /** Object properties */
  properties?: Property[]
}

/**
 * Represents an expression wrapped in parenthesis
 */
export interface ParenExpression {
  type?: NodeType
  expression?: Expression
}

/**
 * Call expression with pipe argument
 */
export interface PipeExpression {
  type?: NodeType
  argument?: Expression
  call?: CallExpression
}

/**
 * Uses operators to act on a single operand in an expression
 */
export interface UnaryExpression {
  type?: NodeType
  operator?: string
  argument?: Expression
}

/**
 * Represents boolean values
 */
export interface BooleanLiteral {
  type?: NodeType
  value?: boolean
}

/**
 * Represents an instant in time with nanosecond precision using the syntax of golang's RFC3339 Nanosecond variant
 */
export interface DateTimeLiteral {
  type?: NodeType
  value?: string
}

/**
 * Represents the elapsed time between two instants as an int64 nanosecond count with syntax of golang's time.Duration
 */
export interface DurationLiteral {
  type?: NodeType
  /** Duration values */
  values?: Duration[]
}

/**
 * A pair consisting of length of time and the unit of time measured. It is the atomic unit from which all duration literals are composed.
 */
export interface Duration {
  type?: NodeType
  magnitude?: number
  unit?: string
}

/**
 * Represents floating point numbers according to the double representations defined by the IEEE-754-1985
 */
export interface FloatLiteral {
  type?: NodeType
  value?: number
}

/**
 * Represents integer numbers
 */
export interface IntegerLiteral {
  type?: NodeType
  value?: string
}

/**
 * Represents a specialized literal value, indicating the left hand value of a pipe expression
 */
export interface PipeLiteral {
  type?: NodeType
}

/**
 * Expressions begin and end with `/` and are regular expressions with syntax accepted by RE2
 */
export interface RegexpLiteral {
  type?: NodeType
  value?: string
}

/**
 * Represents integer numbers
 */
export interface UnsignedIntegerLiteral {
  type?: NodeType
  value?: string
}

/**
 * Object property assignment
 */
export interface MemberAssignment {
  type?: NodeType
  member?: MemberExpression
  init?: Expression
}

/**
 * May consist of an expression that does not return a value and is executed solely for its side-effects
 */
export interface ExpressionStatement {
  type?: NodeType
  expression?: Expression
}

/**
 * Defines an expression to return
 */
export interface ReturnStatement {
  type?: NodeType
  argument?: Expression
}

/**
 * A single variable declaration
 */
export interface OptionStatement {
  type?: NodeType
  assignment?: VariableAssignment | MemberAssignment
}

/**
 * Declares a builtin identifier and its type
 */
export interface BuiltinStatement {
  type?: NodeType
  id?: Identifier
}

/**
 * Declares a Flux test case
 */
export interface TestStatement {
  type?: NodeType
  assignment?: VariableAssignment
}

export interface FluxSuggestions {
  funcs?: FluxSuggestion[]
}

export interface FluxSuggestion {
  name?: string
  params?: any
}

/**
 * Query influx using the Flux language
 */
export interface Query {
  extern?: File
  /** Query script to execute. */
  query: string
  /** The type of query. Must be "flux". */
  type?: 'flux'
  /** Enumeration of key/value pairs that respresent parameters to be injected into query (can only specify either this field or extern and not both)
   */
  params?: any
  dialect?: Dialect
  /** Specifies the time that should be reported as "now" in the query. Default is the server's now time. */
  now?: string
}

/**
 * Dialect are options to change the default CSV output format; https://www.w3.org/TR/2015/REC-tabular-metadata-20151217/#dialect-descriptions
 */
export interface Dialect {
  /** If true, the results will contain a header row */
  header?: boolean
  /** Separator between cells; the default is , */
  delimiter?: string
  /** https://www.w3.org/TR/2015/REC-tabular-data-model-20151217/#columns */
  annotations?: Array<'group' | 'datatype' | 'default'>
  /** Character prefixed to comment strings */
  commentPrefix?: string
  /** Format of timestamps */
  dateTimeFormat?: 'RFC3339' | 'RFC3339Nano'
}

export interface AnalyzeQueryResponse {
  errors?: Array<{
    line?: number
    column?: number
    character?: number
    message?: string
  }>
}

export interface Buckets {
  readonly links?: Links
  buckets?: Bucket[]
}

export interface Bucket {
  readonly links?: {
    /** URL to retrieve labels for this bucket */
    labels?: Link
    /** URL to retrieve members that can read this bucket */
    members?: Link
    /** URL to retrieve parent organization for this bucket */
    org?: Link
    /** URL to retrieve owners that can read and write to this bucket. */
    owners?: Link
    /** URL for this bucket */
    self?: Link
    /** URL to write line protocol for this bucket */
    write?: Link
  }
  readonly id?: string
  readonly type?: 'user' | 'system'
  name: string
  description?: string
  orgID?: string
  rp?: string
  schemaType?: SchemaType
  readonly createdAt?: string
  readonly updatedAt?: string
  retentionRules: RetentionRules
  labels?: Labels
}

export type SchemaType = 'implicit' | 'explicit'

/**
 * Rules to expire or retain data.  No rules means data never expires.
 */
export type RetentionRules = RetentionRule[]

export interface RetentionRule {
  type: 'expire'
  /** Duration in seconds for how long data will be kept in the database. 0 means infinite. */
  everySeconds: number
  /** Shard duration measured in seconds. */
  shardGroupDurationSeconds?: number
}

export interface PostBucketRequest {
  orgID: string
  name: string
  description?: string
  rp?: string
  retentionRules: RetentionRules
  schemaType?: SchemaType
}

/**
 * Updates to an existing bucket resource.
 */
export interface PatchBucketRequest {
  name?: string
  description?: string
  retentionRules?: PatchRetentionRules
}

/**
 * Updates to rules to expire or retain data. No rules means no updates.
 */
export type PatchRetentionRules = PatchRetentionRule[]

/**
 * Updates to a rule to expire or retain data.
 */
export interface PatchRetentionRule {
  type: 'expire'
  /** Duration in seconds for how long data will be kept in the database. 0 means infinite. */
  everySeconds?: number
  /** Shard duration measured in seconds. */
  shardGroupDurationSeconds?: number
}

export interface Organizations {
  links?: Links
  orgs?: Organization[]
}

export interface Organization {
  readonly links?: {
    self?: Link
    members?: Link
    owners?: Link
    labels?: Link
    secrets?: Link
    buckets?: Link
    tasks?: Link
    dashboards?: Link
  }
  readonly id?: string
  name: string
  description?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  /** If inactive the organization is inactive. */
  status?: 'active' | 'inactive'
}

export interface PostOrganizationRequest {
  name: string
  description?: string
}

export interface PatchOrganizationRequest {
  /** New name to set on the organization */
  name?: string
  /** New description to set on the organization */
  description?: string
}

export type SecretKeysResponse = SecretKeys & {
  readonly links?: {
    self?: string
    org?: string
  }
}

export interface SecretKeys {
  secrets?: string[]
}

export type Secrets = any

export interface Stack {
  id?: string
  orgID?: string
  readonly createdAt?: string
  events?: Array<{
    eventType?: string
    name?: string
    description?: string
    sources?: string[]
    resources?: Array<{
      apiVersion?: string
      resourceID?: string
      kind?: TemplateKind
      templateMetaName?: string
      associations?: Array<{
        kind?: TemplateKind
        metaName?: string
      }>
      links?: {
        self?: string
      }
    }>
    urls?: string[]
    readonly updatedAt?: string
  }>
}

export type TemplateKind =
  | 'Bucket'
  | 'Check'
  | 'CheckDeadman'
  | 'CheckThreshold'
  | 'Dashboard'
  | 'Label'
  | 'NotificationEndpoint'
  | 'NotificationEndpointHTTP'
  | 'NotificationEndpointPagerDuty'
  | 'NotificationEndpointSlack'
  | 'NotificationRule'
  | 'Task'
  | 'Telegraf'
  | 'Variable'

export interface TemplateApply {
  dryRun?: boolean
  orgID?: string
  stackID?: string
  template?: {
    contentType?: string
    sources?: string[]
    contents?: Template
  }
  templates?: Array<{
    contentType?: string
    sources?: string[]
    contents?: Template
  }>
  envRefs?: any
  secrets?: any
  remotes?: Array<{
    url: string
    contentType?: string
  }>
  actions?: Array<
    | {
        action?: 'skipKind'
        properties?: {
          kind: TemplateKind
        }
      }
    | {
        action?: 'skipResource'
        properties?: {
          kind: TemplateKind
          resourceTemplateName: string
        }
      }
  >
}

export type Template = Array<{
  apiVersion?: string
  kind?: TemplateKind
  meta?: {
    name?: string
  }
  spec?: any
}>

export interface TemplateSummary {
  sources?: string[]
  stackID?: string
  summary?: {
    buckets?: Array<{
      id?: string
      orgID?: string
      kind?: TemplateKind
      templateMetaName?: string
      name?: string
      description?: string
      retentionPeriod?: number
      labelAssociations?: TemplateSummaryLabel[]
      envReferences?: TemplateEnvReferences
    }>
    checks?: Array<
      CheckDiscriminator & {
        kind?: TemplateKind
        templateMetaName?: string
        labelAssociations?: TemplateSummaryLabel[]
        envReferences?: TemplateEnvReferences
      }
    >
    dashboards?: Array<{
      id?: string
      orgID?: string
      kind?: TemplateKind
      templateMetaName?: string
      name?: string
      description?: string
      labelAssociations?: TemplateSummaryLabel[]
      charts?: TemplateChart[]
      envReferences?: TemplateEnvReferences
    }>
    labels?: TemplateSummaryLabel[]
    labelMappings?: Array<{
      status?: string
      resourceTemplateMetaName?: string
      resourceName?: string
      resourceID?: string
      resourceType?: string
      labelTemplateMetaName?: string
      labelName?: string
      labelID?: string
    }>
    missingEnvRefs?: string[]
    missingSecrets?: string[]
    notificationEndpoints?: Array<
      NotificationEndpointDiscriminator & {
        kind?: TemplateKind
        templateMetaName?: string
        labelAssociations?: TemplateSummaryLabel[]
        envReferences?: TemplateEnvReferences
      }
    >
    notificationRules?: Array<{
      kind?: TemplateKind
      templateMetaName?: string
      name?: string
      description?: string
      endpointTemplateMetaName?: string
      endpointID?: string
      endpointType?: string
      every?: string
      offset?: string
      messageTemplate?: string
      status?: string
      statusRules?: Array<{
        currentLevel?: string
        previousLevel?: string
      }>
      tagRules?: Array<{
        key?: string
        value?: string
        operator?: string
      }>
      labelAssociations?: TemplateSummaryLabel[]
      envReferences?: TemplateEnvReferences
    }>
    tasks?: Array<{
      kind?: TemplateKind
      templateMetaName?: string
      id?: string
      name?: string
      cron?: string
      description?: string
      every?: string
      offset?: string
      query?: string
      status?: string
      envReferences?: TemplateEnvReferences
    }>
    telegrafConfigs?: Array<
      TelegrafRequest & {
        kind?: TemplateKind
        templateMetaName?: string
        labelAssociations?: TemplateSummaryLabel[]
        envReferences?: TemplateEnvReferences
      }
    >
    variables?: Array<{
      kind?: TemplateKind
      templateMetaName?: string
      id?: string
      orgID?: string
      name?: string
      description?: string
      arguments?: VariableProperties
      labelAssociations?: TemplateSummaryLabel[]
      envReferences?: TemplateEnvReferences
    }>
  }
  diff?: {
    buckets?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: {
        name?: string
        description?: string
        retentionRules?: RetentionRules
      }
      old?: {
        name?: string
        description?: string
        retentionRules?: RetentionRules
      }
    }>
    checks?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: CheckDiscriminator
      old?: CheckDiscriminator
    }>
    dashboards?: Array<{
      stateStatus?: string
      id?: string
      kind?: TemplateKind
      templateMetaName?: string
      new?: {
        name?: string
        description?: string
        charts?: TemplateChart[]
      }
      old?: {
        name?: string
        description?: string
        charts?: TemplateChart[]
      }
    }>
    labels?: Array<{
      stateStatus?: string
      kind?: TemplateKind
      id?: string
      templateMetaName?: string
      new?: {
        name?: string
        color?: string
        description?: string
      }
      old?: {
        name?: string
        color?: string
        description?: string
      }
    }>
    labelMappings?: Array<{
      status?: string
      resourceType?: string
      resourceID?: string
      resourceTemplateMetaName?: string
      resourceName?: string
      labelID?: string
      labelTemplateMetaName?: string
      labelName?: string
    }>
    notificationEndpoints?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: NotificationEndpointDiscriminator
      old?: NotificationEndpointDiscriminator
    }>
    notificationRules?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: {
        name?: string
        description?: string
        endpointName?: string
        endpointID?: string
        endpointType?: string
        every?: string
        offset?: string
        messageTemplate?: string
        status?: string
        statusRules?: Array<{
          currentLevel?: string
          previousLevel?: string
        }>
        tagRules?: Array<{
          key?: string
          value?: string
          operator?: string
        }>
      }
      old?: {
        name?: string
        description?: string
        endpointName?: string
        endpointID?: string
        endpointType?: string
        every?: string
        offset?: string
        messageTemplate?: string
        status?: string
        statusRules?: Array<{
          currentLevel?: string
          previousLevel?: string
        }>
        tagRules?: Array<{
          key?: string
          value?: string
          operator?: string
        }>
      }
    }>
    tasks?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: {
        name?: string
        cron?: string
        description?: string
        every?: string
        offset?: string
        query?: string
        status?: string
      }
      old?: {
        name?: string
        cron?: string
        description?: string
        every?: string
        offset?: string
        query?: string
        status?: string
      }
    }>
    telegrafConfigs?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: TelegrafRequest
      old?: TelegrafRequest
    }>
    variables?: Array<{
      kind?: TemplateKind
      stateStatus?: string
      id?: string
      templateMetaName?: string
      new?: {
        name?: string
        description?: string
        args?: VariableProperties
      }
      old?: {
        name?: string
        description?: string
        args?: VariableProperties
      }
    }>
  }
  errors?: Array<{
    kind?: TemplateKind
    reason?: string
    fields?: string[]
    indexes?: number[]
  }>
}

export interface TemplateSummaryLabel {
  id?: string
  orgID?: string
  kind?: TemplateKind
  templateMetaName?: string
  name?: string
  properties?: {
    color?: string
    description?: string
  }
  envReferences?: TemplateEnvReferences
}

export type TemplateEnvReferences = Array<{
  /** Field the environment reference corresponds too */
  resourceField: string
  /** Key identified as environment reference and is the key identified in the template */
  envRefKey: string
  /** Value provided to fulfill reference */
  value?: string | number | number | boolean
  /** Default value that will be provided for the reference when no value is provided */
  defaultValue?: string | number | number | boolean
}>

export interface TemplateChart {
  xPos?: number
  yPos?: number
  height?: number
  width?: number
  properties?: ViewProperties
}

export type NotificationEndpointDiscriminator =
  | (SlackNotificationEndpoint & {type: string})
  | (PagerDutyNotificationEndpoint & {type: string})
  | (HTTPNotificationEndpoint & {type: string})
  | (TelegramNotificationEndpoint & {type: string})

export type SlackNotificationEndpoint = NotificationEndpointBase & {
  /** Specifies the URL of the Slack endpoint. Specify either `URL` or `Token`. */
  url?: string
  /** Specifies the API token string. Specify either `URL` or `Token`. */
  token?: string
}

export interface NotificationEndpointBase {
  id?: string
  orgID?: string
  userID?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  /** An optional description of the notification endpoint. */
  description?: string
  name: string
  /** The status of the endpoint. */
  status?: 'active' | 'inactive'
  labels?: Labels
  readonly links?: {
    /** URL for this endpoint. */
    self?: Link
    /** URL to retrieve labels for this endpoint. */
    labels?: Link
    /** URL to retrieve members for this endpoint. */
    members?: Link
    /** URL to retrieve owners for this endpoint. */
    owners?: Link
  }
  type: NotificationEndpointType
}

export type NotificationEndpointType =
  | 'slack'
  | 'pagerduty'
  | 'http'
  | 'telegram'

export type PagerDutyNotificationEndpoint = NotificationEndpointBase & {
  clientURL?: string
  routingKey: string
}

export type HTTPNotificationEndpoint = NotificationEndpointBase & {
  url: string
  username?: string
  password?: string
  token?: string
  method: 'POST' | 'GET' | 'PUT'
  authMethod: 'none' | 'basic' | 'bearer'
  contentTemplate?: string
  /** Customized headers. */
  headers?: any
}

export type TelegramNotificationEndpoint = NotificationEndpointBase & {
  /** Specifies the Telegram bot token. See https://core.telegram.org/bots#creating-a-new-bot . */
  token: string
  /** ID of the telegram channel, a chat_id in https://core.telegram.org/bots/api#sendmessage . */
  channel: string
}

export type VariableProperties =
  | QueryVariableProperties
  | ConstantVariableProperties
  | MapVariableProperties

export interface QueryVariableProperties {
  type?: 'query'
  values?: {
    query?: string
    language?: string
  }
}

export interface ConstantVariableProperties {
  type?: 'constant'
  values?: string[]
}

export interface MapVariableProperties {
  type?: 'map'
  values?: any
}

export interface TemplateExportByID {
  stackID?: string
  orgIDs?: Array<{
    orgID?: string
    resourceFilters?: {
      byLabel?: string[]
      byResourceKind?: TemplateKind[]
    }
  }>
  resources?: Array<{
    id: string
    kind: TemplateKind
    /** if defined with id, name is used for resource exported by id. if defined independently, resources strictly matching name are exported */
    name?: string
  }>
}

export interface TemplateExportByName {
  stackID?: string
  orgIDs?: Array<{
    orgID?: string
    resourceFilters?: {
      byLabel?: string[]
      byResourceKind?: TemplateKind[]
    }
  }>
  resources?: Array<{
    kind: TemplateKind
    name: string
  }>
}

export interface Task {
  readonly id: string
  /** The type of task, this can be used for filtering tasks on list actions. */
  type?: string
  /** The ID of the organization that owns this Task. */
  orgID: string
  /** The name of the organization that owns this Task. */
  org?: string
  /** The name of the task. */
  name: string
  /** The ID of the user who owns this Task. */
  ownerID?: string
  /** An optional description of the task. */
  description?: string
  status?: TaskStatusType
  labels?: Labels
  /** The ID of the authorization used when this task communicates with the query engine. */
  authorizationID?: string
  /** The Flux script to run for this task. */
  flux: string
  /** A simple task repetition schedule; parsed from Flux. */
  every?: string
  /** A task repetition schedule in the form '* * * * * *'; parsed from Flux. */
  cron?: string
  /** Duration to delay after the schedule, before executing the task; parsed from flux, if set to zero it will remove this option and use 0 as the default. */
  offset?: string
  /** Timestamp of latest scheduled, completed run, RFC3339. */
  readonly latestCompleted?: string
  readonly lastRunStatus?: 'failed' | 'success' | 'canceled'
  readonly lastRunError?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  readonly links?: {
    self?: Link
    owners?: Link
    members?: Link
    runs?: Link
    logs?: Link
    labels?: Link
  }
}

export interface TaskUpdateRequest {
  status?: TaskStatusType
  /** The Flux script to run for this task. */
  flux?: string
  /** Override the 'name' option in the flux script. */
  name?: string
  /** Override the 'every' option in the flux script. */
  every?: string
  /** Override the 'cron' option in the flux script. */
  cron?: string
  /** Override the 'offset' option in the flux script. */
  offset?: string
  /** An optional description of the task. */
  description?: string
}

export interface Runs {
  links?: Links
  runs?: Run[]
}

export interface Run {
  readonly id?: string
  readonly taskID?: string
  readonly status?: 'scheduled' | 'started' | 'failed' | 'success' | 'canceled'
  /** Time used for run's "now" option, RFC3339. */
  scheduledFor?: string
  /** An array of logs associated with the run. */
  readonly log?: LogEvent[]
  /** Time run started executing, RFC3339Nano. */
  readonly startedAt?: string
  /** Time run finished executing, RFC3339Nano. */
  readonly finishedAt?: string
  /** Time run was manually requested, RFC3339Nano. */
  readonly requestedAt?: string
  readonly links?: {
    self?: string
    task?: string
    retry?: string
  }
}

export interface LogEvent {
  /** Time event occurred, RFC3339Nano. */
  readonly time?: string
  /** A description of the event that occurred. */
  readonly message?: string
  /** the ID of the task that logged */
  readonly runID?: string
}

export interface RunManually {
  /** Time used for run's "now" option, RFC3339.  Default is the server's now time. */
  scheduledFor?: string
}

export interface Logs {
  readonly events?: LogEvent[]
}

export type Flags = any

export interface PasswordResetBody {
  password: string
}

export interface Checks {
  checks?: Check[]
  links?: Links
}

export type PostCheck = CheckDiscriminator

export interface CheckPatch {
  name?: string
  description?: string
  status?: 'active' | 'inactive'
}

export interface NotificationRules {
  notificationRules?: NotificationRule[]
  links?: Links
}

export type NotificationRule = NotificationRuleDiscriminator

export type NotificationRuleDiscriminator =
  | (SlackNotificationRule & {type: string})
  | (SMTPNotificationRule & {type: string})
  | (PagerDutyNotificationRule & {type: string})
  | (HTTPNotificationRule & {type: string})
  | (TelegramNotificationRule & {type: string})

export type SlackNotificationRule = NotificationRuleBase &
  SlackNotificationRuleBase

export interface NotificationRuleBase {
  /** Timestamp of latest scheduled, completed run, RFC3339. */
  readonly latestCompleted?: string
  readonly lastRunStatus?: 'failed' | 'success' | 'canceled'
  readonly lastRunError?: string
  readonly id?: string
  endpointID: string
  /** The ID of the organization that owns this notification rule. */
  orgID: string
  /** The ID of the task associated with this notification rule. */
  taskID?: string
  /** The ID of creator used to create this notification rule. */
  readonly ownerID?: string
  readonly createdAt?: string
  readonly updatedAt?: string
  status: TaskStatusType
  /** Human-readable name describing the notification rule. */
  name: string
  sleepUntil?: string
  /** The notification repetition interval. */
  every?: string
  /** Duration to delay after the schedule, before executing check. */
  offset?: string
  runbookLink?: string
  /** Don't notify me more than <limit> times every <limitEvery> seconds. If set, limit cannot be empty. */
  limitEvery?: number
  /** Don't notify me more than <limit> times every <limitEvery> seconds. If set, limitEvery cannot be empty. */
  limit?: number
  /** List of tag rules the notification rule attempts to match. */
  tagRules?: TagRule[]
  /** An optional description of the notification rule. */
  description?: string
  /** List of status rules the notification rule attempts to match. */
  statusRules: StatusRule[]
  labels?: Labels
  readonly links?: {
    /** URL for this endpoint. */
    self?: Link
    /** URL to retrieve labels for this notification rule. */
    labels?: Link
    /** URL to retrieve members for this notification rule. */
    members?: Link
    /** URL to retrieve owners for this notification rule. */
    owners?: Link
    /** URL to retrieve flux script for this notification rule. */
    query?: Link
  }
}

export interface TagRule {
  key?: string
  value?: string
  operator?: 'equal' | 'notequal' | 'equalregex' | 'notequalregex'
}

export interface StatusRule {
  currentLevel?: RuleStatusLevel
  previousLevel?: RuleStatusLevel
  count?: number
  period?: string
}

/**
 * The state to record if check matches a criteria.
 */
export type RuleStatusLevel =
  | 'UNKNOWN'
  | 'OK'
  | 'INFO'
  | 'CRIT'
  | 'WARN'
  | 'ANY'

export interface SlackNotificationRuleBase {
  type: 'slack'
  channel?: string
  messageTemplate: string
}

export type SMTPNotificationRule = NotificationRuleBase &
  SMTPNotificationRuleBase

export interface SMTPNotificationRuleBase {
  type: 'smtp'
  subjectTemplate: string
  bodyTemplate?: string
  to: string
}

export type PagerDutyNotificationRule = NotificationRuleBase &
  PagerDutyNotificationRuleBase

export interface PagerDutyNotificationRuleBase {
  type: 'pagerduty'
  messageTemplate: string
}

export type HTTPNotificationRule = NotificationRuleBase &
  HTTPNotificationRuleBase

export interface HTTPNotificationRuleBase {
  type: 'http'
  url?: string
}

export type TelegramNotificationRule = NotificationRuleBase &
  TelegramNotificationRuleBase

export interface TelegramNotificationRuleBase {
  /** The discriminator between other types of notification rules is "telegram". */
  type: 'telegram'
  /** The message template as a flux interpolated string. */
  messageTemplate: string
  /** Parse mode of the message text per https://core.telegram.org/bots/api#formatting-options . Defaults to "MarkdownV2" . */
  parseMode?: 'MarkdownV2' | 'HTML' | 'Markdown'
  /** Disables preview of web links in the sent messages when "true". Defaults to "false" . */
  disableWebPagePreview?: boolean
}

export type PostNotificationRule = NotificationRuleDiscriminator

/**
 * Rendered flux that backs the check or notification.
 */
export interface FluxResponse {
  flux?: string
}

export interface NotificationRuleUpdate {
  name?: string
  description?: string
  status?: 'active' | 'inactive'
}

export interface NotificationEndpoints {
  notificationEndpoints?: NotificationEndpoint[]
  links?: Links
}

export type NotificationEndpoint = NotificationEndpointDiscriminator

export type PostNotificationEndpoint = NotificationEndpointDiscriminator

export interface NotificationEndpointUpdate {
  name?: string
  description?: string
  status?: 'active' | 'inactive'
}

export interface HealthCheck {
  name: string
  message?: string
  checks?: HealthCheck[]
  status: 'pass' | 'fail'
  version?: string
  commit?: string
}

export interface Ready {
  status?: 'ready'
  started?: string
  up?: string
}

export interface Users {
  links?: {
    self?: string
  }
  users?: UserResponse[]
}

export interface User {
  readonly id?: string
  oauthID?: string
  name: string
  /** If inactive the user is inactive. */
  status?: 'active' | 'inactive'
}

export interface IsOnboarding {
  /** True means that the influxdb instance has NOT had initial setup; false means that the database has been setup. */
  allowed?: boolean
}

export interface OnboardingRequest {
  username: string
  password?: string
  org: string
  bucket: string
  retentionPeriodSeconds?: number
  /** Retention period *in nanoseconds* for the new bucket. This key's name has been misleading since OSS 2.0 GA, please transition to use `retentionPeriodSeconds`
   */
  retentionPeriodHrs?: number
  /** Authentication token to set on the initial user. If not specified, the server will generate a token.
   */
  token?: string
}

export interface OnboardingResponse {
  user?: UserResponse
  org?: Organization
  bucket?: Bucket
  auth?: Authorization
}

export type Authorization = AuthorizationUpdateRequest & {
  readonly createdAt?: string
  readonly updatedAt?: string
  /** ID of org that authorization is scoped to. */
  orgID?: string
  /** List of permissions for an auth.  An auth must have at least one Permission. */
  permissions?: Permission[]
  readonly id?: string
  /** Passed via the Authorization Header and Token Authentication type. */
  readonly token?: string
  /** ID of user that created and owns the token. */
  readonly userID?: string
  /** Name of user that created and owns the token. */
  readonly user?: string
  /** Name of the org token is scoped to. */
  readonly org?: string
  readonly links?: {
    readonly self?: Link
    readonly user?: Link
  }
}

export interface AuthorizationUpdateRequest {
  /** If inactive the token is inactive and requests using the token will be rejected. */
  status?: 'active' | 'inactive'
  /** A description of the token. */
  description?: string
}

export interface Permission {
  action: 'read' | 'write'
  resource: Resource
}

export interface Resource {
  type:
    | 'authorizations'
    | 'buckets'
    | 'dashboards'
    | 'orgs'
    | 'sources'
    | 'tasks'
    | 'telegrafs'
    | 'users'
    | 'variables'
    | 'scrapers'
    | 'secrets'
    | 'labels'
    | 'views'
    | 'documents'
    | 'notificationRules'
    | 'notificationEndpoints'
    | 'checks'
    | 'dbrp'
    | 'notebooks'
    | 'annotations'
    | 'remotes'
    | 'replications'
    | 'flows'
    | 'functions'
  /** If ID is set that is a permission for a specific resource. if it is not set it is a permission for all resources of that resource type. */
  id?: string
  /** Optional name of the resource if the resource has a name field. */
  name?: string
  /** If orgID is set that is a permission for all resources owned my that org. if it is not set it is a permission for all resources of that resource type. */
  orgID?: string
  /** Optional name of the organization of the organization with orgID. */
  org?: string
}

export interface Authorizations {
  readonly links?: Links
  authorizations?: Authorization[]
}

export type AuthorizationPostRequest = AuthorizationUpdateRequest & {
  /** ID of org that authorization is scoped to. */
  orgID?: string
  /** ID of user that authorization is scoped to. */
  userID?: string
  /** List of permissions for an auth.  An auth must have at least one Permission. */
  permissions?: Permission[]
}

export type LegacyAuthorizationPostRequest = AuthorizationUpdateRequest & {
  /** ID of org that authorization is scoped to. */
  orgID?: string
  /** ID of user that authorization is scoped to. */
  userID?: string
  /** Token (name) of the authorization */
  token?: string
  /** List of permissions for an auth.  An auth must have at least one Permission. */
  permissions?: Permission[]
}

export interface Variables {
  variables?: Variable[]
}

export interface Variable {
  readonly links?: {
    self?: string
    org?: string
    labels?: string
  }
  readonly id?: string
  orgID: string
  name: string
  description?: string
  selected?: string[]
  labels?: Labels
  arguments: VariableProperties
  createdAt?: string
  updatedAt?: string
}

export interface Sources {
  links?: {
    self?: string
  }
  sources?: Source[]
}

export interface Source {
  links?: {
    self?: string
    query?: string
    health?: string
    buckets?: string
  }
  id?: string
  orgID?: string
  default?: boolean
  name?: string
  type?: 'v1' | 'v2' | 'self'
  url?: string
  insecureSkipVerify?: boolean
  telegraf?: string
  token?: string
  username?: string
  password?: string
  sharedSecret?: string
  metaUrl?: string
  defaultRP?: string
  readonly languages?: Array<'flux' | 'influxql'>
}

export interface ScraperTargetResponses {
  configurations?: ScraperTargetResponse[]
}

export type ScraperTargetResponse = ScraperTargetRequest & {
  readonly id?: string
  /** The name of the organization. */
  org?: string
  /** The bucket name. */
  bucket?: string
  readonly links?: {
    self?: Link
    members?: Link
    owners?: Link
    bucket?: Link
    organization?: Link
  }
}

export interface ScraperTargetRequest {
  /** The name of the scraper target. */
  name?: string
  /** The type of the metrics to be parsed. */
  type?: 'prometheus'
  /** The URL of the metrics endpoint. */
  url?: string
  /** The organization ID. */
  orgID?: string
  /** The ID of the bucket to write to. */
  bucketID?: string
  /** Skip TLS verification on endpoint. */
  allowInsecure?: boolean
}

export interface MetadataBackup {
  kv: string
  sql: string
  buckets: BucketMetadataManifests
}

export type BucketMetadataManifests = BucketMetadataManifest[]

export interface BucketMetadataManifest {
  organizationID: string
  organizationName: string
  bucketID: string
  bucketName: string
  description?: string
  defaultRetentionPolicy: string
  retentionPolicies: RetentionPolicyManifests
}

export type RetentionPolicyManifests = RetentionPolicyManifest[]

export interface RetentionPolicyManifest {
  name: string
  replicaN: number
  duration: number
  shardGroupDuration: number
  shardGroups: ShardGroupManifests
  subscriptions: SubscriptionManifests
}

export type ShardGroupManifests = ShardGroupManifest[]

export interface ShardGroupManifest {
  id: number
  startTime: string
  endTime: string
  deletedAt?: string
  truncatedAt?: string
  shards: ShardManifests
}

export type ShardManifests = ShardManifest[]

export interface ShardManifest {
  id: number
  shardOwners: ShardOwners
}

export type ShardOwners = ShardOwner[]

export interface ShardOwner {
  /** ID of the node that owns a shard. */
  nodeID: number
}

export type SubscriptionManifests = SubscriptionManifest[]

export interface SubscriptionManifest {
  name: string
  mode: string
  destinations: string[]
}

export interface RestoredBucketMappings {
  /** New ID of the restored bucket */
  id: string
  name: string
  shardMappings: BucketShardMappings
}

export type BucketShardMappings = BucketShardMapping[]

export interface BucketShardMapping {
  oldId: number
  newId: number
}

export interface Config {
  config?: any
}

export interface RemoteConnections {
  remotes?: RemoteConnection[]
}

export interface RemoteConnection {
  id: string
  name: string
  orgID: string
  description?: string
  remoteURL: string
  remoteOrgID: string
  allowInsecureTLS: boolean
}

export interface RemoteConnectionCreationRequest {
  name: string
  description?: string
  orgID: string
  remoteURL: string
  remoteAPIToken: string
  remoteOrgID: string
  allowInsecureTLS: boolean
}

export interface RemoteConnectionUpdateRequest {
  name?: string
  description?: string
  remoteURL?: string
  remoteAPIToken?: string
  remoteOrgID?: string
  allowInsecureTLS?: boolean
}

export interface Replications {
  replications?: Replication[]
}

export interface Replication {
  id: string
  name: string
  description?: string
  orgID: string
  remoteID: string
  localBucketID: string
  remoteBucketID: string
  maxQueueSizeBytes: number
  currentQueueSizeBytes: number
  latestResponseCode?: number
  latestErrorMessage?: string
  dropNonRetryableData?: boolean
}

export interface ReplicationCreationRequest {
  name: string
  description?: string
  orgID: string
  remoteID: string
  localBucketID: string
  remoteBucketID: string
  maxQueueSizeBytes: number
  dropNonRetryableData?: boolean
}

export interface ReplicationUpdateRequest {
  name?: string
  description?: string
  remoteID?: string
  remoteBucketID?: string
  maxQueueSizeBytes?: number
  dropNonRetryableData?: boolean
}

export interface Dashboards {
  links?: Links
  dashboards?: Dashboard[]
}

export interface Tasks {
  readonly links?: Links
  tasks?: Task[]
}

export interface TaskCreateRequest {
  /** The ID of the organization that owns this Task. */
  orgID?: string
  /** The name of the organization that owns this Task. */
  org?: string
  status?: TaskStatusType
  /** The Flux script to run for this task. */
  flux: string
  /** An optional description of the task. */
  description?: string
}

export interface Scripts {
  scripts?: Script[]
}

export interface Script {
  readonly id?: string
  name: string
  description?: string
  orgID: string
  /** script to be executed */
  script: string
  language?: ScriptLanguage
  /** invocation endpoint address */
  url?: string
  readonly createdAt?: string
  readonly updatedAt?: string
}

export type ScriptLanguage = 'flux'

export interface ScriptCreateRequest {
  /** The name of the script. The name must be unique within the organization. */
  name: string
  description: string
  /** The script to execute. */
  script: string
  language: ScriptLanguage
}

export interface ScriptUpdateRequest {
  name?: string
  description?: string
  /** script is script to be executed */
  script?: string
}

export interface ScriptInvocationParams {
  params?: any
}

/**
 * The data sent in the response body when a script is invoked by an HTTP request. User defined and dynamic.
 */
export type ScriptHTTPResponseData = string
