// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Influx API Service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "https://raw.githubusercontent.com/api/v2".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *  
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * contains the AST for the supplied Flux query
 * @export
 * @interface ASTResponse
 */
export interface ASTResponse {
    /**
     * 
     * @type {Package}
     * @memberof ASTResponse
     */
    ast?: Package;
}

/**
 * 
 * @export
 * @interface AddResourceMemberRequestBody
 */
export interface AddResourceMemberRequestBody {
    /**
     * 
     * @type {string}
     * @memberof AddResourceMemberRequestBody
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AddResourceMemberRequestBody
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface AnalyzeQueryResponse
 */
export interface AnalyzeQueryResponse {
    /**
     * 
     * @type {Array<AnalyzeQueryResponseErrors>}
     * @memberof AnalyzeQueryResponse
     */
    errors?: Array<AnalyzeQueryResponseErrors>;
}

/**
 * 
 * @export
 * @interface AnalyzeQueryResponseErrors
 */
export interface AnalyzeQueryResponseErrors {
    /**
     * 
     * @type {number}
     * @memberof AnalyzeQueryResponseErrors
     */
    line?: number;
    /**
     * 
     * @type {number}
     * @memberof AnalyzeQueryResponseErrors
     */
    column?: number;
    /**
     * 
     * @type {number}
     * @memberof AnalyzeQueryResponseErrors
     */
    character?: number;
    /**
     * 
     * @type {string}
     * @memberof AnalyzeQueryResponseErrors
     */
    message?: string;
}

/**
 * used to create and directly specify the elements of an array object
 * @export
 * @interface ArrayExpression
 */
export interface ArrayExpression {
    /**
     * type of AST node
     * @type {string}
     * @memberof ArrayExpression
     */
    type?: string;
    /**
     * elements of the array
     * @type {Array<Expression>}
     * @memberof ArrayExpression
     */
    elements?: Array<Expression>;
}

/**
 * 
 * @export
 * @interface Authorization
 */
export interface Authorization extends AuthorizationUpdateRequest {
    /**
     * ID of org that authorization is scoped to.
     * @type {string}
     * @memberof Authorization
     */
    orgID?: string;
    /**
     * List of permissions for an auth.  An auth must have at least one Permission.
     * @type {Array<Permission>}
     * @memberof Authorization
     */
    permissions?: Array<Permission>;
    /**
     * 
     * @type {string}
     * @memberof Authorization
     */
    id?: string;
    /**
     * Passed via the Authorization Header and Token Authentication type.
     * @type {string}
     * @memberof Authorization
     */
    token?: string;
    /**
     * ID of user that created and owns the token.
     * @type {string}
     * @memberof Authorization
     */
    userID?: string;
    /**
     * Name of user that created and owns the token.
     * @type {string}
     * @memberof Authorization
     */
    user?: string;
    /**
     * Name of the org token is scoped to.
     * @type {string}
     * @memberof Authorization
     */
    org?: string;
    /**
     * 
     * @type {any}
     * @memberof Authorization
     */
    links?: any;
}

/**
 * @export
 * @namespace Authorization
 */
export namespace Authorization {
}

/**
 * 
 * @export
 * @interface AuthorizationUpdateRequest
 */
export interface AuthorizationUpdateRequest {
    /**
     * if inactive the token is inactive and requests using the token will be rejected.
     * @type {string}
     * @memberof AuthorizationUpdateRequest
     */
    status?: AuthorizationUpdateRequest.StatusEnum;
    /**
     * A description of the token.
     * @type {string}
     * @memberof AuthorizationUpdateRequest
     */
    description?: string;
}

/**
 * @export
 * @namespace AuthorizationUpdateRequest
 */
export namespace AuthorizationUpdateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface Authorizations
 */
export interface Authorizations {
    /**
     * 
     * @type {Links}
     * @memberof Authorizations
     */
    links?: Links;
    /**
     * 
     * @type {Array<Authorization>}
     * @memberof Authorizations
     */
    authorizations?: Array<Authorization>;
}

/**
 * The viewport for a View's visualizations
 * @export
 * @interface Axes
 */
export interface Axes {
    /**
     * 
     * @type {Axis}
     * @memberof Axes
     */
    x?: Axis;
    /**
     * 
     * @type {Axis}
     * @memberof Axes
     */
    y?: Axis;
    /**
     * 
     * @type {Axis}
     * @memberof Axes
     */
    y2?: Axis;
}

/**
 * A description of a particular axis for a visualization
 * @export
 * @interface Axis
 */
export interface Axis {
    /**
     * The extents of an axis in the form [lower, upper]. Clients determine whether bounds are to be inclusive or exclusive of their limits
     * @type {Array<number>}
     * @memberof Axis
     */
    bounds?: Array<number>;
    /**
     * label is a description of this Axis
     * @type {string}
     * @memberof Axis
     */
    label?: string;
    /**
     * Prefix represents a label prefix for formatting axis values.
     * @type {string}
     * @memberof Axis
     */
    prefix?: string;
    /**
     * Suffix represents a label suffix for formatting axis values.
     * @type {string}
     * @memberof Axis
     */
    suffix?: string;
    /**
     * Base represents the radix for formatting axis values.
     * @type {string}
     * @memberof Axis
     */
    base?: string;
    /**
     * Scale is the axis formatting scale. Supported: \"log\", \"linear\"
     * @type {string}
     * @memberof Axis
     */
    scale?: string;
}

/**
 * a placeholder for statements for which no correct statement nodes can be created
 * @export
 * @interface BadStatement
 */
export interface BadStatement {
    /**
     * type of AST node
     * @type {string}
     * @memberof BadStatement
     */
    type?: string;
    /**
     * raw source text
     * @type {string}
     * @memberof BadStatement
     */
    text?: string;
}

/**
 * uses binary operators to act on two operands in an expression
 * @export
 * @interface BinaryExpression
 */
export interface BinaryExpression {
    /**
     * type of AST node
     * @type {string}
     * @memberof BinaryExpression
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof BinaryExpression
     */
    operator?: string;
    /**
     * 
     * @type {Expression}
     * @memberof BinaryExpression
     */
    left?: Expression;
    /**
     * 
     * @type {Expression}
     * @memberof BinaryExpression
     */
    right?: Expression;
}

/**
 * a set of statements
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * type of AST node
     * @type {string}
     * @memberof Block
     */
    type?: string;
    /**
     * block body
     * @type {Array<Statement>}
     * @memberof Block
     */
    body?: Array<Statement>;
}

/**
 * represents boolean values
 * @export
 * @interface BooleanLiteral
 */
export interface BooleanLiteral {
    /**
     * type of AST node
     * @type {string}
     * @memberof BooleanLiteral
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BooleanLiteral
     */
    value?: boolean;
}

/**
 * 
 * @export
 * @interface Bucket
 */
export interface Bucket {
    /**
     * 
     * @type {BucketLinks}
     * @memberof Bucket
     */
    links?: BucketLinks;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    orgID?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    rp?: string;
    /**
     * 
     * @type {Date}
     * @memberof Bucket
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Bucket
     */
    updatedAt?: Date;
    /**
     * rules to expire or retain data.  No rules means data never expires.
     * @type {Array<BucketRetentionRules>}
     * @memberof Bucket
     */
    retentionRules: Array<BucketRetentionRules>;
    /**
     * 
     * @type {Array<Label>}
     * @memberof Bucket
     */
    labels?: Array<Label>;
}

/**
 * 
 * @export
 * @interface BucketLinks
 */
export interface BucketLinks {
    /**
     * URI of resource.
     * @type {string}
     * @memberof BucketLinks
     */
    labels?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof BucketLinks
     */
    logs?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof BucketLinks
     */
    members?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof BucketLinks
     */
    org?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof BucketLinks
     */
    owners?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof BucketLinks
     */
    self?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof BucketLinks
     */
    write?: string;
}

/**
 * 
 * @export
 * @interface BucketRetentionRules
 */
export interface BucketRetentionRules {
    /**
     * 
     * @type {string}
     * @memberof BucketRetentionRules
     */
    type: BucketRetentionRules.TypeEnum;
    /**
     * duration in seconds for how long data will be kept in the database.
     * @type {number}
     * @memberof BucketRetentionRules
     */
    everySeconds: number;
}

/**
 * @export
 * @namespace BucketRetentionRules
 */
export namespace BucketRetentionRules {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Expire = 'expire'
    }
}

/**
 * 
 * @export
 * @interface Buckets
 */
export interface Buckets {
    /**
     * 
     * @type {Links}
     * @memberof Buckets
     */
    links?: Links;
    /**
     * 
     * @type {Array<Bucket>}
     * @memberof Buckets
     */
    buckets?: Array<Bucket>;
}

/**
 * declares a builtin identifier and its type
 * @export
 * @interface BuiltinStatement
 */
export interface BuiltinStatement {
    /**
     * type of AST node
     * @type {string}
     * @memberof BuiltinStatement
     */
    type?: string;
    /**
     * 
     * @type {Identifier}
     * @memberof BuiltinStatement
     */
    id?: Identifier;
}

/**
 * represents a function call
 * @export
 * @interface CallExpression
 */
export interface CallExpression {
    /**
     * type of AST node
     * @type {string}
     * @memberof CallExpression
     */
    type?: string;
    /**
     * 
     * @type {Expression}
     * @memberof CallExpression
     */
    callee?: Expression;
    /**
     * function arguments
     * @type {Array<Expression>}
     * @memberof CallExpression
     */
    arguments?: Array<Expression>;
}

/**
 * 
 * @export
 * @interface Cell
 */
export interface Cell {
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    id?: string;
    /**
     * 
     * @type {CellLinks}
     * @memberof Cell
     */
    links?: CellLinks;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    w?: number;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    h?: number;
    /**
     * The reference to a view from the views API
     * @type {string}
     * @memberof Cell
     */
    viewID?: string;
}

/**
 * 
 * @export
 * @interface CellLinks
 */
export interface CellLinks {
    /**
     * 
     * @type {string}
     * @memberof CellLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof CellLinks
     */
    view?: string;
}

/**
 * 
 * @export
 * @interface CellUpdate
 */
export interface CellUpdate {
    /**
     * 
     * @type {number}
     * @memberof CellUpdate
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof CellUpdate
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof CellUpdate
     */
    w?: number;
    /**
     * 
     * @type {number}
     * @memberof CellUpdate
     */
    h?: number;
}

/**
 * 
 * @export
 * @interface Check
 */
export interface Check {
    /**
     * 
     * @type {string}
     * @memberof Check
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Check
     */
    message?: string;
    /**
     * 
     * @type {Array<Check>}
     * @memberof Check
     */
    checks?: Array<Check>;
    /**
     * 
     * @type {string}
     * @memberof Check
     */
    status: Check.StatusEnum;
}

/**
 * @export
 * @namespace Check
 */
export namespace Check {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Pass = 'pass',
        Fail = 'fail'
    }
}

/**
 * selects one of two expressions, `Alternate` or `Consequent`, depending on a third boolean expression, `Test`
 * @export
 * @interface ConditionalExpression
 */
export interface ConditionalExpression {
    /**
     * type of AST node
     * @type {string}
     * @memberof ConditionalExpression
     */
    type?: string;
    /**
     * 
     * @type {Expression}
     * @memberof ConditionalExpression
     */
    test?: Expression;
    /**
     * 
     * @type {Expression}
     * @memberof ConditionalExpression
     */
    alternate?: Expression;
    /**
     * 
     * @type {Expression}
     * @memberof ConditionalExpression
     */
    consequent?: Expression;
}

/**
 * 
 * @export
 * @interface ConstantVariableProperties
 */
export interface ConstantVariableProperties {
    /**
     * 
     * @type {string}
     * @memberof ConstantVariableProperties
     */
    type?: ConstantVariableProperties.TypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConstantVariableProperties
     */
    values?: Array<string>;
}

/**
 * @export
 * @namespace ConstantVariableProperties
 */
export namespace ConstantVariableProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Constant = 'constant'
    }
}

/**
 * 
 * @export
 * @interface CreateCell
 */
export interface CreateCell {
    /**
     * 
     * @type {string}
     * @memberof CreateCell
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCell
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCell
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCell
     */
    w?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateCell
     */
    h?: number;
    /**
     * makes a copy of the provided view
     * @type {string}
     * @memberof CreateCell
     */
    usingView?: string;
}

/**
 * 
 * @export
 * @interface CreateDashboardRequest
 */
export interface CreateDashboardRequest {
    /**
     * id of the organization that owns the dashboard
     * @type {string}
     * @memberof CreateDashboardRequest
     */
    orgID: string;
    /**
     * user-facing name of the dashboard
     * @type {string}
     * @memberof CreateDashboardRequest
     */
    name: string;
    /**
     * user-facing description of the dashboard
     * @type {string}
     * @memberof CreateDashboardRequest
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface Dashboard
 */
export interface Dashboard extends CreateDashboardRequest {
    /**
     * 
     * @type {any}
     * @memberof Dashboard
     */
    links?: any;
    /**
     * 
     * @type {string}
     * @memberof Dashboard
     */
    id?: string;
    /**
     * 
     * @type {any}
     * @memberof Dashboard
     */
    meta?: any;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof Dashboard
     */
    cells?: Array<Cell>;
    /**
     * 
     * @type {Array<Label>}
     * @memberof Dashboard
     */
    labels?: Array<Label>;
}

/**
 * Color defines an encoding of data value into color space
 * @export
 * @interface DashboardColor
 */
export interface DashboardColor {
    /**
     * ID is the unique id of the view color
     * @type {string}
     * @memberof DashboardColor
     */
    id?: string;
    /**
     * Type is how the color is used.
     * @type {string}
     * @memberof DashboardColor
     */
    type?: DashboardColor.TypeEnum;
    /**
     * Hex is the hex number of the color
     * @type {string}
     * @memberof DashboardColor
     */
    hex?: string;
    /**
     * Name is the user-facing name of the hex color
     * @type {string}
     * @memberof DashboardColor
     */
    name?: string;
    /**
     * Value is the data value mapped to this color
     * @type {string}
     * @memberof DashboardColor
     */
    value?: string;
}

/**
 * @export
 * @namespace DashboardColor
 */
export namespace DashboardColor {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Min = 'min',
        Max = 'max',
        Threshold = 'threshold'
    }
}

/**
 * 
 * @export
 * @interface DashboardQuery
 */
export interface DashboardQuery {
    /**
     * Optional Y-axis user-facing label
     * @type {string}
     * @memberof DashboardQuery
     */
    label?: string;
    /**
     * 
     * @type {DashboardQueryRange}
     * @memberof DashboardQuery
     */
    range?: DashboardQueryRange;
    /**
     * 
     * @type {string}
     * @memberof DashboardQuery
     */
    query: string;
    /**
     * Optional URI for data source for this query
     * @type {string}
     * @memberof DashboardQuery
     */
    source?: string;
    /**
     * 
     * @type {QueryConfig}
     * @memberof DashboardQuery
     */
    queryConfig?: QueryConfig;
}

/**
 * Optional default range of the Y-axis
 * @export
 * @interface DashboardQueryRange
 */
export interface DashboardQueryRange {
    /**
     * Upper bound of the display range of the Y-axis
     * @type {number}
     * @memberof DashboardQueryRange
     */
    upper: number;
    /**
     * Lower bound of the display range of the Y-axis
     * @type {number}
     * @memberof DashboardQueryRange
     */
    lower: number;
}

/**
 * 
 * @export
 * @interface Dashboards
 */
export interface Dashboards {
    /**
     * 
     * @type {Links}
     * @memberof Dashboards
     */
    links?: Links;
    /**
     * 
     * @type {Array<Dashboard>}
     * @memberof Dashboards
     */
    dashboards?: Array<Dashboard>;
}

/**
 * represents an instant in time with nanosecond precision using the syntax of golang's RFC3339 Nanosecond variant
 * @export
 * @interface DateTimeLiteral
 */
export interface DateTimeLiteral {
    /**
     * type of AST node
     * @type {string}
     * @memberof DateTimeLiteral
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof DateTimeLiteral
     */
    value?: string;
}

/**
 * indicates whether decimal places should be enforced, and how many digits it should show.
 * @export
 * @interface DecimalPlaces
 */
export interface DecimalPlaces {
    /**
     * Indicates whether decimal point setting should be enforced
     * @type {boolean}
     * @memberof DecimalPlaces
     */
    isEnforced?: boolean;
    /**
     * The number of digits after decimal to display
     * @type {number}
     * @memberof DecimalPlaces
     */
    digits?: number;
}

/**
 * dialect are options to change the default CSV output format; https://www.w3.org/TR/2015/REC-tabular-metadata-20151217/#dialect-descriptions
 * @export
 * @interface Dialect
 */
export interface Dialect {
    /**
     * if true, the results will contain a header row
     * @type {boolean}
     * @memberof Dialect
     */
    header?: boolean;
    /**
     * separator between cells; the default is ,
     * @type {string}
     * @memberof Dialect
     */
    delimiter?: string;
    /**
     * https://www.w3.org/TR/2015/REC-tabular-data-model-20151217/#columns
     * @type {Array<string>}
     * @memberof Dialect
     */
    annotations?: Array<Dialect.AnnotationsEnum>;
    /**
     * character prefixed to comment strings
     * @type {string}
     * @memberof Dialect
     */
    commentPrefix?: string;
    /**
     * format of timestamps
     * @type {string}
     * @memberof Dialect
     */
    dateTimeFormat?: Dialect.DateTimeFormatEnum;
}

/**
 * @export
 * @namespace Dialect
 */
export namespace Dialect {
    /**
     * @export
     * @enum {string}
     */
    export enum AnnotationsEnum {
        Group = 'group',
        Datatype = 'datatype',
        Default = 'default'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DateTimeFormatEnum {
        RFC3339 = 'RFC3339',
        RFC3339Nano = 'RFC3339Nano'
    }
}

/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    id: string;
    /**
     * 
     * @type {DocumentMeta}
     * @memberof Document
     */
    meta: DocumentMeta;
    /**
     * 
     * @type {any}
     * @memberof Document
     */
    content: any;
    /**
     * 
     * @type {Array<Label>}
     * @memberof Document
     */
    labels?: Array<Label>;
    /**
     * 
     * @type {DocumentLinks}
     * @memberof Document
     */
    links?: DocumentLinks;
}

/**
 * 
 * @export
 * @interface DocumentCreate
 */
export interface DocumentCreate {
    /**
     * 
     * @type {DocumentMeta}
     * @memberof DocumentCreate
     */
    meta: DocumentMeta;
    /**
     * 
     * @type {any}
     * @memberof DocumentCreate
     */
    content: any;
    /**
     * must specify one of orgID and org
     * @type {string}
     * @memberof DocumentCreate
     */
    org?: string;
    /**
     * must specify one of orgID and org
     * @type {string}
     * @memberof DocumentCreate
     */
    orgID?: string;
    /**
     * this is an array of label IDs that will be added as labels to the document
     * @type {Array<string>}
     * @memberof DocumentCreate
     */
    labels?: Array<string>;
}

/**
 * 
 * @export
 * @interface DocumentLinks
 */
export interface DocumentLinks {
    /**
     * URI of resource.
     * @type {string}
     * @memberof DocumentLinks
     */
    self?: string;
}

/**
 * 
 * @export
 * @interface DocumentListEntry
 */
export interface DocumentListEntry {
    /**
     * 
     * @type {string}
     * @memberof DocumentListEntry
     */
    id: string;
    /**
     * 
     * @type {DocumentMeta}
     * @memberof DocumentListEntry
     */
    meta: DocumentMeta;
    /**
     * 
     * @type {Array<Label>}
     * @memberof DocumentListEntry
     */
    labels?: Array<Label>;
    /**
     * 
     * @type {DocumentLinks}
     * @memberof DocumentListEntry
     */
    links?: DocumentLinks;
}

/**
 * 
 * @export
 * @interface DocumentMeta
 */
export interface DocumentMeta {
    /**
     * 
     * @type {string}
     * @memberof DocumentMeta
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentMeta
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentMeta
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentMeta
     */
    version: string;
    /**
     * 
     * @type {Date}
     * @memberof DocumentMeta
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DocumentMeta
     */
    updatedAt?: Date;
}

/**
 * 
 * @export
 * @interface DocumentUpdate
 */
export interface DocumentUpdate {
    /**
     * 
     * @type {DocumentMeta}
     * @memberof DocumentUpdate
     */
    meta?: DocumentMeta;
    /**
     * 
     * @type {any}
     * @memberof DocumentUpdate
     */
    content?: any;
}

/**
 * 
 * @export
 * @interface Documents
 */
export interface Documents {
    /**
     * 
     * @type {Array<DocumentListEntry>}
     * @memberof Documents
     */
    documents?: Array<DocumentListEntry>;
}

/**
 * a pair consisting of length of time and the unit of time measured. It is the atomic unit from which all duration literals are composed.
 * @export
 * @interface Duration
 */
export interface Duration {
    /**
     * type of AST node
     * @type {string}
     * @memberof Duration
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof Duration
     */
    magnitude?: number;
    /**
     * 
     * @type {string}
     * @memberof Duration
     */
    unit?: string;
}

/**
 * represents the elapsed time between two instants as an int64 nanosecond count with syntax of golang's time.Duration
 * @export
 * @interface DurationLiteral
 */
export interface DurationLiteral {
    /**
     * type of AST node
     * @type {string}
     * @memberof DurationLiteral
     */
    type?: string;
    /**
     * duration values
     * @type {Array<Duration>}
     * @memberof DurationLiteral
     */
    values?: Array<Duration>;
}

/**
 * 
 * @export
 * @interface EmptyViewProperties
 */
export interface EmptyViewProperties {
    /**
     * 
     * @type {string}
     * @memberof EmptyViewProperties
     */
    type?: EmptyViewProperties.TypeEnum;
}

/**
 * @export
 * @namespace EmptyViewProperties
 */
export namespace EmptyViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Empty = 'empty'
    }
}

/**
 * 
 * @export
 * @interface Expression
 */
export interface Expression {
}

/**
 * may consist of an expression that does not return a value and is executed solely for its side-effects
 * @export
 * @interface ExpressionStatement
 */
export interface ExpressionStatement {
    /**
     * type of AST node
     * @type {string}
     * @memberof ExpressionStatement
     */
    type?: string;
    /**
     * 
     * @type {Expression}
     * @memberof ExpressionStatement
     */
    expression?: Expression;
}

/**
 * 
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * value is the value of the field.  Meaning of the value is implied by the `type` key
     * @type {string}
     * @memberof Field
     */
    value?: string;
    /**
     * type describes the field type. func is a function; field is a field reference
     * @type {string}
     * @memberof Field
     */
    type?: Field.TypeEnum;
    /**
     * Alias overrides the field name in the returned response.  Applies only if type is `func`
     * @type {string}
     * @memberof Field
     */
    alias?: string;
    /**
     * Args are the arguments to the function
     * @type {Array<Field>}
     * @memberof Field
     */
    args?: Array<Field>;
}

/**
 * @export
 * @namespace Field
 */
export namespace Field {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Func = 'func',
        Field = 'field',
        Integer = 'integer',
        Number = 'number',
        Regex = 'regex',
        Wildcard = 'wildcard'
    }
}

/**
 * represents floating point numbers according to the double representations defined by the IEEE-754-1985
 * @export
 * @interface FloatLiteral
 */
export interface FloatLiteral {
    /**
     * type of AST node
     * @type {string}
     * @memberof FloatLiteral
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof FloatLiteral
     */
    value?: number;
}

/**
 * 
 * @export
 * @interface FluxSuggestions
 */
export interface FluxSuggestions {
    /**
     * 
     * @type {FluxSuggestionsFuncs}
     * @memberof FluxSuggestions
     */
    funcs?: FluxSuggestionsFuncs;
}

/**
 * 
 * @export
 * @interface FluxSuggestionsFuncs
 */
export interface FluxSuggestionsFuncs {
    /**
     * 
     * @type {string}
     * @memberof FluxSuggestionsFuncs
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof FluxSuggestionsFuncs
     */
    params?: any;
}

/**
 * function expression
 * @export
 * @interface FunctionExpression
 */
export interface FunctionExpression {
    /**
     * type of AST node
     * @type {string}
     * @memberof FunctionExpression
     */
    type?: string;
    /**
     * function parameters
     * @type {Array<Property>}
     * @memberof FunctionExpression
     */
    params?: Array<Property>;
    /**
     * 
     * @type {Node}
     * @memberof FunctionExpression
     */
    body?: Node;
}

/**
 * 
 * @export
 * @interface GaugeViewProperties
 */
export interface GaugeViewProperties extends ViewProperties {
    /**
     * 
     * @type {string}
     * @memberof GaugeViewProperties
     */
    type?: GaugeViewProperties.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GaugeViewProperties
     */
    prefix?: string;
    /**
     * 
     * @type {string}
     * @memberof GaugeViewProperties
     */
    suffix?: string;
    /**
     * 
     * @type {Legend}
     * @memberof GaugeViewProperties
     */
    legend?: Legend;
    /**
     * 
     * @type {DecimalPlaces}
     * @memberof GaugeViewProperties
     */
    decimalPlaces?: DecimalPlaces;
}

/**
 * @export
 * @namespace GaugeViewProperties
 */
export namespace GaugeViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Gauge = 'gauge'
    }
}

/**
 * 
 * @export
 * @interface HistogramViewProperties
 */
export interface HistogramViewProperties extends ViewProperties {
    /**
     * 
     * @type {string}
     * @memberof HistogramViewProperties
     */
    type?: HistogramViewProperties.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof HistogramViewProperties
     */
    xColumn?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof HistogramViewProperties
     */
    fillColumns?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof HistogramViewProperties
     */
    xDomain?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof HistogramViewProperties
     */
    xAxisLabel?: string;
    /**
     * 
     * @type {string}
     * @memberof HistogramViewProperties
     */
    position?: string;
    /**
     * 
     * @type {number}
     * @memberof HistogramViewProperties
     */
    binCount?: number;
}

/**
 * @export
 * @namespace HistogramViewProperties
 */
export namespace HistogramViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Histogram = 'histogram'
    }
}

/**
 * a valid Flux identifier
 * @export
 * @interface Identifier
 */
export interface Identifier {
    /**
     * type of AST node
     * @type {string}
     * @memberof Identifier
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Identifier
     */
    name?: string;
}

/**
 * declares a package import
 * @export
 * @interface ImportDeclaration
 */
export interface ImportDeclaration {
    /**
     * type of AST node
     * @type {string}
     * @memberof ImportDeclaration
     */
    type?: string;
    /**
     * 
     * @type {Identifier}
     * @memberof ImportDeclaration
     */
    as?: Identifier;
    /**
     * 
     * @type {StringLiteral}
     * @memberof ImportDeclaration
     */
    path?: StringLiteral;
}

/**
 * represents indexing into an array
 * @export
 * @interface IndexExpression
 */
export interface IndexExpression {
    /**
     * type of AST node
     * @type {string}
     * @memberof IndexExpression
     */
    type?: string;
    /**
     * 
     * @type {Expression}
     * @memberof IndexExpression
     */
    array?: Expression;
    /**
     * 
     * @type {Expression}
     * @memberof IndexExpression
     */
    index?: Expression;
}

/**
 * represents integer numbers
 * @export
 * @interface IntegerLiteral
 */
export interface IntegerLiteral {
    /**
     * type of AST node
     * @type {string}
     * @memberof IntegerLiteral
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegerLiteral
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface IsOnboarding
 */
export interface IsOnboarding {
    /**
     * true means that the influxdb instance has NOT had initial setup; false means that the database has been setup.
     * @type {boolean}
     * @memberof IsOnboarding
     */
    allowed?: boolean;
}

/**
 * 
 * @export
 * @interface Label
 */
export interface Label {
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    orgID?: string;
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    name?: string;
    /**
     * Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value.
     * @type {{ [key: string]: string; }}
     * @memberof Label
     */
    properties?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface LabelCreateRequest
 */
export interface LabelCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof LabelCreateRequest
     */
    orgID: string;
    /**
     * 
     * @type {string}
     * @memberof LabelCreateRequest
     */
    name?: string;
    /**
     * Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value.
     * @type {{ [key: string]: string; }}
     * @memberof LabelCreateRequest
     */
    properties?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface LabelMapping
 */
export interface LabelMapping {
    /**
     * 
     * @type {string}
     * @memberof LabelMapping
     */
    labelID?: string;
}

/**
 * 
 * @export
 * @interface LabelResponse
 */
export interface LabelResponse {
    /**
     * 
     * @type {Label}
     * @memberof LabelResponse
     */
    label?: Label;
    /**
     * 
     * @type {Links}
     * @memberof LabelResponse
     */
    links?: Links;
}

/**
 * 
 * @export
 * @interface LabelUpdate
 */
export interface LabelUpdate {
    /**
     * 
     * @type {string}
     * @memberof LabelUpdate
     */
    name?: string;
    /**
     * Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value.
     * @type {any}
     * @memberof LabelUpdate
     */
    properties?: any;
}

/**
 * 
 * @export
 * @interface LabelsResponse
 */
export interface LabelsResponse {
    /**
     * 
     * @type {Array<Label>}
     * @memberof LabelsResponse
     */
    labels?: Array<Label>;
    /**
     * 
     * @type {Links}
     * @memberof LabelsResponse
     */
    links?: Links;
}

/**
 * flux query to be analyzed.
 * @export
 * @interface LanguageRequest
 */
export interface LanguageRequest {
    /**
     * flux query script to be analyzed
     * @type {string}
     * @memberof LanguageRequest
     */
    query: string;
}

/**
 * Legend define encoding of data into a view's legend
 * @export
 * @interface Legend
 */
export interface Legend {
    /**
     * type is the style of the legend
     * @type {string}
     * @memberof Legend
     */
    type?: Legend.TypeEnum;
    /**
     * orientation is the location of the legend with respect to the view graph
     * @type {string}
     * @memberof Legend
     */
    orientation?: Legend.OrientationEnum;
}

/**
 * @export
 * @namespace Legend
 */
export namespace Legend {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Static = 'static'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OrientationEnum {
        Top = 'top',
        Bottom = 'bottom',
        Left = 'left',
        Right = 'right'
    }
}

/**
 * 
 * @export
 * @interface LinePlusSingleStatProperties
 */
export interface LinePlusSingleStatProperties extends ViewProperties {
    /**
     * 
     * @type {Axes}
     * @memberof LinePlusSingleStatProperties
     */
    axes?: Axes;
    /**
     * 
     * @type {string}
     * @memberof LinePlusSingleStatProperties
     */
    type?: LinePlusSingleStatProperties.TypeEnum;
    /**
     * 
     * @type {Legend}
     * @memberof LinePlusSingleStatProperties
     */
    legend?: Legend;
    /**
     * 
     * @type {string}
     * @memberof LinePlusSingleStatProperties
     */
    prefix?: string;
    /**
     * 
     * @type {string}
     * @memberof LinePlusSingleStatProperties
     */
    suffix?: string;
    /**
     * 
     * @type {DecimalPlaces}
     * @memberof LinePlusSingleStatProperties
     */
    decimalPlaces?: DecimalPlaces;
}

/**
 * @export
 * @namespace LinePlusSingleStatProperties
 */
export namespace LinePlusSingleStatProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        LinePlusSingleStat = 'line-plus-single-stat'
    }
}

/**
 * 
 * @export
 * @interface LineProtocolError
 */
export interface LineProtocolError {
    /**
     * code is the machine-readable error code.
     * @type {string}
     * @memberof LineProtocolError
     */
    code: LineProtocolError.CodeEnum;
    /**
     * message is a human-readable message.
     * @type {string}
     * @memberof LineProtocolError
     */
    message: string;
    /**
     * op describes the logical code operation during error. Useful for debugging.
     * @type {string}
     * @memberof LineProtocolError
     */
    op: string;
    /**
     * err is a stack of errors that occurred during processing of the request. Useful for debugging.
     * @type {string}
     * @memberof LineProtocolError
     */
    err: string;
    /**
     * first line within sent body containing malformed data
     * @type {number}
     * @memberof LineProtocolError
     */
    line?: number;
}

/**
 * @export
 * @namespace LineProtocolError
 */
export namespace LineProtocolError {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        InternalError = 'internal error',
        NotFound = 'not found',
        Conflict = 'conflict',
        Invalid = 'invalid',
        EmptyValue = 'empty value',
        Unavailable = 'unavailable'
    }
}

/**
 * 
 * @export
 * @interface LineProtocolLengthError
 */
export interface LineProtocolLengthError {
    /**
     * code is the machine-readable error code.
     * @type {string}
     * @memberof LineProtocolLengthError
     */
    code: LineProtocolLengthError.CodeEnum;
    /**
     * message is a human-readable message.
     * @type {string}
     * @memberof LineProtocolLengthError
     */
    message: string;
    /**
     * max length in bytes for a body of line-protocol.
     * @type {number}
     * @memberof LineProtocolLengthError
     */
    maxLength: number;
}

/**
 * @export
 * @namespace LineProtocolLengthError
 */
export namespace LineProtocolLengthError {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        Invalid = 'invalid'
    }
}

/**
 * 
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * URI of resource.
     * @type {string}
     * @memberof Links
     */
    next?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof Links
     */
    self: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof Links
     */
    prev?: string;
}

/**
 * 
 * @export
 * @interface LogEvent
 */
export interface LogEvent {
    /**
     * Time event occurred, RFC3339Nano.
     * @type {Date}
     * @memberof LogEvent
     */
    time?: Date;
    /**
     * A description of the event that occurred.
     * @type {string}
     * @memberof LogEvent
     */
    message?: string;
}

/**
 * Contains the configuration for the log viewer
 * @export
 * @interface LogViewProperties
 */
export interface LogViewProperties {
    /**
     * 
     * @type {string}
     * @memberof LogViewProperties
     */
    shape: LogViewProperties.ShapeEnum;
    /**
     * 
     * @type {string}
     * @memberof LogViewProperties
     */
    type: LogViewProperties.TypeEnum;
    /**
     * Defines the order, names, and visibility of columns in the log viewer table
     * @type {Array<LogViewerColumn>}
     * @memberof LogViewProperties
     */
    columns: Array<LogViewerColumn>;
}

/**
 * @export
 * @namespace LogViewProperties
 */
export namespace LogViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum ShapeEnum {
        ChronografV2 = 'chronograf-v2'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        LogViewer = 'log-viewer'
    }
}

/**
 * Contains a specific column's settings.
 * @export
 * @interface LogViewerColumn
 */
export interface LogViewerColumn {
    /**
     * Unique identifier name of the column
     * @type {string}
     * @memberof LogViewerColumn
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof LogViewerColumn
     */
    position: number;
    /**
     * Composable settings options for the column
     * @type {Array<LogViewerColumnSettings>}
     * @memberof LogViewerColumn
     */
    settings: Array<LogViewerColumnSettings>;
}

/**
 * Type and value and optional name of a setting.
 * @export
 * @interface LogViewerColumnSettings
 */
export interface LogViewerColumnSettings {
    /**
     * 
     * @type {string}
     * @memberof LogViewerColumnSettings
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof LogViewerColumnSettings
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof LogViewerColumnSettings
     */
    name?: string;
}

/**
 * represents the rule conditions that collectively evaluate to either true or false
 * @export
 * @interface LogicalExpression
 */
export interface LogicalExpression {
    /**
     * type of AST node
     * @type {string}
     * @memberof LogicalExpression
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof LogicalExpression
     */
    operator?: string;
    /**
     * 
     * @type {Expression}
     * @memberof LogicalExpression
     */
    left?: Expression;
    /**
     * 
     * @type {Expression}
     * @memberof LogicalExpression
     */
    right?: Expression;
}

/**
 * 
 * @export
 * @interface Logs
 */
export interface Logs {
    /**
     * 
     * @type {Array<LogEvent>}
     * @memberof Logs
     */
    events?: Array<LogEvent>;
}

/**
 * 
 * @export
 * @interface MapVariableProperties
 */
export interface MapVariableProperties {
    /**
     * 
     * @type {string}
     * @memberof MapVariableProperties
     */
    type?: MapVariableProperties.TypeEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MapVariableProperties
     */
    values?: { [key: string]: string; };
}

/**
 * @export
 * @namespace MapVariableProperties
 */
export namespace MapVariableProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Map = 'map'
    }
}

/**
 * 
 * @export
 * @interface MarkdownViewProperties
 */
export interface MarkdownViewProperties {
    /**
     * 
     * @type {string}
     * @memberof MarkdownViewProperties
     */
    type?: MarkdownViewProperties.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof MarkdownViewProperties
     */
    note?: string;
}

/**
 * @export
 * @namespace MarkdownViewProperties
 */
export namespace MarkdownViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Markdown = 'markdown'
    }
}

/**
 * object property assignment
 * @export
 * @interface MemberAssignment
 */
export interface MemberAssignment {
    /**
     * type of AST node
     * @type {string}
     * @memberof MemberAssignment
     */
    type?: string;
    /**
     * 
     * @type {MemberExpression}
     * @memberof MemberAssignment
     */
    member?: MemberExpression;
    /**
     * 
     * @type {Expression}
     * @memberof MemberAssignment
     */
    init?: Expression;
}

/**
 * represents accessing a property of an object
 * @export
 * @interface MemberExpression
 */
export interface MemberExpression {
    /**
     * type of AST node
     * @type {string}
     * @memberof MemberExpression
     */
    type?: string;
    /**
     * 
     * @type {Expression}
     * @memberof MemberExpression
     */
    object?: Expression;
    /**
     * 
     * @type {PropertyKey}
     * @memberof MemberExpression
     */
    property?: PropertyKey;
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * code is the machine-readable error code.
     * @type {string}
     * @memberof ModelError
     */
    code: ModelError.CodeEnum;
    /**
     * message is a human-readable message.
     * @type {string}
     * @memberof ModelError
     */
    message: string;
    /**
     * op describes the logical code operation during error. Useful for debugging.
     * @type {string}
     * @memberof ModelError
     */
    op?: string;
    /**
     * err is a stack of errors that occurred during processing of the request. Useful for debugging.
     * @type {string}
     * @memberof ModelError
     */
    err?: string;
}

/**
 * @export
 * @namespace ModelError
 */
export namespace ModelError {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        InternalError = 'internal error',
        NotFound = 'not found',
        Conflict = 'conflict',
        Invalid = 'invalid',
        UnprocessableEntity = 'unprocessable entity',
        EmptyValue = 'empty value',
        Unavailable = 'unavailable',
        Forbidden = 'forbidden',
        TooManyRequests = 'too many requests',
        Unauthorized = 'unauthorized',
        MethodNotAllowed = 'method not allowed'
    }
}

/**
 * represents a source from a single file
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * type of AST node
     * @type {string}
     * @memberof ModelFile
     */
    type?: string;
    /**
     * name of the file
     * @type {string}
     * @memberof ModelFile
     */
    name?: string;
    /**
     * 
     * @type {PackageClause}
     * @memberof ModelFile
     */
    _package?: PackageClause;
    /**
     * a list of package imports
     * @type {Array<ImportDeclaration>}
     * @memberof ModelFile
     */
    imports?: Array<ImportDeclaration>;
    /**
     * list of Flux statements
     * @type {Array<Statement>}
     * @memberof ModelFile
     */
    body?: Array<Statement>;
}

/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
}

/**
 * allows the declaration of an anonymous object within a declaration
 * @export
 * @interface ObjectExpression
 */
export interface ObjectExpression {
    /**
     * type of AST node
     * @type {string}
     * @memberof ObjectExpression
     */
    type?: string;
    /**
     * object properties
     * @type {Array<Property>}
     * @memberof ObjectExpression
     */
    properties?: Array<Property>;
}

/**
 * 
 * @export
 * @interface OnboardingRequest
 */
export interface OnboardingRequest {
    /**
     * 
     * @type {string}
     * @memberof OnboardingRequest
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingRequest
     */
    org: string;
    /**
     * 
     * @type {string}
     * @memberof OnboardingRequest
     */
    bucket: string;
    /**
     * 
     * @type {number}
     * @memberof OnboardingRequest
     */
    retentionPeriodHrs?: number;
}

/**
 * 
 * @export
 * @interface OnboardingResponse
 */
export interface OnboardingResponse {
    /**
     * 
     * @type {User}
     * @memberof OnboardingResponse
     */
    user?: User;
    /**
     * 
     * @type {Organization}
     * @memberof OnboardingResponse
     */
    org?: Organization;
    /**
     * 
     * @type {Bucket}
     * @memberof OnboardingResponse
     */
    bucket?: Bucket;
    /**
     * 
     * @type {Authorization}
     * @memberof OnboardingResponse
     */
    auth?: Authorization;
}

/**
 * 
 * @export
 * @interface OperationLog
 */
export interface OperationLog {
    /**
     * A description of the event that occurred.
     * @type {string}
     * @memberof OperationLog
     */
    description?: string;
    /**
     * Time event occurred, RFC3339Nano.
     * @type {Date}
     * @memberof OperationLog
     */
    time?: Date;
    /**
     * ID of the user who operated the event.
     * @type {string}
     * @memberof OperationLog
     */
    userID?: string;
    /**
     * 
     * @type {OperationLogLinks}
     * @memberof OperationLog
     */
    links?: OperationLogLinks;
}

/**
 * 
 * @export
 * @interface OperationLogLinks
 */
export interface OperationLogLinks {
    /**
     * URI of resource.
     * @type {string}
     * @memberof OperationLogLinks
     */
    user?: string;
}

/**
 * 
 * @export
 * @interface OperationLogs
 */
export interface OperationLogs {
    /**
     * 
     * @type {Array<OperationLog>}
     * @memberof OperationLogs
     */
    logs?: Array<OperationLog>;
    /**
     * 
     * @type {Links}
     * @memberof OperationLogs
     */
    links?: Links;
}

/**
 * a single variable declaration
 * @export
 * @interface OptionStatement
 */
export interface OptionStatement {
    /**
     * type of AST node
     * @type {string}
     * @memberof OptionStatement
     */
    type?: string;
    /**
     * 
     * @type {any}
     * @memberof OptionStatement
     */
    assignment?: any;
}

/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {OrganizationLinks}
     * @memberof Organization
     */
    links?: OrganizationLinks;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    description?: string;
    /**
     * 
     * @type {Date}
     * @memberof Organization
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Organization
     */
    updatedAt?: Date;
    /**
     * if inactive the organization is inactive.
     * @type {string}
     * @memberof Organization
     */
    status?: Organization.StatusEnum;
}

/**
 * @export
 * @namespace Organization
 */
export namespace Organization {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface OrganizationLinks
 */
export interface OrganizationLinks {
    /**
     * URI of resource.
     * @type {string}
     * @memberof OrganizationLinks
     */
    self?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof OrganizationLinks
     */
    members?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof OrganizationLinks
     */
    owners?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof OrganizationLinks
     */
    labels?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof OrganizationLinks
     */
    secrets?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof OrganizationLinks
     */
    buckets?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof OrganizationLinks
     */
    tasks?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof OrganizationLinks
     */
    dashboards?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof OrganizationLinks
     */
    logs?: string;
}

/**
 * 
 * @export
 * @interface Organizations
 */
export interface Organizations {
    /**
     * 
     * @type {Links}
     * @memberof Organizations
     */
    links?: Links;
    /**
     * 
     * @type {Array<Organization>}
     * @memberof Organizations
     */
    orgs?: Array<Organization>;
}

/**
 * represents a complete package source tree
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * type of AST node
     * @type {string}
     * @memberof Package
     */
    type?: string;
    /**
     * package import path
     * @type {string}
     * @memberof Package
     */
    path?: string;
    /**
     * package name
     * @type {string}
     * @memberof Package
     */
    _package?: string;
    /**
     * package files
     * @type {Array<any>}
     * @memberof Package
     */
    files?: Array<any>;
}

/**
 * defines a package identifier
 * @export
 * @interface PackageClause
 */
export interface PackageClause {
    /**
     * type of AST node
     * @type {string}
     * @memberof PackageClause
     */
    type?: string;
    /**
     * 
     * @type {Identifier}
     * @memberof PackageClause
     */
    name?: Identifier;
}

/**
 * 
 * @export
 * @interface PasswordResetBody
 */
export interface PasswordResetBody {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetBody
     */
    password: string;
}

/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    action: Permission.ActionEnum;
    /**
     * 
     * @type {PermissionResource}
     * @memberof Permission
     */
    resource: PermissionResource;
}

/**
 * @export
 * @namespace Permission
 */
export namespace Permission {
    /**
     * @export
     * @enum {string}
     */
    export enum ActionEnum {
        Read = 'read',
        Write = 'write'
    }
}

/**
 * 
 * @export
 * @interface PermissionResource
 */
export interface PermissionResource {
    /**
     * 
     * @type {string}
     * @memberof PermissionResource
     */
    type: PermissionResource.TypeEnum;
    /**
     * if id is set that is a permission for a specific resource. if it is not set it is a permission for all resources of that resource type.
     * @type {string}
     * @memberof PermissionResource
     */
    id?: string;
    /**
     * optional name of the resource if the resource has a name field.
     * @type {string}
     * @memberof PermissionResource
     */
    name?: string;
    /**
     * if orgID is set that is a permission for all resources owned my that org. if it is not set it is a permission for all resources of that resource type.
     * @type {string}
     * @memberof PermissionResource
     */
    orgID?: string;
    /**
     * optional name of the organization of the organization with orgID.
     * @type {string}
     * @memberof PermissionResource
     */
    org?: string;
}

/**
 * @export
 * @namespace PermissionResource
 */
export namespace PermissionResource {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Authorizations = 'authorizations',
        Buckets = 'buckets',
        Dashboards = 'dashboards',
        Orgs = 'orgs',
        Sources = 'sources',
        Tasks = 'tasks',
        Telegrafs = 'telegrafs',
        Users = 'users',
        Variables = 'variables',
        Scrapers = 'scrapers',
        Secrets = 'secrets',
        Labels = 'labels',
        Views = 'views',
        Documents = 'documents'
    }
}

/**
 * call expression with pipe argument
 * @export
 * @interface PipeExpression
 */
export interface PipeExpression {
    /**
     * type of AST node
     * @type {string}
     * @memberof PipeExpression
     */
    type?: string;
    /**
     * 
     * @type {Expression}
     * @memberof PipeExpression
     */
    argument?: Expression;
    /**
     * 
     * @type {CallExpression}
     * @memberof PipeExpression
     */
    call?: CallExpression;
}

/**
 * represents a specialized literal value, indicating the left hand value of a pipe expression
 * @export
 * @interface PipeLiteral
 */
export interface PipeLiteral {
    /**
     * type of AST node
     * @type {string}
     * @memberof PipeLiteral
     */
    type?: string;
}

/**
 * the value associated with a key
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * type of AST node
     * @type {string}
     * @memberof Property
     */
    type?: string;
    /**
     * 
     * @type {PropertyKey}
     * @memberof Property
     */
    key?: PropertyKey;
    /**
     * 
     * @type {Expression}
     * @memberof Property
     */
    value?: Expression;
}

/**
 * 
 * @export
 * @interface PropertyKey
 */
export interface PropertyKey {
}

/**
 * query influx with specified return formatting.
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * 
     * @type {any}
     * @memberof Query
     */
    extern?: any;
    /**
     * query script to execute.
     * @type {string}
     * @memberof Query
     */
    query: string;
    /**
     * type of query
     * @type {string}
     * @memberof Query
     */
    type?: Query.TypeEnum;
    /**
     * required for influxql type queries
     * @type {string}
     * @memberof Query
     */
    db?: string;
    /**
     * required for influxql type queries
     * @type {string}
     * @memberof Query
     */
    rp?: string;
    /**
     * required for influxql type queries
     * @type {string}
     * @memberof Query
     */
    cluster?: string;
    /**
     * 
     * @type {Dialect}
     * @memberof Query
     */
    dialect?: Dialect;
}

/**
 * @export
 * @namespace Query
 */
export namespace Query {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Flux = 'flux',
        Influxql = 'influxql'
    }
}

/**
 * 
 * @export
 * @interface QueryConfig
 */
export interface QueryConfig {
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    database: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    measurement: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    retentionPolicy: string;
    /**
     * 
     * @type {boolean}
     * @memberof QueryConfig
     */
    areTagsAccepted: boolean;
    /**
     * 
     * @type {string}
     * @memberof QueryConfig
     */
    rawText?: string;
    /**
     * 
     * @type {any}
     * @memberof QueryConfig
     */
    tags: any;
    /**
     * 
     * @type {QueryConfigGroupBy}
     * @memberof QueryConfig
     */
    groupBy: QueryConfigGroupBy;
    /**
     * 
     * @type {Array<Field>}
     * @memberof QueryConfig
     */
    fields: Array<Field>;
    /**
     * 
     * @type {QueryConfigRange}
     * @memberof QueryConfig
     */
    range?: QueryConfigRange;
}

/**
 * 
 * @export
 * @interface QueryConfigGroupBy
 */
export interface QueryConfigGroupBy {
    /**
     * 
     * @type {string}
     * @memberof QueryConfigGroupBy
     */
    time: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryConfigGroupBy
     */
    tags: Array<string>;
}

/**
 * 
 * @export
 * @interface QueryConfigRange
 */
export interface QueryConfigRange {
    /**
     * 
     * @type {string}
     * @memberof QueryConfigRange
     */
    lower: string;
    /**
     * 
     * @type {string}
     * @memberof QueryConfigRange
     */
    upper: string;
}

/**
 * 
 * @export
 * @interface QueryVariableProperties
 */
export interface QueryVariableProperties {
    /**
     * 
     * @type {string}
     * @memberof QueryVariableProperties
     */
    type?: QueryVariableProperties.TypeEnum;
    /**
     * 
     * @type {QueryVariablePropertiesValues}
     * @memberof QueryVariableProperties
     */
    values?: QueryVariablePropertiesValues;
}

/**
 * @export
 * @namespace QueryVariableProperties
 */
export namespace QueryVariableProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Query = 'query'
    }
}

/**
 * 
 * @export
 * @interface QueryVariablePropertiesValues
 */
export interface QueryVariablePropertiesValues {
    /**
     * 
     * @type {string}
     * @memberof QueryVariablePropertiesValues
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryVariablePropertiesValues
     */
    language?: string;
}

/**
 * 
 * @export
 * @interface Ready
 */
export interface Ready {
    /**
     * 
     * @type {string}
     * @memberof Ready
     */
    status?: Ready.StatusEnum;
    /**
     * 
     * @type {Date}
     * @memberof Ready
     */
    started?: Date;
    /**
     * 
     * @type {string}
     * @memberof Ready
     */
    up?: string;
}

/**
 * @export
 * @namespace Ready
 */
export namespace Ready {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Ready = 'ready'
    }
}

/**
 * expressions begin and end with `/` and are regular expressions with syntax accepted by RE2
 * @export
 * @interface RegexpLiteral
 */
export interface RegexpLiteral {
    /**
     * type of AST node
     * @type {string}
     * @memberof RegexpLiteral
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof RegexpLiteral
     */
    value?: string;
}

/**
 * Describes a field that can be renamed and made visible or invisible
 * @export
 * @interface RenamableField
 */
export interface RenamableField {
    /**
     * This is the calculated name of a field
     * @type {string}
     * @memberof RenamableField
     */
    internalName?: string;
    /**
     * This is the name that a field is renamed to by the user
     * @type {string}
     * @memberof RenamableField
     */
    displayName?: string;
    /**
     * Indicates whether this field should be visible on the table
     * @type {boolean}
     * @memberof RenamableField
     */
    visible?: boolean;
}

/**
 * 
 * @export
 * @interface ResourceMember
 */
export interface ResourceMember extends User {
    /**
     * 
     * @type {string}
     * @memberof ResourceMember
     */
    role?: ResourceMember.RoleEnum;
}

/**
 * @export
 * @namespace ResourceMember
 */
export namespace ResourceMember {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        Member = 'member'
    }
}

/**
 * 
 * @export
 * @interface ResourceMembers
 */
export interface ResourceMembers {
    /**
     * 
     * @type {UsersLinks}
     * @memberof ResourceMembers
     */
    links?: UsersLinks;
    /**
     * 
     * @type {Array<ResourceMember>}
     * @memberof ResourceMembers
     */
    users?: Array<ResourceMember>;
}

/**
 * 
 * @export
 * @interface ResourceOwner
 */
export interface ResourceOwner extends User {
    /**
     * 
     * @type {string}
     * @memberof ResourceOwner
     */
    role?: ResourceOwner.RoleEnum;
}

/**
 * @export
 * @namespace ResourceOwner
 */
export namespace ResourceOwner {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        Owner = 'owner'
    }
}

/**
 * 
 * @export
 * @interface ResourceOwners
 */
export interface ResourceOwners {
    /**
     * 
     * @type {UsersLinks}
     * @memberof ResourceOwners
     */
    links?: UsersLinks;
    /**
     * 
     * @type {Array<ResourceOwner>}
     * @memberof ResourceOwners
     */
    users?: Array<ResourceOwner>;
}

/**
 * defines an expression to return
 * @export
 * @interface ReturnStatement
 */
export interface ReturnStatement {
    /**
     * type of AST node
     * @type {string}
     * @memberof ReturnStatement
     */
    type?: string;
    /**
     * 
     * @type {Expression}
     * @memberof ReturnStatement
     */
    argument?: Expression;
}

/**
 * 
 * @export
 * @interface Routes
 */
export interface Routes {
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    authorizations?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    buckets?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    dashboards?: string;
    /**
     * 
     * @type {RoutesExternal}
     * @memberof Routes
     */
    external?: RoutesExternal;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    variables?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    me?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    orgs?: string;
    /**
     * 
     * @type {RoutesQuery}
     * @memberof Routes
     */
    query?: RoutesQuery;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    setup?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    signin?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    signout?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    sources?: string;
    /**
     * 
     * @type {RoutesSystem}
     * @memberof Routes
     */
    system?: RoutesSystem;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    tasks?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    telegrafs?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    users?: string;
    /**
     * 
     * @type {string}
     * @memberof Routes
     */
    write?: string;
}

/**
 * 
 * @export
 * @interface RoutesExternal
 */
export interface RoutesExternal {
    /**
     * 
     * @type {string}
     * @memberof RoutesExternal
     */
    statusFeed?: string;
}

/**
 * 
 * @export
 * @interface RoutesQuery
 */
export interface RoutesQuery {
    /**
     * 
     * @type {string}
     * @memberof RoutesQuery
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutesQuery
     */
    ast?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutesQuery
     */
    analyze?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutesQuery
     */
    suggestions?: string;
}

/**
 * 
 * @export
 * @interface RoutesSystem
 */
export interface RoutesSystem {
    /**
     * 
     * @type {string}
     * @memberof RoutesSystem
     */
    metrics?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutesSystem
     */
    debug?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutesSystem
     */
    health?: string;
}

/**
 * 
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    taskID?: string;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    status?: Run.StatusEnum;
    /**
     * Time used for run's \"now\" option, RFC3339.
     * @type {Date}
     * @memberof Run
     */
    scheduledFor?: Date;
    /**
     * An array of logs associated with the run.
     * @type {Array<RunLog>}
     * @memberof Run
     */
    log?: Array<RunLog>;
    /**
     * Time run started executing, RFC3339Nano.
     * @type {Date}
     * @memberof Run
     */
    startedAt?: Date;
    /**
     * Time run finished executing, RFC3339Nano.
     * @type {Date}
     * @memberof Run
     */
    finishedAt?: Date;
    /**
     * Time run was manually requested, RFC3339Nano.
     * @type {Date}
     * @memberof Run
     */
    requestedAt?: Date;
    /**
     * 
     * @type {RunLinks}
     * @memberof Run
     */
    links?: RunLinks;
}

/**
 * @export
 * @namespace Run
 */
export namespace Run {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Scheduled = 'scheduled',
        Started = 'started',
        Failed = 'failed',
        Success = 'success',
        Canceled = 'canceled'
    }
}

/**
 * 
 * @export
 * @interface RunLinks
 */
export interface RunLinks {
    /**
     * 
     * @type {string}
     * @memberof RunLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof RunLinks
     */
    task?: string;
    /**
     * 
     * @type {string}
     * @memberof RunLinks
     */
    logs?: string;
    /**
     * 
     * @type {string}
     * @memberof RunLinks
     */
    retry?: string;
}

/**
 * 
 * @export
 * @interface RunLog
 */
export interface RunLog {
    /**
     * 
     * @type {string}
     * @memberof RunLog
     */
    runID?: string;
    /**
     * 
     * @type {string}
     * @memberof RunLog
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof RunLog
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface RunManually
 */
export interface RunManually {
    /**
     * Time used for run's \"now\" option, RFC3339.  Default is the server's now time.
     * @type {Date}
     * @memberof RunManually
     */
    scheduledFor?: Date;
}

/**
 * 
 * @export
 * @interface Runs
 */
export interface Runs {
    /**
     * 
     * @type {Links}
     * @memberof Runs
     */
    links?: Links;
    /**
     * 
     * @type {Array<Run>}
     * @memberof Runs
     */
    runs?: Array<Run>;
}

/**
 * 
 * @export
 * @interface ScraperTargetRequest
 */
export interface ScraperTargetRequest {
    /**
     * name of the scraper target
     * @type {string}
     * @memberof ScraperTargetRequest
     */
    name?: string;
    /**
     * type of the metrics to be parsed
     * @type {string}
     * @memberof ScraperTargetRequest
     */
    type?: ScraperTargetRequest.TypeEnum;
    /**
     * url of the metrics endpoint
     * @type {string}
     * @memberof ScraperTargetRequest
     */
    url?: string;
    /**
     * id of the organization
     * @type {string}
     * @memberof ScraperTargetRequest
     */
    orgID?: string;
    /**
     * id of the bucket to be written
     * @type {string}
     * @memberof ScraperTargetRequest
     */
    bucketID?: string;
}

/**
 * @export
 * @namespace ScraperTargetRequest
 */
export namespace ScraperTargetRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Prometheus = 'prometheus'
    }
}

/**
 * 
 * @export
 * @interface ScraperTargetResponse
 */
export interface ScraperTargetResponse extends ScraperTargetRequest {
    /**
     * 
     * @type {string}
     * @memberof ScraperTargetResponse
     */
    id?: string;
    /**
     * name of the organization
     * @type {string}
     * @memberof ScraperTargetResponse
     */
    org?: string;
    /**
     * name of the bucket
     * @type {string}
     * @memberof ScraperTargetResponse
     */
    bucket?: string;
    /**
     * 
     * @type {any}
     * @memberof ScraperTargetResponse
     */
    links?: any;
}

/**
 * @export
 * @namespace ScraperTargetResponse
 */
export namespace ScraperTargetResponse {
}

/**
 * 
 * @export
 * @interface ScraperTargetResponses
 */
export interface ScraperTargetResponses {
    /**
     * 
     * @type {Array<ScraperTargetResponse>}
     * @memberof ScraperTargetResponses
     */
    configurations?: Array<ScraperTargetResponse>;
}

/**
 * 
 * @export
 * @interface SecretKeys
 */
export interface SecretKeys {
    /**
     * 
     * @type {Array<string>}
     * @memberof SecretKeys
     */
    secrets?: Array<string>;
}

/**
 * 
 * @export
 * @interface SecretKeysResponse
 */
export interface SecretKeysResponse extends SecretKeys {
    /**
     * 
     * @type {any}
     * @memberof SecretKeysResponse
     */
    links?: any;
}

/**
 * 
 * @export
 * @interface SingleStatViewProperties
 */
export interface SingleStatViewProperties extends ViewProperties {
    /**
     * 
     * @type {string}
     * @memberof SingleStatViewProperties
     */
    type?: SingleStatViewProperties.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SingleStatViewProperties
     */
    prefix?: string;
    /**
     * 
     * @type {string}
     * @memberof SingleStatViewProperties
     */
    suffix?: string;
    /**
     * 
     * @type {Legend}
     * @memberof SingleStatViewProperties
     */
    legend?: Legend;
    /**
     * 
     * @type {DecimalPlaces}
     * @memberof SingleStatViewProperties
     */
    decimalPlaces?: DecimalPlaces;
}

/**
 * @export
 * @namespace SingleStatViewProperties
 */
export namespace SingleStatViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        SingleStat = 'single-stat'
    }
}

/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {SourceLinks}
     * @memberof Source
     */
    links?: SourceLinks;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    orgID?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Source
     */
    _default?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    type?: Source.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Source
     */
    insecureSkipVerify?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    telegraf?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    sharedSecret?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    metaUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    defaultRP?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Source
     */
    languages?: Array<Source.LanguagesEnum>;
}

/**
 * @export
 * @namespace Source
 */
export namespace Source {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        V1 = 'v1',
        V2 = 'v2',
        Self = 'self'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LanguagesEnum {
        Flux = 'flux',
        Influxql = 'influxql'
    }
}

/**
 * 
 * @export
 * @interface SourceLinks
 */
export interface SourceLinks {
    /**
     * 
     * @type {string}
     * @memberof SourceLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceLinks
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceLinks
     */
    health?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceLinks
     */
    buckets?: string;
}

/**
 * 
 * @export
 * @interface Sources
 */
export interface Sources {
    /**
     * 
     * @type {UsersLinks}
     * @memberof Sources
     */
    links?: UsersLinks;
    /**
     * 
     * @type {Array<Source>}
     * @memberof Sources
     */
    sources?: Array<Source>;
}

/**
 * 
 * @export
 * @interface Statement
 */
export interface Statement {
}

/**
 * expressions begin and end with double quote marks
 * @export
 * @interface StringLiteral
 */
export interface StringLiteral {
    /**
     * type of AST node
     * @type {string}
     * @memberof StringLiteral
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof StringLiteral
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface TableViewProperties
 */
export interface TableViewProperties extends ViewProperties {
    /**
     * 
     * @type {string}
     * @memberof TableViewProperties
     */
    type?: TableViewProperties.TypeEnum;
    /**
     * 
     * @type {any}
     * @memberof TableViewProperties
     */
    tableOptions?: any;
    /**
     * fieldOptions represent the fields retrieved by the query with customization options
     * @type {Array<RenamableField>}
     * @memberof TableViewProperties
     */
    fieldOptions?: Array<RenamableField>;
    /**
     * timeFormat describes the display format for time values according to moment.js date formatting
     * @type {string}
     * @memberof TableViewProperties
     */
    timeFormat?: string;
    /**
     * 
     * @type {DecimalPlaces}
     * @memberof TableViewProperties
     */
    decimalPlaces?: DecimalPlaces;
}

/**
 * @export
 * @namespace TableViewProperties
 */
export namespace TableViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Table = 'table'
    }
}

/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    id: string;
    /**
     * The ID of the organization that owns this Task.
     * @type {string}
     * @memberof Task
     */
    orgID: string;
    /**
     * The name of the organization that owns this Task.
     * @type {string}
     * @memberof Task
     */
    org?: string;
    /**
     * The name of the task.
     * @type {string}
     * @memberof Task
     */
    name: string;
    /**
     * An optional description of the task.
     * @type {string}
     * @memberof Task
     */
    description?: string;
    /**
     * The current status of the task. When updated to 'inactive', cancels all queued jobs of this task.
     * @type {string}
     * @memberof Task
     */
    status?: Task.StatusEnum;
    /**
     * 
     * @type {Array<Label>}
     * @memberof Task
     */
    labels?: Array<Label>;
    /**
     * The ID of the authorization used when this task communicates with the query engine.
     * @type {string}
     * @memberof Task
     */
    authorizationID?: string;
    /**
     * The Flux script to run for this task.
     * @type {string}
     * @memberof Task
     */
    flux: string;
    /**
     * A simple task repetition schedule; parsed from Flux.
     * @type {string}
     * @memberof Task
     */
    every?: string;
    /**
     * A task repetition schedule in the form '* * * * * *'; parsed from Flux.
     * @type {string}
     * @memberof Task
     */
    cron?: string;
    /**
     * Duration to delay after the schedule, before executing the task; parsed from flux, if set to zero it will remove this option and use 0 as the default.
     * @type {string}
     * @memberof Task
     */
    offset?: string;
    /**
     * Timestamp of latest scheduled, completed run, RFC3339.
     * @type {Date}
     * @memberof Task
     */
    latestCompleted?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Task
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Task
     */
    updatedAt?: Date;
    /**
     * 
     * @type {TaskLinks}
     * @memberof Task
     */
    links?: TaskLinks;
}

/**
 * @export
 * @namespace Task
 */
export namespace Task {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface TaskCreateRequest
 */
export interface TaskCreateRequest {
    /**
     * The ID of the organization that owns this Task.
     * @type {string}
     * @memberof TaskCreateRequest
     */
    orgID?: string;
    /**
     * The name of the organization that owns this Task.
     * @type {string}
     * @memberof TaskCreateRequest
     */
    org?: string;
    /**
     * Starting state of the task. 'inactive' tasks are not run until they are updated to 'active'
     * @type {string}
     * @memberof TaskCreateRequest
     */
    status?: TaskCreateRequest.StatusEnum;
    /**
     * The Flux script to run for this task.
     * @type {string}
     * @memberof TaskCreateRequest
     */
    flux: string;
    /**
     * The token to use for authenticating this task when it executes queries. If omitted, uses the token associated with the request that creates the task.
     * @type {string}
     * @memberof TaskCreateRequest
     */
    token?: string;
}

/**
 * @export
 * @namespace TaskCreateRequest
 */
export namespace TaskCreateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface TaskLinks
 */
export interface TaskLinks {
    /**
     * URI of resource.
     * @type {string}
     * @memberof TaskLinks
     */
    self?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof TaskLinks
     */
    owners?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof TaskLinks
     */
    members?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof TaskLinks
     */
    runs?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof TaskLinks
     */
    logs?: string;
    /**
     * URI of resource.
     * @type {string}
     * @memberof TaskLinks
     */
    labels?: string;
}

/**
 * 
 * @export
 * @interface TaskUpdateRequest
 */
export interface TaskUpdateRequest {
    /**
     * Starting state of the task. 'inactive' tasks are not run until they are updated to 'active'
     * @type {string}
     * @memberof TaskUpdateRequest
     */
    status?: TaskUpdateRequest.StatusEnum;
    /**
     * The Flux script to run for this task.
     * @type {string}
     * @memberof TaskUpdateRequest
     */
    flux?: string;
    /**
     * Override the 'name' option in the flux script.
     * @type {string}
     * @memberof TaskUpdateRequest
     */
    name?: string;
    /**
     * Override the 'every' option in the flux script.
     * @type {string}
     * @memberof TaskUpdateRequest
     */
    every?: string;
    /**
     * Override the 'cron' option in the flux script.
     * @type {string}
     * @memberof TaskUpdateRequest
     */
    cron?: string;
    /**
     * Override the 'offset' option in the flux script.
     * @type {string}
     * @memberof TaskUpdateRequest
     */
    offset?: string;
    /**
     * Override the existing token associated with the task.
     * @type {string}
     * @memberof TaskUpdateRequest
     */
    token?: string;
}

/**
 * @export
 * @namespace TaskUpdateRequest
 */
export namespace TaskUpdateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface Tasks
 */
export interface Tasks {
    /**
     * 
     * @type {Links}
     * @memberof Tasks
     */
    links?: Links;
    /**
     * 
     * @type {Array<Task>}
     * @memberof Tasks
     */
    tasks?: Array<Task>;
}

/**
 * 
 * @export
 * @interface Telegraf
 */
export interface Telegraf extends TelegrafRequest {
    /**
     * 
     * @type {string}
     * @memberof Telegraf
     */
    id?: string;
    /**
     * 
     * @type {any}
     * @memberof Telegraf
     */
    links?: any;
    /**
     * 
     * @type {Array<Label>}
     * @memberof Telegraf
     */
    labels?: Array<Label>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputCpu
 */
export interface TelegrafPluginInputCpu {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputCpu
     */
    name: TelegrafPluginInputCpu.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputCpu
     */
    type: TelegrafPluginInputCpu.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputCpu
     */
    comment?: string;
}

/**
 * @export
 * @namespace TelegrafPluginInputCpu
 */
export namespace TelegrafPluginInputCpu {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Cpu = 'cpu'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputDisk
 */
export interface TelegrafPluginInputDisk {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDisk
     */
    name: TelegrafPluginInputDisk.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDisk
     */
    type: TelegrafPluginInputDisk.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDisk
     */
    comment?: string;
}

/**
 * @export
 * @namespace TelegrafPluginInputDisk
 */
export namespace TelegrafPluginInputDisk {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Disk = 'disk'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputDiskio
 */
export interface TelegrafPluginInputDiskio {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDiskio
     */
    name: TelegrafPluginInputDiskio.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDiskio
     */
    type: TelegrafPluginInputDiskio.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDiskio
     */
    comment?: string;
}

/**
 * @export
 * @namespace TelegrafPluginInputDiskio
 */
export namespace TelegrafPluginInputDiskio {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Diskio = 'diskio'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputDocker
 */
export interface TelegrafPluginInputDocker {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDocker
     */
    name: TelegrafPluginInputDocker.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDocker
     */
    type: TelegrafPluginInputDocker.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDocker
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputDockerConfig}
     * @memberof TelegrafPluginInputDocker
     */
    config: TelegrafPluginInputDockerConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputDocker
 */
export namespace TelegrafPluginInputDocker {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Docker = 'docker'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputDockerConfig
 */
export interface TelegrafPluginInputDockerConfig {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputDockerConfig
     */
    endpoint: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputFile
 */
export interface TelegrafPluginInputFile {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputFile
     */
    name: TelegrafPluginInputFile.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputFile
     */
    type: TelegrafPluginInputFile.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputFile
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputFileConfig}
     * @memberof TelegrafPluginInputFile
     */
    config: TelegrafPluginInputFileConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputFile
 */
export namespace TelegrafPluginInputFile {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        File = 'file'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputFileConfig
 */
export interface TelegrafPluginInputFileConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginInputFileConfig
     */
    files?: Array<string>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputKernel
 */
export interface TelegrafPluginInputKernel {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKernel
     */
    name: TelegrafPluginInputKernel.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKernel
     */
    type: TelegrafPluginInputKernel.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKernel
     */
    comment?: string;
}

/**
 * @export
 * @namespace TelegrafPluginInputKernel
 */
export namespace TelegrafPluginInputKernel {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Kernel = 'kernel'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputKubernetes
 */
export interface TelegrafPluginInputKubernetes {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKubernetes
     */
    name: TelegrafPluginInputKubernetes.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKubernetes
     */
    type: TelegrafPluginInputKubernetes.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKubernetes
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputKubernetesConfig}
     * @memberof TelegrafPluginInputKubernetes
     */
    config: TelegrafPluginInputKubernetesConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputKubernetes
 */
export namespace TelegrafPluginInputKubernetes {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Kubernetes = 'kubernetes'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputKubernetesConfig
 */
export interface TelegrafPluginInputKubernetesConfig {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputKubernetesConfig
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputLogParser
 */
export interface TelegrafPluginInputLogParser {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputLogParser
     */
    name: TelegrafPluginInputLogParser.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputLogParser
     */
    type: TelegrafPluginInputLogParser.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputLogParser
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputLogParserConfig}
     * @memberof TelegrafPluginInputLogParser
     */
    config: TelegrafPluginInputLogParserConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputLogParser
 */
export namespace TelegrafPluginInputLogParser {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Logparser = 'logparser'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputLogParserConfig
 */
export interface TelegrafPluginInputLogParserConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginInputLogParserConfig
     */
    files?: Array<string>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputMem
 */
export interface TelegrafPluginInputMem {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputMem
     */
    name: TelegrafPluginInputMem.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputMem
     */
    type: TelegrafPluginInputMem.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputMem
     */
    comment?: string;
}

/**
 * @export
 * @namespace TelegrafPluginInputMem
 */
export namespace TelegrafPluginInputMem {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Mem = 'mem'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputNet
 */
export interface TelegrafPluginInputNet {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNet
     */
    name: TelegrafPluginInputNet.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNet
     */
    type: TelegrafPluginInputNet.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNet
     */
    comment?: string;
}

/**
 * @export
 * @namespace TelegrafPluginInputNet
 */
export namespace TelegrafPluginInputNet {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Net = 'net'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputNetResponse
 */
export interface TelegrafPluginInputNetResponse {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNetResponse
     */
    name: TelegrafPluginInputNetResponse.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNetResponse
     */
    type: TelegrafPluginInputNetResponse.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNetResponse
     */
    comment?: string;
}

/**
 * @export
 * @namespace TelegrafPluginInputNetResponse
 */
export namespace TelegrafPluginInputNetResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        NetResponse = 'net_response'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputNginx
 */
export interface TelegrafPluginInputNginx {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNginx
     */
    name: TelegrafPluginInputNginx.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNginx
     */
    type: TelegrafPluginInputNginx.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputNginx
     */
    comment?: string;
}

/**
 * @export
 * @namespace TelegrafPluginInputNginx
 */
export namespace TelegrafPluginInputNginx {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Nginx = 'nginx'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputProcesses
 */
export interface TelegrafPluginInputProcesses {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcesses
     */
    name: TelegrafPluginInputProcesses.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcesses
     */
    type: TelegrafPluginInputProcesses.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcesses
     */
    comment?: string;
}

/**
 * @export
 * @namespace TelegrafPluginInputProcesses
 */
export namespace TelegrafPluginInputProcesses {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Processes = 'processes'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputProcstat
 */
export interface TelegrafPluginInputProcstat {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcstat
     */
    name: TelegrafPluginInputProcstat.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcstat
     */
    type: TelegrafPluginInputProcstat.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcstat
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputProcstatConfig}
     * @memberof TelegrafPluginInputProcstat
     */
    config: TelegrafPluginInputProcstatConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputProcstat
 */
export namespace TelegrafPluginInputProcstat {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Procstat = 'procstat'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputProcstatConfig
 */
export interface TelegrafPluginInputProcstatConfig {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputProcstatConfig
     */
    exe?: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputPrometheus
 */
export interface TelegrafPluginInputPrometheus {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputPrometheus
     */
    name: TelegrafPluginInputPrometheus.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputPrometheus
     */
    type: TelegrafPluginInputPrometheus.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputPrometheus
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputPrometheusConfig}
     * @memberof TelegrafPluginInputPrometheus
     */
    config: TelegrafPluginInputPrometheusConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputPrometheus
 */
export namespace TelegrafPluginInputPrometheus {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Prometheus = 'prometheus'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputPrometheusConfig
 */
export interface TelegrafPluginInputPrometheusConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginInputPrometheusConfig
     */
    urls?: Array<string>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputRedis
 */
export interface TelegrafPluginInputRedis {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputRedis
     */
    name: TelegrafPluginInputRedis.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputRedis
     */
    type: TelegrafPluginInputRedis.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputRedis
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputRedisConfig}
     * @memberof TelegrafPluginInputRedis
     */
    config: TelegrafPluginInputRedisConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputRedis
 */
export namespace TelegrafPluginInputRedis {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Redis = 'redis'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputRedisConfig
 */
export interface TelegrafPluginInputRedisConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginInputRedisConfig
     */
    servers?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputRedisConfig
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputSwap
 */
export interface TelegrafPluginInputSwap {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSwap
     */
    name: TelegrafPluginInputSwap.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSwap
     */
    type: TelegrafPluginInputSwap.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSwap
     */
    comment?: string;
}

/**
 * @export
 * @namespace TelegrafPluginInputSwap
 */
export namespace TelegrafPluginInputSwap {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Swap = 'swap'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputSyslog
 */
export interface TelegrafPluginInputSyslog {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSyslog
     */
    name: TelegrafPluginInputSyslog.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSyslog
     */
    type: TelegrafPluginInputSyslog.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSyslog
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginInputSyslogConfig}
     * @memberof TelegrafPluginInputSyslog
     */
    config: TelegrafPluginInputSyslogConfig;
}

/**
 * @export
 * @namespace TelegrafPluginInputSyslog
 */
export namespace TelegrafPluginInputSyslog {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Syslog = 'syslog'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputSyslogConfig
 */
export interface TelegrafPluginInputSyslogConfig {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSyslogConfig
     */
    server?: string;
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputSystem
 */
export interface TelegrafPluginInputSystem {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSystem
     */
    name: TelegrafPluginInputSystem.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSystem
     */
    type: TelegrafPluginInputSystem.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputSystem
     */
    comment?: string;
}

/**
 * @export
 * @namespace TelegrafPluginInputSystem
 */
export namespace TelegrafPluginInputSystem {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        System = 'system'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginInputTail
 */
export interface TelegrafPluginInputTail {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputTail
     */
    name: TelegrafPluginInputTail.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputTail
     */
    type: TelegrafPluginInputTail.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginInputTail
     */
    comment?: string;
}

/**
 * @export
 * @namespace TelegrafPluginInputTail
 */
export namespace TelegrafPluginInputTail {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        Tail = 'tail'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Input = 'input'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputFile
 */
export interface TelegrafPluginOutputFile {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputFile
     */
    name: TelegrafPluginOutputFile.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputFile
     */
    type: TelegrafPluginOutputFile.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputFile
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginOutputFileConfig}
     * @memberof TelegrafPluginOutputFile
     */
    config: TelegrafPluginOutputFileConfig;
}

/**
 * @export
 * @namespace TelegrafPluginOutputFile
 */
export namespace TelegrafPluginOutputFile {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        File = 'file'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Output = 'output'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputFileConfig
 */
export interface TelegrafPluginOutputFileConfig {
    /**
     * 
     * @type {Array<TelegrafPluginOutputFileConfigFiles>}
     * @memberof TelegrafPluginOutputFileConfig
     */
    files: Array<TelegrafPluginOutputFileConfigFiles>;
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputFileConfigFiles
 */
export interface TelegrafPluginOutputFileConfigFiles {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputFileConfigFiles
     */
    type?: TelegrafPluginOutputFileConfigFiles.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputFileConfigFiles
     */
    path?: string;
}

/**
 * @export
 * @namespace TelegrafPluginOutputFileConfigFiles
 */
export namespace TelegrafPluginOutputFileConfigFiles {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Stdout = 'stdout',
        Path = 'path'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputInfluxDBV2
 */
export interface TelegrafPluginOutputInfluxDBV2 {
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2
     */
    name: TelegrafPluginOutputInfluxDBV2.NameEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2
     */
    type: TelegrafPluginOutputInfluxDBV2.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2
     */
    comment?: string;
    /**
     * 
     * @type {TelegrafPluginOutputInfluxDBV2Config}
     * @memberof TelegrafPluginOutputInfluxDBV2
     */
    config: TelegrafPluginOutputInfluxDBV2Config;
}

/**
 * @export
 * @namespace TelegrafPluginOutputInfluxDBV2
 */
export namespace TelegrafPluginOutputInfluxDBV2 {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        InfluxdbV2 = 'influxdb_v2'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Output = 'output'
    }
}

/**
 * 
 * @export
 * @interface TelegrafPluginOutputInfluxDBV2Config
 */
export interface TelegrafPluginOutputInfluxDBV2Config {
    /**
     * 
     * @type {Array<string>}
     * @memberof TelegrafPluginOutputInfluxDBV2Config
     */
    urls: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2Config
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2Config
     */
    organization: string;
    /**
     * 
     * @type {string}
     * @memberof TelegrafPluginOutputInfluxDBV2Config
     */
    bucket: string;
}

/**
 * 
 * @export
 * @interface TelegrafRequest
 */
export interface TelegrafRequest {
    /**
     * 
     * @type {string}
     * @memberof TelegrafRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TelegrafRequest
     */
    description?: string;
    /**
     * 
     * @type {TelegrafRequestAgent}
     * @memberof TelegrafRequest
     */
    agent?: TelegrafRequestAgent;
    /**
     * 
     * @type {Array<TelegrafRequestPlugin>}
     * @memberof TelegrafRequest
     */
    plugins?: Array<TelegrafRequestPlugin>;
    /**
     * 
     * @type {string}
     * @memberof TelegrafRequest
     */
    orgID?: string;
}

/**
 * 
 * @export
 * @interface TelegrafRequestAgent
 */
export interface TelegrafRequestAgent {
    /**
     * 
     * @type {number}
     * @memberof TelegrafRequestAgent
     */
    collectionInterval?: number;
}

/**
 * 
 * @export
 * @interface TelegrafRequestPlugin
 */
export interface TelegrafRequestPlugin {
}

/**
 * @export
 * @namespace TelegrafRequestPlugin
 */
export namespace TelegrafRequestPlugin {
}

/**
 * 
 * @export
 * @interface Telegrafs
 */
export interface Telegrafs {
    /**
     * 
     * @type {Array<Telegraf>}
     * @memberof Telegrafs
     */
    configurations?: Array<Telegraf>;
}

/**
 * declares a Flux test case
 * @export
 * @interface TestStatement
 */
export interface TestStatement {
    /**
     * type of AST node
     * @type {string}
     * @memberof TestStatement
     */
    type?: string;
    /**
     * 
     * @type {VariableAssignment}
     * @memberof TestStatement
     */
    assignment?: VariableAssignment;
}

/**
 * uses operators to act on a single operand in an expression
 * @export
 * @interface UnaryExpression
 */
export interface UnaryExpression {
    /**
     * type of AST node
     * @type {string}
     * @memberof UnaryExpression
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof UnaryExpression
     */
    operator?: string;
    /**
     * 
     * @type {Expression}
     * @memberof UnaryExpression
     */
    argument?: Expression;
}

/**
 * represents integer numbers
 * @export
 * @interface UnsignedIntegerLiteral
 */
export interface UnsignedIntegerLiteral {
    /**
     * type of AST node
     * @type {string}
     * @memberof UnsignedIntegerLiteral
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof UnsignedIntegerLiteral
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * if inactive the user is inactive.
     * @type {string}
     * @memberof User
     */
    status?: User.StatusEnum;
    /**
     * 
     * @type {UserLinks}
     * @memberof User
     */
    links?: UserLinks;
}

/**
 * @export
 * @namespace User
 */
export namespace User {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = 'active',
        Inactive = 'inactive'
    }
}

/**
 * 
 * @export
 * @interface UserLinks
 */
export interface UserLinks {
    /**
     * 
     * @type {string}
     * @memberof UserLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLinks
     */
    logs?: string;
}

/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * 
     * @type {UsersLinks}
     * @memberof Users
     */
    links?: UsersLinks;
    /**
     * 
     * @type {Array<User>}
     * @memberof Users
     */
    users?: Array<User>;
}

/**
 * 
 * @export
 * @interface UsersLinks
 */
export interface UsersLinks {
    /**
     * 
     * @type {string}
     * @memberof UsersLinks
     */
    self?: string;
}

/**
 * 
 * @export
 * @interface Variable
 */
export interface Variable {
    /**
     * 
     * @type {VariableLinks}
     * @memberof Variable
     */
    links?: VariableLinks;
    /**
     * 
     * @type {string}
     * @memberof Variable
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Variable
     */
    orgID: string;
    /**
     * 
     * @type {string}
     * @memberof Variable
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Variable
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Variable
     */
    selected?: Array<string>;
    /**
     * 
     * @type {Array<Label>}
     * @memberof Variable
     */
    labels?: Array<Label>;
    /**
     * 
     * @type {any}
     * @memberof Variable
     */
    arguments: any;
}

/**
 * represents the declaration of a variable
 * @export
 * @interface VariableAssignment
 */
export interface VariableAssignment {
    /**
     * type of AST node
     * @type {string}
     * @memberof VariableAssignment
     */
    type?: string;
    /**
     * 
     * @type {Identifier}
     * @memberof VariableAssignment
     */
    id?: Identifier;
    /**
     * 
     * @type {Expression}
     * @memberof VariableAssignment
     */
    init?: Expression;
}

/**
 * 
 * @export
 * @interface VariableLinks
 */
export interface VariableLinks {
    /**
     * 
     * @type {string}
     * @memberof VariableLinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableLinks
     */
    org?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableLinks
     */
    labels?: string;
}

/**
 * 
 * @export
 * @interface Variables
 */
export interface Variables {
    /**
     * 
     * @type {Array<Variable>}
     * @memberof Variables
     */
    variables?: Array<Variable>;
}

/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {ViewLinks}
     * @memberof View
     */
    links?: ViewLinks;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof View
     */
    properties?: any;
}

/**
 * 
 * @export
 * @interface ViewLinks
 */
export interface ViewLinks {
    /**
     * 
     * @type {string}
     * @memberof ViewLinks
     */
    self?: string;
}

/**
 * 
 * @export
 * @interface ViewProperties
 */
export interface ViewProperties {
    /**
     * 
     * @type {Array<DashboardQuery>}
     * @memberof ViewProperties
     */
    queries?: Array<DashboardQuery>;
    /**
     * Colors define color encoding of data into a visualization
     * @type {Array<DashboardColor>}
     * @memberof ViewProperties
     */
    colors?: Array<DashboardColor>;
    /**
     * 
     * @type {string}
     * @memberof ViewProperties
     */
    note?: string;
    /**
     * if true, will display note when empty
     * @type {boolean}
     * @memberof ViewProperties
     */
    showNoteWhenEmpty?: boolean;
}

/**
 * 
 * @export
 * @interface Views
 */
export interface Views {
    /**
     * 
     * @type {ViewLinks}
     * @memberof Views
     */
    links?: ViewLinks;
    /**
     * 
     * @type {Array<View>}
     * @memberof Views
     */
    views?: Array<View>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum WritePrecision {
    Ms = 'ms',
    S = 's',
    Us = 'us',
    Ns = 'ns'
}

/**
 * 
 * @export
 * @interface XYViewProperties
 */
export interface XYViewProperties extends ViewProperties {
    /**
     * 
     * @type {Axes}
     * @memberof XYViewProperties
     */
    axes?: Axes;
    /**
     * 
     * @type {string}
     * @memberof XYViewProperties
     */
    type?: XYViewProperties.TypeEnum;
    /**
     * 
     * @type {Legend}
     * @memberof XYViewProperties
     */
    legend?: Legend;
    /**
     * 
     * @type {string}
     * @memberof XYViewProperties
     */
    geom?: XYViewProperties.GeomEnum;
}

/**
 * @export
 * @namespace XYViewProperties
 */
export namespace XYViewProperties {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Xy = 'xy'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GeomEnum {
        Line = 'line',
        Step = 'step',
        Stacked = 'stacked',
        Bar = 'bar'
    }
}


/**
 * AuthorizationsApi - axios parameter creator
 * @export
 */
export const AuthorizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a authorization
         * @param {string} authID ID of authorization to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthorizationsID(authID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authID' is not null or undefined
            if (authID === null || authID === undefined) {
                throw new RequiredError('authID','Required parameter authID was null or undefined when calling deleteAuthorizationsID.');
            }
            const localVarPath = `/authorizations/{authID}`
                .replace(`{${"authID"}}`, encodeURIComponent(String(authID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all authorizations
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [userID] filter authorizations belonging to a user id
         * @param {string} [user] filter authorizations belonging to a user name
         * @param {string} [orgID] filter authorizations belonging to a org id
         * @param {string} [org] filter authorizations belonging to a org name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizations(zapTraceSpan?: string, userID?: string, user?: string, orgID?: string, org?: string, options: any = {}): RequestArgs {
            const localVarPath = `/authorizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userID !== undefined) {
                localVarQueryParameter['userID'] = userID;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (orgID !== undefined) {
                localVarQueryParameter['orgID'] = orgID;
            }

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an authorization
         * @param {string} authID ID of authorization to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizationsID(authID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authID' is not null or undefined
            if (authID === null || authID === undefined) {
                throw new RequiredError('authID','Required parameter authID was null or undefined when calling getAuthorizationsID.');
            }
            const localVarPath = `/authorizations/{authID}`
                .replace(`{${"authID"}}`, encodeURIComponent(String(authID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update authorization to be active or inactive. requests using an inactive authorization will be rejected.
         * @param {string} authID ID of authorization to update
         * @param {AuthorizationUpdateRequest} authorizationUpdateRequest authorization to update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthorizationsID(authID: string, authorizationUpdateRequest: AuthorizationUpdateRequest, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authID' is not null or undefined
            if (authID === null || authID === undefined) {
                throw new RequiredError('authID','Required parameter authID was null or undefined when calling patchAuthorizationsID.');
            }
            // verify required parameter 'authorizationUpdateRequest' is not null or undefined
            if (authorizationUpdateRequest === null || authorizationUpdateRequest === undefined) {
                throw new RequiredError('authorizationUpdateRequest','Required parameter authorizationUpdateRequest was null or undefined when calling patchAuthorizationsID.');
            }
            const localVarPath = `/authorizations/{authID}`
                .replace(`{${"authID"}}`, encodeURIComponent(String(authID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthorizationUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authorizationUpdateRequest || {}) : (authorizationUpdateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an authorization
         * @param {Authorization} authorization authorization to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthorizations(authorization: Authorization, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling postAuthorizations.');
            }
            const localVarPath = `/authorizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Authorization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authorization || {}) : (authorization || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationsApi - functional programming interface
 * @export
 */
export const AuthorizationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a authorization
         * @param {string} authID ID of authorization to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthorizationsID(authID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).deleteAuthorizationsID(authID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all authorizations
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [userID] filter authorizations belonging to a user id
         * @param {string} [user] filter authorizations belonging to a user name
         * @param {string} [orgID] filter authorizations belonging to a org id
         * @param {string} [org] filter authorizations belonging to a org name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizations(zapTraceSpan?: string, userID?: string, user?: string, orgID?: string, org?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorizations> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).getAuthorizations(zapTraceSpan, userID, user, orgID, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve an authorization
         * @param {string} authID ID of authorization to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizationsID(authID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).getAuthorizationsID(authID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary update authorization to be active or inactive. requests using an inactive authorization will be rejected.
         * @param {string} authID ID of authorization to update
         * @param {AuthorizationUpdateRequest} authorizationUpdateRequest authorization to update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthorizationsID(authID: string, authorizationUpdateRequest: AuthorizationUpdateRequest, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).patchAuthorizationsID(authID, authorizationUpdateRequest, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create an authorization
         * @param {Authorization} authorization authorization to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthorizations(authorization: Authorization, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = AuthorizationsApiAxiosParamCreator(configuration).postAuthorizations(authorization, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * AuthorizationsApi - factory interface
 * @export
 */
export const AuthorizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a authorization
         * @param {string} authID ID of authorization to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthorizationsID(authID: string, zapTraceSpan?: string, options?: any) {
            return AuthorizationsApiFp(configuration).deleteAuthorizationsID(authID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all authorizations
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [userID] filter authorizations belonging to a user id
         * @param {string} [user] filter authorizations belonging to a user name
         * @param {string} [orgID] filter authorizations belonging to a org id
         * @param {string} [org] filter authorizations belonging to a org name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizations(zapTraceSpan?: string, userID?: string, user?: string, orgID?: string, org?: string, options?: any) {
            return AuthorizationsApiFp(configuration).getAuthorizations(zapTraceSpan, userID, user, orgID, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve an authorization
         * @param {string} authID ID of authorization to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizationsID(authID: string, zapTraceSpan?: string, options?: any) {
            return AuthorizationsApiFp(configuration).getAuthorizationsID(authID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary update authorization to be active or inactive. requests using an inactive authorization will be rejected.
         * @param {string} authID ID of authorization to update
         * @param {AuthorizationUpdateRequest} authorizationUpdateRequest authorization to update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthorizationsID(authID: string, authorizationUpdateRequest: AuthorizationUpdateRequest, zapTraceSpan?: string, options?: any) {
            return AuthorizationsApiFp(configuration).patchAuthorizationsID(authID, authorizationUpdateRequest, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create an authorization
         * @param {Authorization} authorization authorization to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthorizations(authorization: Authorization, zapTraceSpan?: string, options?: any) {
            return AuthorizationsApiFp(configuration).postAuthorizations(authorization, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * AuthorizationsApi - object-oriented interface
 * @export
 * @class AuthorizationsApi
 * @extends {BaseAPI}
 */
export class AuthorizationsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a authorization
     * @param {string} authID ID of authorization to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public deleteAuthorizationsID(authID: string, zapTraceSpan?: string, options?: any) {
        return AuthorizationsApiFp(this.configuration).deleteAuthorizationsID(authID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all authorizations
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [userID] filter authorizations belonging to a user id
     * @param {string} [user] filter authorizations belonging to a user name
     * @param {string} [orgID] filter authorizations belonging to a org id
     * @param {string} [org] filter authorizations belonging to a org name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public getAuthorizations(zapTraceSpan?: string, userID?: string, user?: string, orgID?: string, org?: string, options?: any) {
        return AuthorizationsApiFp(this.configuration).getAuthorizations(zapTraceSpan, userID, user, orgID, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve an authorization
     * @param {string} authID ID of authorization to get
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public getAuthorizationsID(authID: string, zapTraceSpan?: string, options?: any) {
        return AuthorizationsApiFp(this.configuration).getAuthorizationsID(authID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary update authorization to be active or inactive. requests using an inactive authorization will be rejected.
     * @param {string} authID ID of authorization to update
     * @param {AuthorizationUpdateRequest} authorizationUpdateRequest authorization to update to apply
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public patchAuthorizationsID(authID: string, authorizationUpdateRequest: AuthorizationUpdateRequest, zapTraceSpan?: string, options?: any) {
        return AuthorizationsApiFp(this.configuration).patchAuthorizationsID(authID, authorizationUpdateRequest, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create an authorization
     * @param {Authorization} authorization authorization to create
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationsApi
     */
    public postAuthorizations(authorization: Authorization, zapTraceSpan?: string, options?: any) {
        return AuthorizationsApiFp(this.configuration).postAuthorizations(authorization, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * BucketsApi - axios parameter creator
 * @export
 */
export const BucketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a bucket
         * @param {string} bucketID ID of bucket to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsID(bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling deleteBucketsID.');
            }
            const localVarPath = `/buckets/{bucketID}`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} labelID the label id to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDLabelsID(bucketID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling deleteBucketsIDLabelsID.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling deleteBucketsIDLabelsID.');
            }
            const localVarPath = `/buckets/{bucketID}/labels/{labelID}`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDMembersID(userID: string, bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteBucketsIDMembersID.');
            }
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling deleteBucketsIDMembersID.');
            }
            const localVarPath = `/buckets/{bucketID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDOwnersID(userID: string, bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteBucketsIDOwnersID.');
            }
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling deleteBucketsIDOwnersID.');
            }
            const localVarPath = `/buckets/{bucketID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all buckets
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [org] specifies the organization name of the resource
         * @param {string} [orgID] specifies the organization id of the resource
         * @param {string} [name] only returns buckets with the specified name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuckets(zapTraceSpan?: string, offset?: number, limit?: number, org?: string, orgID?: string, name?: string, options: any = {}): RequestArgs {
            const localVarPath = `/buckets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (orgID !== undefined) {
                localVarQueryParameter['orgID'] = orgID;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a bucket
         * @param {string} bucketID ID of bucket to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsID(bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling getBucketsID.');
            }
            const localVarPath = `/buckets/{bucketID}`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDLabels(bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling getBucketsIDLabels.');
            }
            const localVarPath = `/buckets/{bucketID}/labels`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDLogs(bucketID: string, zapTraceSpan?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling getBucketsIDLogs.');
            }
            const localVarPath = `/buckets/{bucketID}/logs`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDMembers(bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling getBucketsIDMembers.');
            }
            const localVarPath = `/buckets/{bucketID}/members`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDOwners(bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling getBucketsIDOwners.');
            }
            const localVarPath = `/buckets/{bucketID}/owners`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesIDBuckets(sourceID: string, zapTraceSpan?: string, org?: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling getSourcesIDBuckets.');
            }
            const localVarPath = `/sources/{sourceID}/buckets`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a bucket
         * @param {string} bucketID ID of bucket to update
         * @param {Bucket} bucket bucket update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBucketsID(bucketID: string, bucket: Bucket, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling patchBucketsID.');
            }
            // verify required parameter 'bucket' is not null or undefined
            if (bucket === null || bucket === undefined) {
                throw new RequiredError('bucket','Required parameter bucket was null or undefined when calling patchBucketsID.');
            }
            const localVarPath = `/buckets/{bucketID}`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Bucket" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bucket || {}) : (bucket || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a bucket
         * @param {Bucket} bucket bucket to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBuckets(bucket: Bucket, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucket' is not null or undefined
            if (bucket === null || bucket === undefined) {
                throw new RequiredError('bucket','Required parameter bucket was null or undefined when calling postBuckets.');
            }
            const localVarPath = `/buckets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Bucket" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bucket || {}) : (bucket || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a bucket
         * @param {string} bucketID ID of the bucket
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDLabels(bucketID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling postBucketsIDLabels.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling postBucketsIDLabels.');
            }
            const localVarPath = `/buckets/{bucketID}/labels`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDMembers(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling postBucketsIDMembers.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postBucketsIDMembers.');
            }
            const localVarPath = `/buckets/{bucketID}/members`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDOwners(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling postBucketsIDOwners.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postBucketsIDOwners.');
            }
            const localVarPath = `/buckets/{bucketID}/owners`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BucketsApi - functional programming interface
 * @export
 */
export const BucketsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a bucket
         * @param {string} bucketID ID of bucket to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsID(bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).deleteBucketsID(bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} labelID the label id to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDLabelsID(bucketID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).deleteBucketsIDLabelsID(bucketID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDMembersID(userID: string, bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).deleteBucketsIDMembersID(userID, bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDOwnersID(userID: string, bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).deleteBucketsIDOwnersID(userID, bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all buckets
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [org] specifies the organization name of the resource
         * @param {string} [orgID] specifies the organization id of the resource
         * @param {string} [name] only returns buckets with the specified name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuckets(zapTraceSpan?: string, offset?: number, limit?: number, org?: string, orgID?: string, name?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Buckets> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).getBuckets(zapTraceSpan, offset, limit, org, orgID, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve a bucket
         * @param {string} bucketID ID of bucket to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsID(bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).getBucketsID(bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDLabels(bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).getBucketsIDLabels(bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDLogs(bucketID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationLogs> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).getBucketsIDLogs(bucketID, zapTraceSpan, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDMembers(bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMembers> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).getBucketsIDMembers(bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDOwners(bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).getBucketsIDOwners(bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesIDBuckets(sourceID: string, zapTraceSpan?: string, org?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Buckets> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).getSourcesIDBuckets(sourceID, zapTraceSpan, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a bucket
         * @param {string} bucketID ID of bucket to update
         * @param {Bucket} bucket bucket update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBucketsID(bucketID: string, bucket: Bucket, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).patchBucketsID(bucketID, bucket, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a bucket
         * @param {Bucket} bucket bucket to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBuckets(bucket: Bucket, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).postBuckets(bucket, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a bucket
         * @param {string} bucketID ID of the bucket
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDLabels(bucketID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).postBucketsIDLabels(bucketID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDMembers(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMember> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).postBucketsIDMembers(bucketID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDOwners(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwner> {
            const localVarAxiosArgs = BucketsApiAxiosParamCreator(configuration).postBucketsIDOwners(bucketID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * BucketsApi - factory interface
 * @export
 */
export const BucketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a bucket
         * @param {string} bucketID ID of bucket to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsID(bucketID: string, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).deleteBucketsID(bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} labelID the label id to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDLabelsID(bucketID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).deleteBucketsIDLabelsID(bucketID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDMembersID(userID: string, bucketID: string, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).deleteBucketsIDMembersID(userID, bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDOwnersID(userID: string, bucketID: string, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).deleteBucketsIDOwnersID(userID, bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all buckets
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [org] specifies the organization name of the resource
         * @param {string} [orgID] specifies the organization id of the resource
         * @param {string} [name] only returns buckets with the specified name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuckets(zapTraceSpan?: string, offset?: number, limit?: number, org?: string, orgID?: string, name?: string, options?: any) {
            return BucketsApiFp(configuration).getBuckets(zapTraceSpan, offset, limit, org, orgID, name, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve a bucket
         * @param {string} bucketID ID of bucket to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsID(bucketID: string, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).getBucketsID(bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDLabels(bucketID: string, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).getBucketsIDLabels(bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve operation logs for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDLogs(bucketID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
            return BucketsApiFp(configuration).getBucketsIDLogs(bucketID, zapTraceSpan, offset, limit, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDMembers(bucketID: string, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).getBucketsIDMembers(bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDOwners(bucketID: string, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).getBucketsIDOwners(bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesIDBuckets(sourceID: string, zapTraceSpan?: string, org?: string, options?: any) {
            return BucketsApiFp(configuration).getSourcesIDBuckets(sourceID, zapTraceSpan, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a bucket
         * @param {string} bucketID ID of bucket to update
         * @param {Bucket} bucket bucket update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBucketsID(bucketID: string, bucket: Bucket, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).patchBucketsID(bucketID, bucket, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a bucket
         * @param {Bucket} bucket bucket to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBuckets(bucket: Bucket, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).postBuckets(bucket, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a bucket
         * @param {string} bucketID ID of the bucket
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDLabels(bucketID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).postBucketsIDLabels(bucketID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDMembers(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).postBucketsIDMembers(bucketID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDOwners(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return BucketsApiFp(configuration).postBucketsIDOwners(bucketID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * BucketsApi - object-oriented interface
 * @export
 * @class BucketsApi
 * @extends {BaseAPI}
 */
export class BucketsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a bucket
     * @param {string} bucketID ID of bucket to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public deleteBucketsID(bucketID: string, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).deleteBucketsID(bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a bucket
     * @param {string} bucketID ID of the bucket
     * @param {string} labelID the label id to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public deleteBucketsIDLabelsID(bucketID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).deleteBucketsIDLabelsID(bucketID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an bucket
     * @param {string} userID ID of member to remove
     * @param {string} bucketID ID of the bucket
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public deleteBucketsIDMembersID(userID: string, bucketID: string, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).deleteBucketsIDMembersID(userID, bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a bucket
     * @param {string} userID ID of owner to remove
     * @param {string} bucketID ID of the bucket
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public deleteBucketsIDOwnersID(userID: string, bucketID: string, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).deleteBucketsIDOwnersID(userID, bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all buckets
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [org] specifies the organization name of the resource
     * @param {string} [orgID] specifies the organization id of the resource
     * @param {string} [name] only returns buckets with the specified name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public getBuckets(zapTraceSpan?: string, offset?: number, limit?: number, org?: string, orgID?: string, name?: string, options?: any) {
        return BucketsApiFp(this.configuration).getBuckets(zapTraceSpan, offset, limit, org, orgID, name, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve a bucket
     * @param {string} bucketID ID of bucket to get
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public getBucketsID(bucketID: string, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).getBucketsID(bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a bucket
     * @param {string} bucketID ID of the bucket
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public getBucketsIDLabels(bucketID: string, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).getBucketsIDLabels(bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve operation logs for a bucket
     * @param {string} bucketID ID of the bucket
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public getBucketsIDLogs(bucketID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
        return BucketsApiFp(this.configuration).getBucketsIDLogs(bucketID, zapTraceSpan, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users with member privileges for a bucket
     * @param {string} bucketID ID of the bucket
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public getBucketsIDMembers(bucketID: string, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).getBucketsIDMembers(bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a bucket
     * @param {string} bucketID ID of the bucket
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public getBucketsIDOwners(bucketID: string, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).getBucketsIDOwners(bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
     * @param {string} sourceID ID of the source
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [org] specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public getSourcesIDBuckets(sourceID: string, zapTraceSpan?: string, org?: string, options?: any) {
        return BucketsApiFp(this.configuration).getSourcesIDBuckets(sourceID, zapTraceSpan, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a bucket
     * @param {string} bucketID ID of bucket to update
     * @param {Bucket} bucket bucket update to apply
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public patchBucketsID(bucketID: string, bucket: Bucket, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).patchBucketsID(bucketID, bucket, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a bucket
     * @param {Bucket} bucket bucket to create
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public postBuckets(bucket: Bucket, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).postBuckets(bucket, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a bucket
     * @param {string} bucketID ID of the bucket
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public postBucketsIDLabels(bucketID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).postBucketsIDLabels(bucketID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add bucket member
     * @param {string} bucketID ID of the bucket
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public postBucketsIDMembers(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).postBucketsIDMembers(bucketID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add bucket owner
     * @param {string} bucketID ID of the bucket
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public postBucketsIDOwners(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return BucketsApiFp(this.configuration).postBucketsIDOwners(bucketID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * CellsApi - axios parameter creator
 * @export
 */
export const CellsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDCellsID(dashboardID: string, cellID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling deleteDashboardsIDCellsID.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling deleteDashboardsIDCellsID.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDCellsIDView(dashboardID: string, cellID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling getDashboardsIDCellsIDView.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling getDashboardsIDCellsIDView.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}/view`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsID(dashboardID: string, cellID: string, cellUpdate: CellUpdate, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling patchDashboardsIDCellsID.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling patchDashboardsIDCellsID.');
            }
            // verify required parameter 'cellUpdate' is not null or undefined
            if (cellUpdate === null || cellUpdate === undefined) {
                throw new RequiredError('cellUpdate','Required parameter cellUpdate was null or undefined when calling patchDashboardsIDCellsID.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CellUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cellUpdate || {}) : (cellUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsIDView(dashboardID: string, cellID: string, view: View, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling patchDashboardsIDCellsIDView.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling patchDashboardsIDCellsIDView.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling patchDashboardsIDCellsIDView.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}/view`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"View" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(view || {}) : (view || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDCells(dashboardID: string, createCell: CreateCell, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling postDashboardsIDCells.');
            }
            // verify required parameter 'createCell' is not null or undefined
            if (createCell === null || createCell === undefined) {
                throw new RequiredError('createCell','Required parameter createCell was null or undefined when calling postDashboardsIDCells.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCell" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCell || {}) : (createCell || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDashboardsIDCells(dashboardID: string, cell: Array<Cell>, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling putDashboardsIDCells.');
            }
            // verify required parameter 'cell' is not null or undefined
            if (cell === null || cell === undefined) {
                throw new RequiredError('cell','Required parameter cell was null or undefined when calling putDashboardsIDCells.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Cell&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cell || {}) : (cell || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CellsApi - functional programming interface
 * @export
 */
export const CellsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDCellsID(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).deleteDashboardsIDCellsID(dashboardID, cellID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDCellsIDView(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).getDashboardsIDCellsIDView(dashboardID, cellID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsID(dashboardID: string, cellID: string, cellUpdate: CellUpdate, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).patchDashboardsIDCellsID(dashboardID, cellID, cellUpdate, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsIDView(dashboardID: string, cellID: string, view: View, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).patchDashboardsIDCellsIDView(dashboardID, cellID, view, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDCells(dashboardID: string, createCell: CreateCell, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).postDashboardsIDCells(dashboardID, createCell, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDashboardsIDCells(dashboardID: string, cell: Array<Cell>, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = CellsApiAxiosParamCreator(configuration).putDashboardsIDCells(dashboardID, cell, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * CellsApi - factory interface
 * @export
 */
export const CellsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDCellsID(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any) {
            return CellsApiFp(configuration).deleteDashboardsIDCellsID(dashboardID, cellID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDCellsIDView(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any) {
            return CellsApiFp(configuration).getDashboardsIDCellsIDView(dashboardID, cellID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsID(dashboardID: string, cellID: string, cellUpdate: CellUpdate, zapTraceSpan?: string, options?: any) {
            return CellsApiFp(configuration).patchDashboardsIDCellsID(dashboardID, cellID, cellUpdate, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsIDView(dashboardID: string, cellID: string, view: View, zapTraceSpan?: string, options?: any) {
            return CellsApiFp(configuration).patchDashboardsIDCellsIDView(dashboardID, cellID, view, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDCells(dashboardID: string, createCell: CreateCell, zapTraceSpan?: string, options?: any) {
            return CellsApiFp(configuration).postDashboardsIDCells(dashboardID, createCell, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDashboardsIDCells(dashboardID: string, cell: Array<Cell>, zapTraceSpan?: string, options?: any) {
            return CellsApiFp(configuration).putDashboardsIDCells(dashboardID, cell, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * CellsApi - object-oriented interface
 * @export
 * @class CellsApi
 * @extends {BaseAPI}
 */
export class CellsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a dashboard cell
     * @param {string} dashboardID ID of dashboard to delte
     * @param {string} cellID ID of cell to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public deleteDashboardsIDCellsID(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any) {
        return CellsApiFp(this.configuration).deleteDashboardsIDCellsID(dashboardID, cellID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve the view for a cell in a dashboard
     * @param {string} dashboardID ID of dashboard
     * @param {string} cellID ID of cell
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public getDashboardsIDCellsIDView(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any) {
        return CellsApiFp(this.configuration).getDashboardsIDCellsIDView(dashboardID, cellID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} cellID ID of cell to update
     * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public patchDashboardsIDCellsID(dashboardID: string, cellID: string, cellUpdate: CellUpdate, zapTraceSpan?: string, options?: any) {
        return CellsApiFp(this.configuration).patchDashboardsIDCellsID(dashboardID, cellID, cellUpdate, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the view for a cell
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} cellID ID of cell to update
     * @param {View} view updates the view for a cell
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public patchDashboardsIDCellsIDView(dashboardID: string, cellID: string, view: View, zapTraceSpan?: string, options?: any) {
        return CellsApiFp(this.configuration).patchDashboardsIDCellsIDView(dashboardID, cellID, view, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a dashboard cell
     * @param {string} dashboardID ID of dashboard to update
     * @param {CreateCell} createCell cell that will be added
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public postDashboardsIDCells(dashboardID: string, createCell: CreateCell, zapTraceSpan?: string, options?: any) {
        return CellsApiFp(this.configuration).postDashboardsIDCells(dashboardID, createCell, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Replace a dashboards cells
     * @param {string} dashboardID ID of dashboard to update
     * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public putDashboardsIDCells(dashboardID: string, cell: Array<Cell>, zapTraceSpan?: string, options?: any) {
        return CellsApiFp(this.configuration).putDashboardsIDCells(dashboardID, cell, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * DashboardsApi - axios parameter creator
 * @export
 */
export const DashboardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsID(dashboardID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling deleteDashboardsID.');
            }
            const localVarPath = `/dashboards/{dashboardID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDCellsID(dashboardID: string, cellID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling deleteDashboardsIDCellsID.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling deleteDashboardsIDCellsID.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} labelID the label id to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDLabelsID(dashboardID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling deleteDashboardsIDLabelsID.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling deleteDashboardsIDLabelsID.');
            }
            const localVarPath = `/dashboards/{dashboardID}/labels/{labelID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDMembersID(userID: string, dashboardID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteDashboardsIDMembersID.');
            }
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling deleteDashboardsIDMembersID.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDOwnersID(userID: string, dashboardID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteDashboardsIDOwnersID.');
            }
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling deleteDashboardsIDOwnersID.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all dashboards
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [owner] specifies the owner id to return resources for
         * @param {'ID' | 'CreatedAt' | 'UpdatedAt'} [sortBy] specifies the owner id to return resources for
         * @param {Array<string>} [id] ID list of dashboards to return. If both this and owner are specified, only ids is used.
         * @param {string} [orgID] specifies the organization id of the resource
         * @param {string} [org] specifies the organization name of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboards(zapTraceSpan?: string, owner?: string, sortBy?: 'ID' | 'CreatedAt' | 'UpdatedAt', id?: Array<string>, orgID?: string, org?: string, options: any = {}): RequestArgs {
            const localVarPath = `/dashboards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (orgID !== undefined) {
                localVarQueryParameter['orgID'] = orgID;
            }

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsID(dashboardID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling getDashboardsID.');
            }
            const localVarPath = `/dashboards/{dashboardID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDCellsIDView(dashboardID: string, cellID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling getDashboardsIDCellsIDView.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling getDashboardsIDCellsIDView.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}/view`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDLabels(dashboardID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling getDashboardsIDLabels.');
            }
            const localVarPath = `/dashboards/{dashboardID}/labels`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDLogs(dashboardID: string, zapTraceSpan?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling getDashboardsIDLogs.');
            }
            const localVarPath = `/dashboards/{dashboardID}/logs`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDMembers(dashboardID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling getDashboardsIDMembers.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDOwners(dashboardID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling getDashboardsIDOwners.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {Dashboard} dashboard patching of a dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsID(dashboardID: string, dashboard: Dashboard, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling patchDashboardsID.');
            }
            // verify required parameter 'dashboard' is not null or undefined
            if (dashboard === null || dashboard === undefined) {
                throw new RequiredError('dashboard','Required parameter dashboard was null or undefined when calling patchDashboardsID.');
            }
            const localVarPath = `/dashboards/{dashboardID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(dashboard || {}) : (dashboard || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsID(dashboardID: string, cellID: string, cellUpdate: CellUpdate, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling patchDashboardsIDCellsID.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling patchDashboardsIDCellsID.');
            }
            // verify required parameter 'cellUpdate' is not null or undefined
            if (cellUpdate === null || cellUpdate === undefined) {
                throw new RequiredError('cellUpdate','Required parameter cellUpdate was null or undefined when calling patchDashboardsIDCellsID.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CellUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cellUpdate || {}) : (cellUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsIDView(dashboardID: string, cellID: string, view: View, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling patchDashboardsIDCellsIDView.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling patchDashboardsIDCellsIDView.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling patchDashboardsIDCellsIDView.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}/view`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"View" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(view || {}) : (view || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a dashboard
         * @param {CreateDashboardRequest} createDashboardRequest dashboard to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboards(createDashboardRequest: CreateDashboardRequest, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'createDashboardRequest' is not null or undefined
            if (createDashboardRequest === null || createDashboardRequest === undefined) {
                throw new RequiredError('createDashboardRequest','Required parameter createDashboardRequest was null or undefined when calling postDashboards.');
            }
            const localVarPath = `/dashboards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateDashboardRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createDashboardRequest || {}) : (createDashboardRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDCells(dashboardID: string, createCell: CreateCell, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling postDashboardsIDCells.');
            }
            // verify required parameter 'createCell' is not null or undefined
            if (createCell === null || createCell === undefined) {
                throw new RequiredError('createCell','Required parameter createCell was null or undefined when calling postDashboardsIDCells.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCell" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCell || {}) : (createCell || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDLabels(dashboardID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling postDashboardsIDLabels.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling postDashboardsIDLabels.');
            }
            const localVarPath = `/dashboards/{dashboardID}/labels`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDMembers(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling postDashboardsIDMembers.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postDashboardsIDMembers.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDOwners(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling postDashboardsIDOwners.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postDashboardsIDOwners.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDashboardsIDCells(dashboardID: string, cell: Array<Cell>, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling putDashboardsIDCells.');
            }
            // verify required parameter 'cell' is not null or undefined
            if (cell === null || cell === undefined) {
                throw new RequiredError('cell','Required parameter cell was null or undefined when calling putDashboardsIDCells.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Cell&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cell || {}) : (cell || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsApi - functional programming interface
 * @export
 */
export const DashboardsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsID(dashboardID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).deleteDashboardsID(dashboardID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDCellsID(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).deleteDashboardsIDCellsID(dashboardID, cellID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} labelID the label id to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDLabelsID(dashboardID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).deleteDashboardsIDLabelsID(dashboardID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDMembersID(userID: string, dashboardID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).deleteDashboardsIDMembersID(userID, dashboardID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDOwnersID(userID: string, dashboardID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).deleteDashboardsIDOwnersID(userID, dashboardID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get all dashboards
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [owner] specifies the owner id to return resources for
         * @param {'ID' | 'CreatedAt' | 'UpdatedAt'} [sortBy] specifies the owner id to return resources for
         * @param {Array<string>} [id] ID list of dashboards to return. If both this and owner are specified, only ids is used.
         * @param {string} [orgID] specifies the organization id of the resource
         * @param {string} [org] specifies the organization name of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboards(zapTraceSpan?: string, owner?: string, sortBy?: 'ID' | 'CreatedAt' | 'UpdatedAt', id?: Array<string>, orgID?: string, org?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboards> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).getDashboards(zapTraceSpan, owner, sortBy, id, orgID, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a single Dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsID(dashboardID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).getDashboardsID(dashboardID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDCellsIDView(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).getDashboardsIDCellsIDView(dashboardID, cellID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDLabels(dashboardID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).getDashboardsIDLabels(dashboardID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDLogs(dashboardID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationLogs> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).getDashboardsIDLogs(dashboardID, zapTraceSpan, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDMembers(dashboardID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMembers> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).getDashboardsIDMembers(dashboardID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDOwners(dashboardID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).getDashboardsIDOwners(dashboardID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a single dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {Dashboard} dashboard patching of a dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsID(dashboardID: string, dashboard: Dashboard, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).patchDashboardsID(dashboardID, dashboard, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsID(dashboardID: string, cellID: string, cellUpdate: CellUpdate, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).patchDashboardsIDCellsID(dashboardID, cellID, cellUpdate, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsIDView(dashboardID: string, cellID: string, view: View, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).patchDashboardsIDCellsIDView(dashboardID, cellID, view, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a dashboard
         * @param {CreateDashboardRequest} createDashboardRequest dashboard to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboards(createDashboardRequest: CreateDashboardRequest, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).postDashboards(createDashboardRequest, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDCells(dashboardID: string, createCell: CreateCell, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).postDashboardsIDCells(dashboardID, createCell, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDLabels(dashboardID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).postDashboardsIDLabels(dashboardID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDMembers(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMember> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).postDashboardsIDMembers(dashboardID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDOwners(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwner> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).postDashboardsIDOwners(dashboardID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDashboardsIDCells(dashboardID: string, cell: Array<Cell>, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dashboard> {
            const localVarAxiosArgs = DashboardsApiAxiosParamCreator(configuration).putDashboardsIDCells(dashboardID, cell, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * DashboardsApi - factory interface
 * @export
 */
export const DashboardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsID(dashboardID: string, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).deleteDashboardsID(dashboardID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete a dashboard cell
         * @param {string} dashboardID ID of dashboard to delte
         * @param {string} cellID ID of cell to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDCellsID(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).deleteDashboardsIDCellsID(dashboardID, cellID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} labelID the label id to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDLabelsID(dashboardID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).deleteDashboardsIDLabelsID(dashboardID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDMembersID(userID: string, dashboardID: string, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).deleteDashboardsIDMembersID(userID, dashboardID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDOwnersID(userID: string, dashboardID: string, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).deleteDashboardsIDOwnersID(userID, dashboardID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get all dashboards
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [owner] specifies the owner id to return resources for
         * @param {'ID' | 'CreatedAt' | 'UpdatedAt'} [sortBy] specifies the owner id to return resources for
         * @param {Array<string>} [id] ID list of dashboards to return. If both this and owner are specified, only ids is used.
         * @param {string} [orgID] specifies the organization id of the resource
         * @param {string} [org] specifies the organization name of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboards(zapTraceSpan?: string, owner?: string, sortBy?: 'ID' | 'CreatedAt' | 'UpdatedAt', id?: Array<string>, orgID?: string, org?: string, options?: any) {
            return DashboardsApiFp(configuration).getDashboards(zapTraceSpan, owner, sortBy, id, orgID, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a single Dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsID(dashboardID: string, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).getDashboardsID(dashboardID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDCellsIDView(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).getDashboardsIDCellsIDView(dashboardID, cellID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDLabels(dashboardID: string, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).getDashboardsIDLabels(dashboardID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve operation logs for a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDLogs(dashboardID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
            return DashboardsApiFp(configuration).getDashboardsIDLogs(dashboardID, zapTraceSpan, offset, limit, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDMembers(dashboardID: string, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).getDashboardsIDMembers(dashboardID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDOwners(dashboardID: string, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).getDashboardsIDOwners(dashboardID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a single dashboard
         * @param {string} dashboardID ID of dashboard to update
         * @param {Dashboard} dashboard patching of a dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsID(dashboardID: string, dashboard: Dashboard, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).patchDashboardsID(dashboardID, dashboard, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsID(dashboardID: string, cellID: string, cellUpdate: CellUpdate, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).patchDashboardsIDCellsID(dashboardID, cellID, cellUpdate, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsIDView(dashboardID: string, cellID: string, view: View, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).patchDashboardsIDCellsIDView(dashboardID, cellID, view, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a dashboard
         * @param {CreateDashboardRequest} createDashboardRequest dashboard to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboards(createDashboardRequest: CreateDashboardRequest, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).postDashboards(createDashboardRequest, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a dashboard cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {CreateCell} createCell cell that will be added
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDCells(dashboardID: string, createCell: CreateCell, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).postDashboardsIDCells(dashboardID, createCell, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDLabels(dashboardID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).postDashboardsIDLabels(dashboardID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDMembers(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).postDashboardsIDMembers(dashboardID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDOwners(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).postDashboardsIDOwners(dashboardID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Replace a dashboards cells
         * @param {string} dashboardID ID of dashboard to update
         * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDashboardsIDCells(dashboardID: string, cell: Array<Cell>, zapTraceSpan?: string, options?: any) {
            return DashboardsApiFp(configuration).putDashboardsIDCells(dashboardID, cell, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * DashboardsApi - object-oriented interface
 * @export
 * @class DashboardsApi
 * @extends {BaseAPI}
 */
export class DashboardsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a dashboard
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public deleteDashboardsID(dashboardID: string, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).deleteDashboardsID(dashboardID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete a dashboard cell
     * @param {string} dashboardID ID of dashboard to delte
     * @param {string} cellID ID of cell to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public deleteDashboardsIDCellsID(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).deleteDashboardsIDCellsID(dashboardID, cellID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a dashboard
     * @param {string} dashboardID ID of the dashboard
     * @param {string} labelID the label id to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public deleteDashboardsIDLabelsID(dashboardID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).deleteDashboardsIDLabelsID(dashboardID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an dashboard
     * @param {string} userID ID of member to remove
     * @param {string} dashboardID ID of the dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public deleteDashboardsIDMembersID(userID: string, dashboardID: string, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).deleteDashboardsIDMembersID(userID, dashboardID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a dashboard
     * @param {string} userID ID of owner to remove
     * @param {string} dashboardID ID of the dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public deleteDashboardsIDOwnersID(userID: string, dashboardID: string, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).deleteDashboardsIDOwnersID(userID, dashboardID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get all dashboards
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [owner] specifies the owner id to return resources for
     * @param {'ID' | 'CreatedAt' | 'UpdatedAt'} [sortBy] specifies the owner id to return resources for
     * @param {Array<string>} [id] ID list of dashboards to return. If both this and owner are specified, only ids is used.
     * @param {string} [orgID] specifies the organization id of the resource
     * @param {string} [org] specifies the organization name of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDashboards(zapTraceSpan?: string, owner?: string, sortBy?: 'ID' | 'CreatedAt' | 'UpdatedAt', id?: Array<string>, orgID?: string, org?: string, options?: any) {
        return DashboardsApiFp(this.configuration).getDashboards(zapTraceSpan, owner, sortBy, id, orgID, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a single Dashboard
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDashboardsID(dashboardID: string, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).getDashboardsID(dashboardID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve the view for a cell in a dashboard
     * @param {string} dashboardID ID of dashboard
     * @param {string} cellID ID of cell
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDashboardsIDCellsIDView(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).getDashboardsIDCellsIDView(dashboardID, cellID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a dashboard
     * @param {string} dashboardID ID of the dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDashboardsIDLabels(dashboardID: string, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).getDashboardsIDLabels(dashboardID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve operation logs for a dashboard
     * @param {string} dashboardID ID of the dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDashboardsIDLogs(dashboardID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
        return DashboardsApiFp(this.configuration).getDashboardsIDLogs(dashboardID, zapTraceSpan, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all dashboard members
     * @param {string} dashboardID ID of the dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDashboardsIDMembers(dashboardID: string, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).getDashboardsIDMembers(dashboardID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all dashboard owners
     * @param {string} dashboardID ID of the dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDashboardsIDOwners(dashboardID: string, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).getDashboardsIDOwners(dashboardID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a single dashboard
     * @param {string} dashboardID ID of dashboard to update
     * @param {Dashboard} dashboard patching of a dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public patchDashboardsID(dashboardID: string, dashboard: Dashboard, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).patchDashboardsID(dashboardID, dashboard, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the non positional information related to a cell (because updates to a single cells positional data could cause grid conflicts)
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} cellID ID of cell to update
     * @param {CellUpdate} cellUpdate updates the non positional information related to a cell
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public patchDashboardsIDCellsID(dashboardID: string, cellID: string, cellUpdate: CellUpdate, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).patchDashboardsIDCellsID(dashboardID, cellID, cellUpdate, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the view for a cell
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} cellID ID of cell to update
     * @param {View} view updates the view for a cell
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public patchDashboardsIDCellsIDView(dashboardID: string, cellID: string, view: View, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).patchDashboardsIDCellsIDView(dashboardID, cellID, view, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a dashboard
     * @param {CreateDashboardRequest} createDashboardRequest dashboard to create
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public postDashboards(createDashboardRequest: CreateDashboardRequest, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).postDashboards(createDashboardRequest, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a dashboard cell
     * @param {string} dashboardID ID of dashboard to update
     * @param {CreateCell} createCell cell that will be added
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public postDashboardsIDCells(dashboardID: string, createCell: CreateCell, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).postDashboardsIDCells(dashboardID, createCell, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a dashboard
     * @param {string} dashboardID ID of the dashboard
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public postDashboardsIDLabels(dashboardID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).postDashboardsIDLabels(dashboardID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add dashboard member
     * @param {string} dashboardID ID of the dashboard
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public postDashboardsIDMembers(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).postDashboardsIDMembers(dashboardID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add dashboard owner
     * @param {string} dashboardID ID of the dashboard
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public postDashboardsIDOwners(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).postDashboardsIDOwners(dashboardID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Replace a dashboards cells
     * @param {string} dashboardID ID of dashboard to update
     * @param {Array<Cell>} cell batch replaces all of a dashboards cells (this is used primarily to update the positional information of all of the cells)
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public putDashboardsIDCells(dashboardID: string, cell: Array<Cell>, zapTraceSpan?: string, options?: any) {
        return DashboardsApiFp(this.configuration).putDashboardsIDCells(dashboardID, cell, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Map of all top level routes available
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes(zapTraceSpan?: string, options: any = {}): RequestArgs {
            const localVarPath = `/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Exchange basic auth credentials for session
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSignin(zapTraceSpan?: string, options: any = {}): RequestArgs {
            const localVarPath = `/signin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Expire the current session
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSignout(zapTraceSpan?: string, options: any = {}): RequestArgs {
            const localVarPath = `/signout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Map of all top level routes available
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes(zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Routes> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getRoutes(zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Exchange basic auth credentials for session
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSignin(zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).postSignin(zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Expire the current session
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSignout(zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).postSignout(zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Map of all top level routes available
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes(zapTraceSpan?: string, options?: any) {
            return DefaultApiFp(configuration).getRoutes(zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Exchange basic auth credentials for session
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSignin(zapTraceSpan?: string, options?: any) {
            return DefaultApiFp(configuration).postSignin(zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Expire the current session
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSignout(zapTraceSpan?: string, options?: any) {
            return DefaultApiFp(configuration).postSignout(zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Map of all top level routes available
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRoutes(zapTraceSpan?: string, options?: any) {
        return DefaultApiFp(this.configuration).getRoutes(zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Exchange basic auth credentials for session
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postSignin(zapTraceSpan?: string, options?: any) {
        return DefaultApiFp(this.configuration).postSignin(zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Expire the current session
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postSignout(zapTraceSpan?: string, options?: any) {
        return DefaultApiFp(this.configuration).postSignout(zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the health of an instance anytime during execution. Allow us to check if the instance is still healthy.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(zapTraceSpan?: string, options: any = {}): RequestArgs {
            const localVarPath = `/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the health of an instance anytime during execution. Allow us to check if the instance is still healthy.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Check> {
            const localVarAxiosArgs = HealthApiAxiosParamCreator(configuration).getHealth(zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get the health of an instance anytime during execution. Allow us to check if the instance is still healthy.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(zapTraceSpan?: string, options?: any) {
            return HealthApiFp(configuration).getHealth(zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Get the health of an instance anytime during execution. Allow us to check if the instance is still healthy.
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getHealth(zapTraceSpan?: string, options?: any) {
        return HealthApiFp(this.configuration).getHealth(zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * LabelsApi - axios parameter creator
 * @export
 */
export const LabelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a label
         * @param {string} labelID ID of label to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLabelsID(labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling deleteLabelsID.');
            }
            const localVarPath = `/labels/{labelID}`
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all labels
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [orgID] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabels(zapTraceSpan?: string, orgID?: string, options: any = {}): RequestArgs {
            const localVarPath = `/labels`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgID !== undefined) {
                localVarQueryParameter['orgID'] = orgID;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a label
         * @param {string} labelID ID of label to update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelsID(labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling getLabelsID.');
            }
            const localVarPath = `/labels/{labelID}`
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single label
         * @param {string} labelID ID of label to update
         * @param {LabelUpdate} labelUpdate label update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchLabelsID(labelID: string, labelUpdate: LabelUpdate, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling patchLabelsID.');
            }
            // verify required parameter 'labelUpdate' is not null or undefined
            if (labelUpdate === null || labelUpdate === undefined) {
                throw new RequiredError('labelUpdate','Required parameter labelUpdate was null or undefined when calling patchLabelsID.');
            }
            const localVarPath = `/labels/{labelID}`
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelUpdate || {}) : (labelUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a label
         * @param {LabelCreateRequest} labelCreateRequest label to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLabels(labelCreateRequest: LabelCreateRequest, options: any = {}): RequestArgs {
            // verify required parameter 'labelCreateRequest' is not null or undefined
            if (labelCreateRequest === null || labelCreateRequest === undefined) {
                throw new RequiredError('labelCreateRequest','Required parameter labelCreateRequest was null or undefined when calling postLabels.');
            }
            const localVarPath = `/labels`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelCreateRequest || {}) : (labelCreateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LabelsApi - functional programming interface
 * @export
 */
export const LabelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a label
         * @param {string} labelID ID of label to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLabelsID(labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = LabelsApiAxiosParamCreator(configuration).deleteLabelsID(labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get all labels
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [orgID] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabels(zapTraceSpan?: string, orgID?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = LabelsApiAxiosParamCreator(configuration).getLabels(zapTraceSpan, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a label
         * @param {string} labelID ID of label to update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelsID(labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = LabelsApiAxiosParamCreator(configuration).getLabelsID(labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a single label
         * @param {string} labelID ID of label to update
         * @param {LabelUpdate} labelUpdate label update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchLabelsID(labelID: string, labelUpdate: LabelUpdate, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = LabelsApiAxiosParamCreator(configuration).patchLabelsID(labelID, labelUpdate, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a label
         * @param {LabelCreateRequest} labelCreateRequest label to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLabels(labelCreateRequest: LabelCreateRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = LabelsApiAxiosParamCreator(configuration).postLabels(labelCreateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * LabelsApi - factory interface
 * @export
 */
export const LabelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a label
         * @param {string} labelID ID of label to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLabelsID(labelID: string, zapTraceSpan?: string, options?: any) {
            return LabelsApiFp(configuration).deleteLabelsID(labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get all labels
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [orgID] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabels(zapTraceSpan?: string, orgID?: string, options?: any) {
            return LabelsApiFp(configuration).getLabels(zapTraceSpan, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a label
         * @param {string} labelID ID of label to update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelsID(labelID: string, zapTraceSpan?: string, options?: any) {
            return LabelsApiFp(configuration).getLabelsID(labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a single label
         * @param {string} labelID ID of label to update
         * @param {LabelUpdate} labelUpdate label update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchLabelsID(labelID: string, labelUpdate: LabelUpdate, zapTraceSpan?: string, options?: any) {
            return LabelsApiFp(configuration).patchLabelsID(labelID, labelUpdate, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a label
         * @param {LabelCreateRequest} labelCreateRequest label to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLabels(labelCreateRequest: LabelCreateRequest, options?: any) {
            return LabelsApiFp(configuration).postLabels(labelCreateRequest, options)(axios, basePath);
        },
    };
};

/**
 * LabelsApi - object-oriented interface
 * @export
 * @class LabelsApi
 * @extends {BaseAPI}
 */
export class LabelsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a label
     * @param {string} labelID ID of label to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    public deleteLabelsID(labelID: string, zapTraceSpan?: string, options?: any) {
        return LabelsApiFp(this.configuration).deleteLabelsID(labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get all labels
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [orgID] specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    public getLabels(zapTraceSpan?: string, orgID?: string, options?: any) {
        return LabelsApiFp(this.configuration).getLabels(zapTraceSpan, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a label
     * @param {string} labelID ID of label to update
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    public getLabelsID(labelID: string, zapTraceSpan?: string, options?: any) {
        return LabelsApiFp(this.configuration).getLabelsID(labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a single label
     * @param {string} labelID ID of label to update
     * @param {LabelUpdate} labelUpdate label update
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    public patchLabelsID(labelID: string, labelUpdate: LabelUpdate, zapTraceSpan?: string, options?: any) {
        return LabelsApiFp(this.configuration).patchLabelsID(labelID, labelUpdate, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a label
     * @param {LabelCreateRequest} labelCreateRequest label to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    public postLabels(labelCreateRequest: LabelCreateRequest, options?: any) {
        return LabelsApiFp(this.configuration).postLabels(labelCreateRequest, options)(this.axios, this.basePath);
    }

}

/**
 * OperationLogsApi - axios parameter creator
 * @export
 */
export const OperationLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve operation logs for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDLogs(bucketID: string, zapTraceSpan?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling getBucketsIDLogs.');
            }
            const localVarPath = `/buckets/{bucketID}/logs`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDLogs(dashboardID: string, zapTraceSpan?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling getDashboardsIDLogs.');
            }
            const localVarPath = `/dashboards/{dashboardID}/logs`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDLogs(orgID: string, zapTraceSpan?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling getOrgsIDLogs.');
            }
            const localVarPath = `/orgs/{orgID}/logs`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for a user
         * @param {string} userID ID of the user
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersIDLogs(userID: string, zapTraceSpan?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling getUsersIDLogs.');
            }
            const localVarPath = `/users/{userID}/logs`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationLogsApi - functional programming interface
 * @export
 */
export const OperationLogsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve operation logs for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDLogs(bucketID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationLogs> {
            const localVarAxiosArgs = OperationLogsApiAxiosParamCreator(configuration).getBucketsIDLogs(bucketID, zapTraceSpan, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDLogs(dashboardID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationLogs> {
            const localVarAxiosArgs = OperationLogsApiAxiosParamCreator(configuration).getDashboardsIDLogs(dashboardID, zapTraceSpan, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDLogs(orgID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationLogs> {
            const localVarAxiosArgs = OperationLogsApiAxiosParamCreator(configuration).getOrgsIDLogs(orgID, zapTraceSpan, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for a user
         * @param {string} userID ID of the user
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersIDLogs(userID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationLogs> {
            const localVarAxiosArgs = OperationLogsApiAxiosParamCreator(configuration).getUsersIDLogs(userID, zapTraceSpan, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * OperationLogsApi - factory interface
 * @export
 */
export const OperationLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Retrieve operation logs for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDLogs(bucketID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
            return OperationLogsApiFp(configuration).getBucketsIDLogs(bucketID, zapTraceSpan, offset, limit, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve operation logs for a dashboard
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDLogs(dashboardID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
            return OperationLogsApiFp(configuration).getDashboardsIDLogs(dashboardID, zapTraceSpan, offset, limit, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve operation logs for an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDLogs(orgID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
            return OperationLogsApiFp(configuration).getOrgsIDLogs(orgID, zapTraceSpan, offset, limit, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve operation logs for a user
         * @param {string} userID ID of the user
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersIDLogs(userID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
            return OperationLogsApiFp(configuration).getUsersIDLogs(userID, zapTraceSpan, offset, limit, options)(axios, basePath);
        },
    };
};

/**
 * OperationLogsApi - object-oriented interface
 * @export
 * @class OperationLogsApi
 * @extends {BaseAPI}
 */
export class OperationLogsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve operation logs for a bucket
     * @param {string} bucketID ID of the bucket
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationLogsApi
     */
    public getBucketsIDLogs(bucketID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
        return OperationLogsApiFp(this.configuration).getBucketsIDLogs(bucketID, zapTraceSpan, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve operation logs for a dashboard
     * @param {string} dashboardID ID of the dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationLogsApi
     */
    public getDashboardsIDLogs(dashboardID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
        return OperationLogsApiFp(this.configuration).getDashboardsIDLogs(dashboardID, zapTraceSpan, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve operation logs for an organization
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationLogsApi
     */
    public getOrgsIDLogs(orgID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
        return OperationLogsApiFp(this.configuration).getOrgsIDLogs(orgID, zapTraceSpan, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve operation logs for a user
     * @param {string} userID ID of the user
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationLogsApi
     */
    public getUsersIDLogs(userID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
        return OperationLogsApiFp(this.configuration).getUsersIDLogs(userID, zapTraceSpan, offset, limit, options)(this.axios, this.basePath);
    }

}

/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an organization
         * @param {string} orgID ID of organization to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsID(orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling deleteOrgsID.');
            }
            const localVarPath = `/orgs/{orgID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from an organization
         * @param {string} orgID ID of the organization
         * @param {string} labelID the label id
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDLabelsID(orgID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling deleteOrgsIDLabelsID.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling deleteOrgsIDLabelsID.');
            }
            const localVarPath = `/orgs/{orgID}/labels/{labelID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDMembersID(userID: string, orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteOrgsIDMembersID.');
            }
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling deleteOrgsIDMembersID.');
            }
            const localVarPath = `/orgs/{orgID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDOwnersID(userID: string, orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteOrgsIDOwnersID.');
            }
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling deleteOrgsIDOwnersID.');
            }
            const localVarPath = `/orgs/{orgID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all organizations
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] filter organizations to a specific organization name
         * @param {string} [orgID] filter organizations to a specific organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgs(zapTraceSpan?: string, org?: string, orgID?: string, options: any = {}): RequestArgs {
            const localVarPath = `/orgs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (orgID !== undefined) {
                localVarQueryParameter['orgID'] = orgID;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an organization
         * @param {string} orgID ID of organization to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsID(orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling getOrgsID.');
            }
            const localVarPath = `/orgs/{orgID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDLabels(orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling getOrgsIDLabels.');
            }
            const localVarPath = `/orgs/{orgID}/labels`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDLogs(orgID: string, zapTraceSpan?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling getOrgsIDLogs.');
            }
            const localVarPath = `/orgs/{orgID}/logs`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDMembers(orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling getOrgsIDMembers.');
            }
            const localVarPath = `/orgs/{orgID}/members`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDOwners(orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling getOrgsIDOwners.');
            }
            const localVarPath = `/orgs/{orgID}/owners`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all secret keys for an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDSecrets(orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling getOrgsIDSecrets.');
            }
            const localVarPath = `/orgs/{orgID}/secrets`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an organization
         * @param {string} orgID ID of organization to get
         * @param {Organization} organization organization update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgsID(orgID: string, organization: Organization, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling patchOrgsID.');
            }
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling patchOrgsID.');
            }
            const localVarPath = `/orgs/{orgID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organization || {}) : (organization || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply patch to the provided secrets
         * @param {string} orgID ID of the organization
         * @param {{ [key: string]: string; }} requestBody secret key value pairs to update/add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgsIDSecrets(orgID: string, requestBody: { [key: string]: string; }, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling patchOrgsIDSecrets.');
            }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling patchOrgsIDSecrets.');
            }
            const localVarPath = `/orgs/{orgID}/secrets`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"{ [key: string]: string; }" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an organization
         * @param {Organization} organization organization to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgs(organization: Organization, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling postOrgs.');
            }
            const localVarPath = `/orgs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(organization || {}) : (organization || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to an organization
         * @param {string} orgID ID of the organization
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDLabels(orgID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling postOrgsIDLabels.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling postOrgsIDLabels.');
            }
            const localVarPath = `/orgs/{orgID}/labels`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDMembers(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling postOrgsIDMembers.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postOrgsIDMembers.');
            }
            const localVarPath = `/orgs/{orgID}/members`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDOwners(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling postOrgsIDOwners.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postOrgsIDOwners.');
            }
            const localVarPath = `/orgs/{orgID}/owners`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete provided secrets
         * @param {string} orgID ID of the organization
         * @param {SecretKeys} secretKeys secret key to deleted
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDSecrets(orgID: string, secretKeys: SecretKeys, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling postOrgsIDSecrets.');
            }
            // verify required parameter 'secretKeys' is not null or undefined
            if (secretKeys === null || secretKeys === undefined) {
                throw new RequiredError('secretKeys','Required parameter secretKeys was null or undefined when calling postOrgsIDSecrets.');
            }
            const localVarPath = `/orgs/{orgID}/secrets/delete`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SecretKeys" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(secretKeys || {}) : (secretKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an organization
         * @param {string} orgID ID of organization to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsID(orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).deleteOrgsID(orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from an organization
         * @param {string} orgID ID of the organization
         * @param {string} labelID the label id
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDLabelsID(orgID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).deleteOrgsIDLabelsID(orgID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDMembersID(userID: string, orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).deleteOrgsIDMembersID(userID, orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDOwnersID(userID: string, orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).deleteOrgsIDOwnersID(userID, orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all organizations
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] filter organizations to a specific organization name
         * @param {string} [orgID] filter organizations to a specific organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgs(zapTraceSpan?: string, org?: string, orgID?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organizations> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).getOrgs(zapTraceSpan, org, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve an organization
         * @param {string} orgID ID of organization to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsID(orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).getOrgsID(orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDLabels(orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).getOrgsIDLabels(orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDLogs(orgID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationLogs> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).getOrgsIDLogs(orgID, zapTraceSpan, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDMembers(orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMembers> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).getOrgsIDMembers(orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDOwners(orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).getOrgsIDOwners(orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all secret keys for an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDSecrets(orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretKeysResponse> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).getOrgsIDSecrets(orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update an organization
         * @param {string} orgID ID of organization to get
         * @param {Organization} organization organization update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgsID(orgID: string, organization: Organization, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).patchOrgsID(orgID, organization, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Apply patch to the provided secrets
         * @param {string} orgID ID of the organization
         * @param {{ [key: string]: string; }} requestBody secret key value pairs to update/add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgsIDSecrets(orgID: string, requestBody: { [key: string]: string; }, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).patchOrgsIDSecrets(orgID, requestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create an organization
         * @param {Organization} organization organization to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgs(organization: Organization, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).postOrgs(organization, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to an organization
         * @param {string} orgID ID of the organization
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDLabels(orgID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).postOrgsIDLabels(orgID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDMembers(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMember> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).postOrgsIDMembers(orgID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDOwners(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwner> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).postOrgsIDOwners(orgID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete provided secrets
         * @param {string} orgID ID of the organization
         * @param {SecretKeys} secretKeys secret key to deleted
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDSecrets(orgID: string, secretKeys: SecretKeys, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrganizationsApiAxiosParamCreator(configuration).postOrgsIDSecrets(orgID, secretKeys, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete an organization
         * @param {string} orgID ID of organization to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsID(orgID: string, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).deleteOrgsID(orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from an organization
         * @param {string} orgID ID of the organization
         * @param {string} labelID the label id
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDLabelsID(orgID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).deleteOrgsIDLabelsID(orgID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDMembersID(userID: string, orgID: string, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).deleteOrgsIDMembersID(userID, orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDOwnersID(userID: string, orgID: string, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).deleteOrgsIDOwnersID(userID, orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all organizations
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] filter organizations to a specific organization name
         * @param {string} [orgID] filter organizations to a specific organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgs(zapTraceSpan?: string, org?: string, orgID?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrgs(zapTraceSpan, org, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve an organization
         * @param {string} orgID ID of organization to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsID(orgID: string, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrgsID(orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDLabels(orgID: string, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrgsIDLabels(orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve operation logs for an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDLogs(orgID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
            return OrganizationsApiFp(configuration).getOrgsIDLogs(orgID, zapTraceSpan, offset, limit, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDMembers(orgID: string, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrgsIDMembers(orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDOwners(orgID: string, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrgsIDOwners(orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all secret keys for an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDSecrets(orgID: string, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrgsIDSecrets(orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update an organization
         * @param {string} orgID ID of organization to get
         * @param {Organization} organization organization update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgsID(orgID: string, organization: Organization, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).patchOrgsID(orgID, organization, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Apply patch to the provided secrets
         * @param {string} orgID ID of the organization
         * @param {{ [key: string]: string; }} requestBody secret key value pairs to update/add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgsIDSecrets(orgID: string, requestBody: { [key: string]: string; }, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).patchOrgsIDSecrets(orgID, requestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create an organization
         * @param {Organization} organization organization to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgs(organization: Organization, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).postOrgs(organization, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to an organization
         * @param {string} orgID ID of the organization
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDLabels(orgID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).postOrgsIDLabels(orgID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDMembers(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).postOrgsIDMembers(orgID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDOwners(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).postOrgsIDOwners(orgID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete provided secrets
         * @param {string} orgID ID of the organization
         * @param {SecretKeys} secretKeys secret key to deleted
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDSecrets(orgID: string, secretKeys: SecretKeys, zapTraceSpan?: string, options?: any) {
            return OrganizationsApiFp(configuration).postOrgsIDSecrets(orgID, secretKeys, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @summary Delete an organization
     * @param {string} orgID ID of organization to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrgsID(orgID: string, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrgsID(orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from an organization
     * @param {string} orgID ID of the organization
     * @param {string} labelID the label id
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrgsIDLabelsID(orgID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrgsIDLabelsID(orgID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an organization
     * @param {string} userID ID of member to remove
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrgsIDMembersID(userID: string, orgID: string, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrgsIDMembersID(userID, orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an organization
     * @param {string} userID ID of owner to remove
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrgsIDOwnersID(userID: string, orgID: string, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrgsIDOwnersID(userID, orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all organizations
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [org] filter organizations to a specific organization name
     * @param {string} [orgID] filter organizations to a specific organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrgs(zapTraceSpan?: string, org?: string, orgID?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrgs(zapTraceSpan, org, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve an organization
     * @param {string} orgID ID of organization to get
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrgsID(orgID: string, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrgsID(orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a organization
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrgsIDLabels(orgID: string, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrgsIDLabels(orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve operation logs for an organization
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrgsIDLogs(orgID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrgsIDLogs(orgID, zapTraceSpan, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all members of an organization
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrgsIDMembers(orgID: string, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrgsIDMembers(orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of an organization
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrgsIDOwners(orgID: string, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrgsIDOwners(orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all secret keys for an organization
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrgsIDSecrets(orgID: string, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrgsIDSecrets(orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update an organization
     * @param {string} orgID ID of organization to get
     * @param {Organization} organization organization update to apply
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public patchOrgsID(orgID: string, organization: Organization, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).patchOrgsID(orgID, organization, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Apply patch to the provided secrets
     * @param {string} orgID ID of the organization
     * @param {{ [key: string]: string; }} requestBody secret key value pairs to update/add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public patchOrgsIDSecrets(orgID: string, requestBody: { [key: string]: string; }, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).patchOrgsIDSecrets(orgID, requestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create an organization
     * @param {Organization} organization organization to create
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public postOrgs(organization: Organization, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).postOrgs(organization, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to an organization
     * @param {string} orgID ID of the organization
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public postOrgsIDLabels(orgID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).postOrgsIDLabels(orgID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add organization member
     * @param {string} orgID ID of the organization
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public postOrgsIDMembers(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).postOrgsIDMembers(orgID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add organization owner
     * @param {string} orgID ID of the organization
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public postOrgsIDOwners(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).postOrgsIDOwners(orgID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete provided secrets
     * @param {string} orgID ID of the organization
     * @param {SecretKeys} secretKeys secret key to deleted
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public postOrgsIDSecrets(orgID: string, secretKeys: SecretKeys, zapTraceSpan?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).postOrgsIDSecrets(orgID, secretKeys, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerySuggestions(zapTraceSpan?: string, options: any = {}): RequestArgs {
            const localVarPath = `/query/suggestions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name name of branching suggestion
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerySuggestionsName(name: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getQuerySuggestionsName.');
            }
            const localVarPath = `/query/suggestions/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary query an influx
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'application/json' | 'application/vnd.flux'} [contentType] 
         * @param {string} [org] specifies the name of the organization executing the query; if both orgID and org are specified, orgID takes precedence.
         * @param {string} [orgID] specifies the ID of the organization executing the query; if both orgID and org are specified, orgID takes precedence.
         * @param {Query} [query] flux query or specification to execute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuery(zapTraceSpan?: string, contentType?: 'application/json' | 'application/vnd.flux', org?: string, orgID?: string, query?: Query, options: any = {}): RequestArgs {
            const localVarPath = `/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (orgID !== undefined) {
                localVarQueryParameter['orgID'] = orgID;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Query" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary analyze an influxql or flux query
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'application/json'} [contentType] 
         * @param {Query} [query] flux or influxql query to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQueryAnalyze(zapTraceSpan?: string, contentType?: 'application/json', query?: Query, options: any = {}): RequestArgs {
            const localVarPath = `/query/analyze`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Query" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * analyzes flux query and generates a query specification.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'application/json'} [contentType] 
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate abstract syntax tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQueryAst(zapTraceSpan?: string, contentType?: 'application/json', languageRequest?: LanguageRequest, options: any = {}): RequestArgs {
            const localVarPath = `/query/ast`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LanguageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(languageRequest || {}) : (languageRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerySuggestions(zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FluxSuggestions> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).getQuerySuggestions(zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} name name of branching suggestion
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerySuggestionsName(name: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FluxSuggestions> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).getQuerySuggestionsName(name, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary query an influx
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'application/json' | 'application/vnd.flux'} [contentType] 
         * @param {string} [org] specifies the name of the organization executing the query; if both orgID and org are specified, orgID takes precedence.
         * @param {string} [orgID] specifies the ID of the organization executing the query; if both orgID and org are specified, orgID takes precedence.
         * @param {Query} [query] flux query or specification to execute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuery(zapTraceSpan?: string, contentType?: 'application/json' | 'application/vnd.flux', org?: string, orgID?: string, query?: Query, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).postQuery(zapTraceSpan, contentType, org, orgID, query, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary analyze an influxql or flux query
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'application/json'} [contentType] 
         * @param {Query} [query] flux or influxql query to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQueryAnalyze(zapTraceSpan?: string, contentType?: 'application/json', query?: Query, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalyzeQueryResponse> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).postQueryAnalyze(zapTraceSpan, contentType, query, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * analyzes flux query and generates a query specification.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'application/json'} [contentType] 
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate abstract syntax tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQueryAst(zapTraceSpan?: string, contentType?: 'application/json', languageRequest?: LanguageRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ASTResponse> {
            const localVarAxiosArgs = QueryApiAxiosParamCreator(configuration).postQueryAst(zapTraceSpan, contentType, languageRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerySuggestions(zapTraceSpan?: string, options?: any) {
            return QueryApiFp(configuration).getQuerySuggestions(zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} name name of branching suggestion
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuerySuggestionsName(name: string, zapTraceSpan?: string, options?: any) {
            return QueryApiFp(configuration).getQuerySuggestionsName(name, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary query an influx
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'application/json' | 'application/vnd.flux'} [contentType] 
         * @param {string} [org] specifies the name of the organization executing the query; if both orgID and org are specified, orgID takes precedence.
         * @param {string} [orgID] specifies the ID of the organization executing the query; if both orgID and org are specified, orgID takes precedence.
         * @param {Query} [query] flux query or specification to execute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQuery(zapTraceSpan?: string, contentType?: 'application/json' | 'application/vnd.flux', org?: string, orgID?: string, query?: Query, options?: any) {
            return QueryApiFp(configuration).postQuery(zapTraceSpan, contentType, org, orgID, query, options)(axios, basePath);
        },
        /**
         * 
         * @summary analyze an influxql or flux query
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'application/json'} [contentType] 
         * @param {Query} [query] flux or influxql query to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQueryAnalyze(zapTraceSpan?: string, contentType?: 'application/json', query?: Query, options?: any) {
            return QueryApiFp(configuration).postQueryAnalyze(zapTraceSpan, contentType, query, options)(axios, basePath);
        },
        /**
         * analyzes flux query and generates a query specification.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'application/json'} [contentType] 
         * @param {LanguageRequest} [languageRequest] analyzed flux query to generate abstract syntax tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postQueryAst(zapTraceSpan?: string, contentType?: 'application/json', languageRequest?: LanguageRequest, options?: any) {
            return QueryApiFp(configuration).postQueryAst(zapTraceSpan, contentType, languageRequest, options)(axios, basePath);
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * 
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public getQuerySuggestions(zapTraceSpan?: string, options?: any) {
        return QueryApiFp(this.configuration).getQuerySuggestions(zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} name name of branching suggestion
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public getQuerySuggestionsName(name: string, zapTraceSpan?: string, options?: any) {
        return QueryApiFp(this.configuration).getQuerySuggestionsName(name, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary query an influx
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {'application/json' | 'application/vnd.flux'} [contentType] 
     * @param {string} [org] specifies the name of the organization executing the query; if both orgID and org are specified, orgID takes precedence.
     * @param {string} [orgID] specifies the ID of the organization executing the query; if both orgID and org are specified, orgID takes precedence.
     * @param {Query} [query] flux query or specification to execute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public postQuery(zapTraceSpan?: string, contentType?: 'application/json' | 'application/vnd.flux', org?: string, orgID?: string, query?: Query, options?: any) {
        return QueryApiFp(this.configuration).postQuery(zapTraceSpan, contentType, org, orgID, query, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary analyze an influxql or flux query
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {'application/json'} [contentType] 
     * @param {Query} [query] flux or influxql query to analyze
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public postQueryAnalyze(zapTraceSpan?: string, contentType?: 'application/json', query?: Query, options?: any) {
        return QueryApiFp(this.configuration).postQueryAnalyze(zapTraceSpan, contentType, query, options)(this.axios, this.basePath);
    }

    /**
     * analyzes flux query and generates a query specification.
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {'application/json'} [contentType] 
     * @param {LanguageRequest} [languageRequest] analyzed flux query to generate abstract syntax tree.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public postQueryAst(zapTraceSpan?: string, contentType?: 'application/json', languageRequest?: LanguageRequest, options?: any) {
        return QueryApiFp(this.configuration).postQueryAst(zapTraceSpan, contentType, languageRequest, options)(this.axios, this.basePath);
    }

}

/**
 * ReadyApi - axios parameter creator
 * @export
 */
export const ReadyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the readiness of a instance at startup. Allow us to confirm the instance is prepared to accept requests.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReady(zapTraceSpan?: string, options: any = {}): RequestArgs {
            const localVarPath = `/ready`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReadyApi - functional programming interface
 * @export
 */
export const ReadyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the readiness of a instance at startup. Allow us to confirm the instance is prepared to accept requests.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReady(zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ready> {
            const localVarAxiosArgs = ReadyApiAxiosParamCreator(configuration).getReady(zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * ReadyApi - factory interface
 * @export
 */
export const ReadyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get the readiness of a instance at startup. Allow us to confirm the instance is prepared to accept requests.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReady(zapTraceSpan?: string, options?: any) {
            return ReadyApiFp(configuration).getReady(zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * ReadyApi - object-oriented interface
 * @export
 * @class ReadyApi
 * @extends {BaseAPI}
 */
export class ReadyApi extends BaseAPI {
    /**
     * 
     * @summary Get the readiness of a instance at startup. Allow us to confirm the instance is prepared to accept requests.
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadyApi
     */
    public getReady(zapTraceSpan?: string, options?: any) {
        return ReadyApiFp(this.configuration).getReady(zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * ScraperTargetsApi - axios parameter creator
 * @export
 */
export const ScraperTargetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete a scraper target
         * @param {string} scraperTargetID id of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersID(scraperTargetID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling deleteScrapersID.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} labelID ID of the label
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDLabelsID(scraperTargetID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling deleteScrapersIDLabelsID.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling deleteScrapersIDLabelsID.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/labels/{labelID}`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from a scraper target
         * @param {string} userID ID of member to remove
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDMembersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteScrapersIDMembersID.');
            }
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling deleteScrapersIDMembersID.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a scraper target
         * @param {string} userID ID of owner to remove
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDOwnersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteScrapersIDOwnersID.');
            }
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling deleteScrapersIDOwnersID.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all scraper targets
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [name] specifies the name of the scraper target.
         * @param {Array<string>} [id] ID list of scraper targets to return. If both this and owner are specified, only ids is used.
         * @param {string} [orgID] specifies the organization id of the scraper target
         * @param {string} [org] specifies the organization name of the scraper target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapers(zapTraceSpan?: string, name?: string, id?: Array<string>, orgID?: string, org?: string, options: any = {}): RequestArgs {
            const localVarPath = `/scrapers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (orgID !== undefined) {
                localVarQueryParameter['orgID'] = orgID;
            }

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get a scraper target by id
         * @param {string} scraperTargetID id of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersID(scraperTargetID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling getScrapersID.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a scraper targets
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDLabels(scraperTargetID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling getScrapersIDLabels.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/labels`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDMembers(scraperTargetID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling getScrapersIDMembers.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/members`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDOwners(scraperTargetID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling getScrapersIDOwners.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/owners`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update a scraper target
         * @param {string} scraperTargetID id of the scraper target
         * @param {ScraperTargetRequest} scraperTargetRequest scraper target update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScrapersID(scraperTargetID: string, scraperTargetRequest: ScraperTargetRequest, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling patchScrapersID.');
            }
            // verify required parameter 'scraperTargetRequest' is not null or undefined
            if (scraperTargetRequest === null || scraperTargetRequest === undefined) {
                throw new RequiredError('scraperTargetRequest','Required parameter scraperTargetRequest was null or undefined when calling patchScrapersID.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScraperTargetRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(scraperTargetRequest || {}) : (scraperTargetRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update a label from a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} labelID ID of the label
         * @param {Label} label label update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScrapersIDLabelsID(scraperTargetID: string, labelID: string, label: Label, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling patchScrapersIDLabelsID.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling patchScrapersIDLabelsID.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling patchScrapersIDLabelsID.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/labels/{labelID}`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Label" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(label || {}) : (label || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create a scraper target
         * @param {ScraperTargetRequest} scraperTargetRequest scraper target to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapers(scraperTargetRequest: ScraperTargetRequest, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetRequest' is not null or undefined
            if (scraperTargetRequest === null || scraperTargetRequest === undefined) {
                throw new RequiredError('scraperTargetRequest','Required parameter scraperTargetRequest was null or undefined when calling postScrapers.');
            }
            const localVarPath = `/scrapers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScraperTargetRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(scraperTargetRequest || {}) : (scraperTargetRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDLabels(scraperTargetID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling postScrapersIDLabels.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling postScrapersIDLabels.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/labels`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add scraper target member
         * @param {string} scraperTargetID ID of the scraper target
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDMembers(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling postScrapersIDMembers.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postScrapersIDMembers.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/members`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add scraper target owner
         * @param {string} scraperTargetID ID of the scraper target
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDOwners(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling postScrapersIDOwners.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postScrapersIDOwners.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/owners`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScraperTargetsApi - functional programming interface
 * @export
 */
export const ScraperTargetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete a scraper target
         * @param {string} scraperTargetID id of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersID(scraperTargetID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).deleteScrapersID(scraperTargetID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} labelID ID of the label
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDLabelsID(scraperTargetID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).deleteScrapersIDLabelsID(scraperTargetID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from a scraper target
         * @param {string} userID ID of member to remove
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDMembersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).deleteScrapersIDMembersID(userID, scraperTargetID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a scraper target
         * @param {string} userID ID of owner to remove
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDOwnersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).deleteScrapersIDOwnersID(userID, scraperTargetID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary get all scraper targets
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [name] specifies the name of the scraper target.
         * @param {Array<string>} [id] ID list of scraper targets to return. If both this and owner are specified, only ids is used.
         * @param {string} [orgID] specifies the organization id of the scraper target
         * @param {string} [org] specifies the organization name of the scraper target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapers(zapTraceSpan?: string, name?: string, id?: Array<string>, orgID?: string, org?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScraperTargetResponses> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).getScrapers(zapTraceSpan, name, id, orgID, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary get a scraper target by id
         * @param {string} scraperTargetID id of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersID(scraperTargetID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScraperTargetResponse> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).getScrapersID(scraperTargetID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a scraper targets
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDLabels(scraperTargetID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).getScrapersIDLabels(scraperTargetID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDMembers(scraperTargetID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMembers> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).getScrapersIDMembers(scraperTargetID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDOwners(scraperTargetID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).getScrapersIDOwners(scraperTargetID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary update a scraper target
         * @param {string} scraperTargetID id of the scraper target
         * @param {ScraperTargetRequest} scraperTargetRequest scraper target update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScrapersID(scraperTargetID: string, scraperTargetRequest: ScraperTargetRequest, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScraperTargetResponse> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).patchScrapersID(scraperTargetID, scraperTargetRequest, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary update a label from a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} labelID ID of the label
         * @param {Label} label label update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScrapersIDLabelsID(scraperTargetID: string, labelID: string, label: Label, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).patchScrapersIDLabelsID(scraperTargetID, labelID, label, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary create a scraper target
         * @param {ScraperTargetRequest} scraperTargetRequest scraper target to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapers(scraperTargetRequest: ScraperTargetRequest, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScraperTargetResponse> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).postScrapers(scraperTargetRequest, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDLabels(scraperTargetID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).postScrapersIDLabels(scraperTargetID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add scraper target member
         * @param {string} scraperTargetID ID of the scraper target
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDMembers(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMember> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).postScrapersIDMembers(scraperTargetID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add scraper target owner
         * @param {string} scraperTargetID ID of the scraper target
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDOwners(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwner> {
            const localVarAxiosArgs = ScraperTargetsApiAxiosParamCreator(configuration).postScrapersIDOwners(scraperTargetID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * ScraperTargetsApi - factory interface
 * @export
 */
export const ScraperTargetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary delete a scraper target
         * @param {string} scraperTargetID id of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersID(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).deleteScrapersID(scraperTargetID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} labelID ID of the label
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDLabelsID(scraperTargetID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).deleteScrapersIDLabelsID(scraperTargetID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from a scraper target
         * @param {string} userID ID of member to remove
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDMembersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).deleteScrapersIDMembersID(userID, scraperTargetID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a scraper target
         * @param {string} userID ID of owner to remove
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDOwnersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).deleteScrapersIDOwnersID(userID, scraperTargetID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary get all scraper targets
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [name] specifies the name of the scraper target.
         * @param {Array<string>} [id] ID list of scraper targets to return. If both this and owner are specified, only ids is used.
         * @param {string} [orgID] specifies the organization id of the scraper target
         * @param {string} [org] specifies the organization name of the scraper target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapers(zapTraceSpan?: string, name?: string, id?: Array<string>, orgID?: string, org?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).getScrapers(zapTraceSpan, name, id, orgID, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary get a scraper target by id
         * @param {string} scraperTargetID id of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersID(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).getScrapersID(scraperTargetID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a scraper targets
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDLabels(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).getScrapersIDLabels(scraperTargetID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users with member privileges for a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDMembers(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).getScrapersIDMembers(scraperTargetID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDOwners(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).getScrapersIDOwners(scraperTargetID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary update a scraper target
         * @param {string} scraperTargetID id of the scraper target
         * @param {ScraperTargetRequest} scraperTargetRequest scraper target update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScrapersID(scraperTargetID: string, scraperTargetRequest: ScraperTargetRequest, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).patchScrapersID(scraperTargetID, scraperTargetRequest, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary update a label from a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} labelID ID of the label
         * @param {Label} label label update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScrapersIDLabelsID(scraperTargetID: string, labelID: string, label: Label, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).patchScrapersIDLabelsID(scraperTargetID, labelID, label, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary create a scraper target
         * @param {ScraperTargetRequest} scraperTargetRequest scraper target to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapers(scraperTargetRequest: ScraperTargetRequest, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).postScrapers(scraperTargetRequest, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDLabels(scraperTargetID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).postScrapersIDLabels(scraperTargetID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add scraper target member
         * @param {string} scraperTargetID ID of the scraper target
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDMembers(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).postScrapersIDMembers(scraperTargetID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add scraper target owner
         * @param {string} scraperTargetID ID of the scraper target
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDOwners(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return ScraperTargetsApiFp(configuration).postScrapersIDOwners(scraperTargetID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * ScraperTargetsApi - object-oriented interface
 * @export
 * @class ScraperTargetsApi
 * @extends {BaseAPI}
 */
export class ScraperTargetsApi extends BaseAPI {
    /**
     * 
     * @summary delete a scraper target
     * @param {string} scraperTargetID id of the scraper target
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public deleteScrapersID(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).deleteScrapersID(scraperTargetID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a scraper target
     * @param {string} scraperTargetID ID of the scraper target
     * @param {string} labelID ID of the label
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public deleteScrapersIDLabelsID(scraperTargetID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).deleteScrapersIDLabelsID(scraperTargetID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from a scraper target
     * @param {string} userID ID of member to remove
     * @param {string} scraperTargetID ID of the scraper target
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public deleteScrapersIDMembersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).deleteScrapersIDMembersID(userID, scraperTargetID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a scraper target
     * @param {string} userID ID of owner to remove
     * @param {string} scraperTargetID ID of the scraper target
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public deleteScrapersIDOwnersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).deleteScrapersIDOwnersID(userID, scraperTargetID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary get all scraper targets
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [name] specifies the name of the scraper target.
     * @param {Array<string>} [id] ID list of scraper targets to return. If both this and owner are specified, only ids is used.
     * @param {string} [orgID] specifies the organization id of the scraper target
     * @param {string} [org] specifies the organization name of the scraper target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public getScrapers(zapTraceSpan?: string, name?: string, id?: Array<string>, orgID?: string, org?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).getScrapers(zapTraceSpan, name, id, orgID, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary get a scraper target by id
     * @param {string} scraperTargetID id of the scraper target
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public getScrapersID(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).getScrapersID(scraperTargetID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a scraper targets
     * @param {string} scraperTargetID ID of the scraper target
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public getScrapersIDLabels(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).getScrapersIDLabels(scraperTargetID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users with member privileges for a scraper target
     * @param {string} scraperTargetID ID of the scraper target
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public getScrapersIDMembers(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).getScrapersIDMembers(scraperTargetID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a scraper target
     * @param {string} scraperTargetID ID of the scraper target
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public getScrapersIDOwners(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).getScrapersIDOwners(scraperTargetID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary update a scraper target
     * @param {string} scraperTargetID id of the scraper target
     * @param {ScraperTargetRequest} scraperTargetRequest scraper target update to apply
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public patchScrapersID(scraperTargetID: string, scraperTargetRequest: ScraperTargetRequest, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).patchScrapersID(scraperTargetID, scraperTargetRequest, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary update a label from a scraper target
     * @param {string} scraperTargetID ID of the scraper target
     * @param {string} labelID ID of the label
     * @param {Label} label label update to apply
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public patchScrapersIDLabelsID(scraperTargetID: string, labelID: string, label: Label, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).patchScrapersIDLabelsID(scraperTargetID, labelID, label, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary create a scraper target
     * @param {ScraperTargetRequest} scraperTargetRequest scraper target to create
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public postScrapers(scraperTargetRequest: ScraperTargetRequest, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).postScrapers(scraperTargetRequest, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a scraper target
     * @param {string} scraperTargetID ID of the scraper target
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public postScrapersIDLabels(scraperTargetID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).postScrapersIDLabels(scraperTargetID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add scraper target member
     * @param {string} scraperTargetID ID of the scraper target
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public postScrapersIDMembers(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).postScrapersIDMembers(scraperTargetID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add scraper target owner
     * @param {string} scraperTargetID ID of the scraper target
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScraperTargetsApi
     */
    public postScrapersIDOwners(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return ScraperTargetsApiFp(this.configuration).postScrapersIDOwners(scraperTargetID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * SecretsApi - axios parameter creator
 * @export
 */
export const SecretsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all secret keys for an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDSecrets(orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling getOrgsIDSecrets.');
            }
            const localVarPath = `/orgs/{orgID}/secrets`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply patch to the provided secrets
         * @param {string} orgID ID of the organization
         * @param {{ [key: string]: string; }} requestBody secret key value pairs to update/add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgsIDSecrets(orgID: string, requestBody: { [key: string]: string; }, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling patchOrgsIDSecrets.');
            }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling patchOrgsIDSecrets.');
            }
            const localVarPath = `/orgs/{orgID}/secrets`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"{ [key: string]: string; }" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete provided secrets
         * @param {string} orgID ID of the organization
         * @param {SecretKeys} secretKeys secret key to deleted
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDSecrets(orgID: string, secretKeys: SecretKeys, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling postOrgsIDSecrets.');
            }
            // verify required parameter 'secretKeys' is not null or undefined
            if (secretKeys === null || secretKeys === undefined) {
                throw new RequiredError('secretKeys','Required parameter secretKeys was null or undefined when calling postOrgsIDSecrets.');
            }
            const localVarPath = `/orgs/{orgID}/secrets/delete`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SecretKeys" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(secretKeys || {}) : (secretKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecretsApi - functional programming interface
 * @export
 */
export const SecretsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all secret keys for an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDSecrets(orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretKeysResponse> {
            const localVarAxiosArgs = SecretsApiAxiosParamCreator(configuration).getOrgsIDSecrets(orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Apply patch to the provided secrets
         * @param {string} orgID ID of the organization
         * @param {{ [key: string]: string; }} requestBody secret key value pairs to update/add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgsIDSecrets(orgID: string, requestBody: { [key: string]: string; }, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SecretsApiAxiosParamCreator(configuration).patchOrgsIDSecrets(orgID, requestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete provided secrets
         * @param {string} orgID ID of the organization
         * @param {SecretKeys} secretKeys secret key to deleted
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDSecrets(orgID: string, secretKeys: SecretKeys, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SecretsApiAxiosParamCreator(configuration).postOrgsIDSecrets(orgID, secretKeys, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * SecretsApi - factory interface
 * @export
 */
export const SecretsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary List all secret keys for an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDSecrets(orgID: string, zapTraceSpan?: string, options?: any) {
            return SecretsApiFp(configuration).getOrgsIDSecrets(orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Apply patch to the provided secrets
         * @param {string} orgID ID of the organization
         * @param {{ [key: string]: string; }} requestBody secret key value pairs to update/add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgsIDSecrets(orgID: string, requestBody: { [key: string]: string; }, zapTraceSpan?: string, options?: any) {
            return SecretsApiFp(configuration).patchOrgsIDSecrets(orgID, requestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete provided secrets
         * @param {string} orgID ID of the organization
         * @param {SecretKeys} secretKeys secret key to deleted
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDSecrets(orgID: string, secretKeys: SecretKeys, zapTraceSpan?: string, options?: any) {
            return SecretsApiFp(configuration).postOrgsIDSecrets(orgID, secretKeys, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * SecretsApi - object-oriented interface
 * @export
 * @class SecretsApi
 * @extends {BaseAPI}
 */
export class SecretsApi extends BaseAPI {
    /**
     * 
     * @summary List all secret keys for an organization
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public getOrgsIDSecrets(orgID: string, zapTraceSpan?: string, options?: any) {
        return SecretsApiFp(this.configuration).getOrgsIDSecrets(orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Apply patch to the provided secrets
     * @param {string} orgID ID of the organization
     * @param {{ [key: string]: string; }} requestBody secret key value pairs to update/add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public patchOrgsIDSecrets(orgID: string, requestBody: { [key: string]: string; }, zapTraceSpan?: string, options?: any) {
        return SecretsApiFp(this.configuration).patchOrgsIDSecrets(orgID, requestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete provided secrets
     * @param {string} orgID ID of the organization
     * @param {SecretKeys} secretKeys secret key to deleted
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public postOrgsIDSecrets(orgID: string, secretKeys: SecretKeys, zapTraceSpan?: string, options?: any) {
        return SecretsApiFp(this.configuration).postOrgsIDSecrets(orgID, secretKeys, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * SetupApi - axios parameter creator
 * @export
 */
export const SetupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary check if database has default user, org, bucket created, returns true if not.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetup(zapTraceSpan?: string, options: any = {}): RequestArgs {
            const localVarPath = `/setup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary post onboarding request, to setup initial user, org and bucket
         * @param {OnboardingRequest} onboardingRequest source to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSetup(onboardingRequest: OnboardingRequest, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'onboardingRequest' is not null or undefined
            if (onboardingRequest === null || onboardingRequest === undefined) {
                throw new RequiredError('onboardingRequest','Required parameter onboardingRequest was null or undefined when calling postSetup.');
            }
            const localVarPath = `/setup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OnboardingRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(onboardingRequest || {}) : (onboardingRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetupApi - functional programming interface
 * @export
 */
export const SetupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary check if database has default user, org, bucket created, returns true if not.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetup(zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsOnboarding> {
            const localVarAxiosArgs = SetupApiAxiosParamCreator(configuration).getSetup(zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary post onboarding request, to setup initial user, org and bucket
         * @param {OnboardingRequest} onboardingRequest source to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSetup(onboardingRequest: OnboardingRequest, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnboardingResponse> {
            const localVarAxiosArgs = SetupApiAxiosParamCreator(configuration).postSetup(onboardingRequest, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * SetupApi - factory interface
 * @export
 */
export const SetupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary check if database has default user, org, bucket created, returns true if not.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetup(zapTraceSpan?: string, options?: any) {
            return SetupApiFp(configuration).getSetup(zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary post onboarding request, to setup initial user, org and bucket
         * @param {OnboardingRequest} onboardingRequest source to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSetup(onboardingRequest: OnboardingRequest, zapTraceSpan?: string, options?: any) {
            return SetupApiFp(configuration).postSetup(onboardingRequest, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * SetupApi - object-oriented interface
 * @export
 * @class SetupApi
 * @extends {BaseAPI}
 */
export class SetupApi extends BaseAPI {
    /**
     * 
     * @summary check if database has default user, org, bucket created, returns true if not.
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public getSetup(zapTraceSpan?: string, options?: any) {
        return SetupApiFp(this.configuration).getSetup(zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary post onboarding request, to setup initial user, org and bucket
     * @param {OnboardingRequest} onboardingRequest source to create
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public postSetup(onboardingRequest: OnboardingRequest, zapTraceSpan?: string, options?: any) {
        return SetupApiFp(this.configuration).postSetup(onboardingRequest, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * SourcesApi - axios parameter creator
 * @export
 */
export const SourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a source
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourcesID(sourceID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling deleteSourcesID.');
            }
            const localVarPath = `/sources/{sourceID}`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all sources
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSources(zapTraceSpan?: string, org?: string, options: any = {}): RequestArgs {
            const localVarPath = `/sources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a source
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesID(sourceID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling getSourcesID.');
            }
            const localVarPath = `/sources/{sourceID}`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesIDBuckets(sourceID: string, zapTraceSpan?: string, org?: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling getSourcesIDBuckets.');
            }
            const localVarPath = `/sources/{sourceID}/buckets`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sources health
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesIDHealth(sourceID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling getSourcesIDHealth.');
            }
            const localVarPath = `/sources/{sourceID}/health`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Source
         * @param {string} sourceID ID of the source
         * @param {Source} source source update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSourcesID(sourceID: string, source: Source, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'sourceID' is not null or undefined
            if (sourceID === null || sourceID === undefined) {
                throw new RequiredError('sourceID','Required parameter sourceID was null or undefined when calling patchSourcesID.');
            }
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling patchSourcesID.');
            }
            const localVarPath = `/sources/{sourceID}`
                .replace(`{${"sourceID"}}`, encodeURIComponent(String(sourceID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Source" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(source || {}) : (source || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a Source
         * @param {Source} source source to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSources(source: Source, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling postSources.');
            }
            const localVarPath = `/sources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Source" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(source || {}) : (source || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesApi - functional programming interface
 * @export
 */
export const SourcesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a source
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourcesID(sourceID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).deleteSourcesID(sourceID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get all sources
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSources(zapTraceSpan?: string, org?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sources> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).getSources(zapTraceSpan, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a source
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesID(sourceID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).getSourcesID(sourceID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesIDBuckets(sourceID: string, zapTraceSpan?: string, org?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Buckets> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).getSourcesIDBuckets(sourceID, zapTraceSpan, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a sources health
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesIDHealth(sourceID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Check> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).getSourcesIDHealth(sourceID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Updates a Source
         * @param {string} sourceID ID of the source
         * @param {Source} source source update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSourcesID(sourceID: string, source: Source, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).patchSourcesID(sourceID, source, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Creates a Source
         * @param {Source} source source to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSources(source: Source, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).postSources(source, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * SourcesApi - factory interface
 * @export
 */
export const SourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a source
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourcesID(sourceID: string, zapTraceSpan?: string, options?: any) {
            return SourcesApiFp(configuration).deleteSourcesID(sourceID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get all sources
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSources(zapTraceSpan?: string, org?: string, options?: any) {
            return SourcesApiFp(configuration).getSources(zapTraceSpan, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a source
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesID(sourceID: string, zapTraceSpan?: string, options?: any) {
            return SourcesApiFp(configuration).getSourcesID(sourceID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesIDBuckets(sourceID: string, zapTraceSpan?: string, org?: string, options?: any) {
            return SourcesApiFp(configuration).getSourcesIDBuckets(sourceID, zapTraceSpan, org, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a sources health
         * @param {string} sourceID ID of the source
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesIDHealth(sourceID: string, zapTraceSpan?: string, options?: any) {
            return SourcesApiFp(configuration).getSourcesIDHealth(sourceID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Updates a Source
         * @param {string} sourceID ID of the source
         * @param {Source} source source update
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSourcesID(sourceID: string, source: Source, zapTraceSpan?: string, options?: any) {
            return SourcesApiFp(configuration).patchSourcesID(sourceID, source, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Creates a Source
         * @param {Source} source source to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSources(source: Source, zapTraceSpan?: string, options?: any) {
            return SourcesApiFp(configuration).postSources(source, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
export class SourcesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a source
     * @param {string} sourceID ID of the source
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteSourcesID(sourceID: string, zapTraceSpan?: string, options?: any) {
        return SourcesApiFp(this.configuration).deleteSourcesID(sourceID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get all sources
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [org] specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSources(zapTraceSpan?: string, org?: string, options?: any) {
        return SourcesApiFp(this.configuration).getSources(zapTraceSpan, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a source
     * @param {string} sourceID ID of the source
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourcesID(sourceID: string, zapTraceSpan?: string, options?: any) {
        return SourcesApiFp(this.configuration).getSourcesID(sourceID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a sources buckets (will return dbrps in the form of buckets if it is a v1 source)
     * @param {string} sourceID ID of the source
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [org] specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourcesIDBuckets(sourceID: string, zapTraceSpan?: string, org?: string, options?: any) {
        return SourcesApiFp(this.configuration).getSourcesIDBuckets(sourceID, zapTraceSpan, org, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a sources health
     * @param {string} sourceID ID of the source
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourcesIDHealth(sourceID: string, zapTraceSpan?: string, options?: any) {
        return SourcesApiFp(this.configuration).getSourcesIDHealth(sourceID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Updates a Source
     * @param {string} sourceID ID of the source
     * @param {Source} source source update
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public patchSourcesID(sourceID: string, source: Source, zapTraceSpan?: string, options?: any) {
        return SourcesApiFp(this.configuration).patchSourcesID(sourceID, source, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Creates a Source
     * @param {Source} source source to create
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public postSources(source: Source, zapTraceSpan?: string, options?: any) {
        return SourcesApiFp(this.configuration).postSources(source, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a task and all associated records
         * @summary Delete a task
         * @param {string} taskID ID of task to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksID(taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling deleteTasksID.');
            }
            const localVarPath = `/tasks/{taskID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a task
         * @param {string} taskID ID of the task
         * @param {string} labelID the label id
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDLabelsID(taskID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling deleteTasksIDLabelsID.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling deleteTasksIDLabelsID.');
            }
            const localVarPath = `/tasks/{taskID}/labels/{labelID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDMembersID(userID: string, taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteTasksIDMembersID.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling deleteTasksIDMembersID.');
            }
            const localVarPath = `/tasks/{taskID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDOwnersID(userID: string, taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteTasksIDOwnersID.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling deleteTasksIDOwnersID.');
            }
            const localVarPath = `/tasks/{taskID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tasks.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [after] returns tasks after specified ID
         * @param {string} [user] filter tasks to a specific user ID
         * @param {string} [org] filter tasks to a specific organization name
         * @param {string} [orgID] filter tasks to a specific organization ID
         * @param {number} [limit] the number of tasks to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(zapTraceSpan?: string, after?: string, user?: string, org?: string, orgID?: string, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/tasks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (orgID !== undefined) {
                localVarQueryParameter['orgID'] = orgID;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an task
         * @param {string} taskID ID of task to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksID(taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling getTasksID.');
            }
            const localVarPath = `/tasks/{taskID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a task
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDLabels(taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling getTasksIDLabels.');
            }
            const localVarPath = `/tasks/{taskID}/labels`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all logs for a task
         * @param {string} taskID ID of task to get logs for
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDLogs(taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling getTasksIDLogs.');
            }
            const localVarPath = `/tasks/{taskID}/logs`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDMembers(taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling getTasksIDMembers.');
            }
            const localVarPath = `/tasks/{taskID}/members`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDOwners(taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling getTasksIDOwners.');
            }
            const localVarPath = `/tasks/{taskID}/owners`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve list of run records for a task
         * @param {string} taskID ID of task to get runs for
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [after] returns runs after specified ID
         * @param {number} [limit] the number of runs to return
         * @param {Date} [afterTime] filter runs to those scheduled after this time, RFC3339
         * @param {Date} [beforeTime] filter runs to those scheduled before this time, RFC3339
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDRuns(taskID: string, zapTraceSpan?: string, after?: string, limit?: number, afterTime?: Date, beforeTime?: Date, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling getTasksIDRuns.');
            }
            const localVarPath = `/tasks/{taskID}/runs`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (afterTime !== undefined) {
                localVarQueryParameter['afterTime'] = (afterTime as any).toISOString();
            }

            if (beforeTime !== undefined) {
                localVarQueryParameter['beforeTime'] = (beforeTime as any).toISOString();
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a single run record for a task
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDRunsID(taskID: string, runID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling getTasksIDRunsID.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling getTasksIDRunsID.');
            }
            const localVarPath = `/tasks/{taskID}/runs/{runID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all logs for a run
         * @param {string} taskID ID of task to get logs for.
         * @param {string} runID ID of run to get logs for.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDRunsIDLogs(taskID: string, runID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling getTasksIDRunsIDLogs.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling getTasksIDRunsIDLogs.');
            }
            const localVarPath = `/tasks/{taskID}/runs/{runID}/logs`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a task. This will cancel all queued runs.
         * @summary Update a task
         * @param {string} taskID ID of task to get
         * @param {TaskUpdateRequest} taskUpdateRequest task update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTasksID(taskID: string, taskUpdateRequest: TaskUpdateRequest, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling patchTasksID.');
            }
            // verify required parameter 'taskUpdateRequest' is not null or undefined
            if (taskUpdateRequest === null || taskUpdateRequest === undefined) {
                throw new RequiredError('taskUpdateRequest','Required parameter taskUpdateRequest was null or undefined when calling patchTasksID.');
            }
            const localVarPath = `/tasks/{taskID}`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(taskUpdateRequest || {}) : (taskUpdateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new task
         * @param {TaskCreateRequest} taskCreateRequest task to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasks(taskCreateRequest: TaskCreateRequest, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskCreateRequest' is not null or undefined
            if (taskCreateRequest === null || taskCreateRequest === undefined) {
                throw new RequiredError('taskCreateRequest','Required parameter taskCreateRequest was null or undefined when calling postTasks.');
            }
            const localVarPath = `/tasks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(taskCreateRequest || {}) : (taskCreateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a task
         * @param {string} taskID ID of the task
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDLabels(taskID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling postTasksIDLabels.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling postTasksIDLabels.');
            }
            const localVarPath = `/tasks/{taskID}/labels`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDMembers(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling postTasksIDMembers.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postTasksIDMembers.');
            }
            const localVarPath = `/tasks/{taskID}/members`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDOwners(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling postTasksIDOwners.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postTasksIDOwners.');
            }
            const localVarPath = `/tasks/{taskID}/owners`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary manually start a run of the task now overriding the current schedule.
         * @param {string} taskID 
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {RunManually} [runManually] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDRuns(taskID: string, zapTraceSpan?: string, runManually?: RunManually, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling postTasksIDRuns.');
            }
            const localVarPath = `/tasks/{taskID}/runs`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RunManually" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(runManually || {}) : (runManually || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retry a task run
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDRunsIDRetry(taskID: string, runID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling postTasksIDRunsIDRetry.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling postTasksIDRunsIDRetry.');
            }
            const localVarPath = `/tasks/{taskID}/runs/{runID}/retry`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a task and all associated records
         * @summary Delete a task
         * @param {string} taskID ID of task to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksID(taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).deleteTasksID(taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a task
         * @param {string} taskID ID of the task
         * @param {string} labelID the label id
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDLabelsID(taskID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).deleteTasksIDLabelsID(taskID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDMembersID(userID: string, taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).deleteTasksIDMembersID(userID, taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDOwnersID(userID: string, taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).deleteTasksIDOwnersID(userID, taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List tasks.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [after] returns tasks after specified ID
         * @param {string} [user] filter tasks to a specific user ID
         * @param {string} [org] filter tasks to a specific organization name
         * @param {string} [orgID] filter tasks to a specific organization ID
         * @param {number} [limit] the number of tasks to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(zapTraceSpan?: string, after?: string, user?: string, org?: string, orgID?: string, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tasks> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).getTasks(zapTraceSpan, after, user, org, orgID, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve an task
         * @param {string} taskID ID of task to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksID(taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).getTasksID(taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a task
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDLabels(taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).getTasksIDLabels(taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve all logs for a task
         * @param {string} taskID ID of task to get logs for
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDLogs(taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Logs> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).getTasksIDLogs(taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDMembers(taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMembers> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).getTasksIDMembers(taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDOwners(taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).getTasksIDOwners(taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve list of run records for a task
         * @param {string} taskID ID of task to get runs for
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [after] returns runs after specified ID
         * @param {number} [limit] the number of runs to return
         * @param {Date} [afterTime] filter runs to those scheduled after this time, RFC3339
         * @param {Date} [beforeTime] filter runs to those scheduled before this time, RFC3339
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDRuns(taskID: string, zapTraceSpan?: string, after?: string, limit?: number, afterTime?: Date, beforeTime?: Date, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runs> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).getTasksIDRuns(taskID, zapTraceSpan, after, limit, afterTime, beforeTime, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve a single run record for a task
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDRunsID(taskID: string, runID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).getTasksIDRunsID(taskID, runID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve all logs for a run
         * @param {string} taskID ID of task to get logs for.
         * @param {string} runID ID of run to get logs for.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDRunsIDLogs(taskID: string, runID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Logs> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).getTasksIDRunsIDLogs(taskID, runID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Update a task. This will cancel all queued runs.
         * @summary Update a task
         * @param {string} taskID ID of task to get
         * @param {TaskUpdateRequest} taskUpdateRequest task update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTasksID(taskID: string, taskUpdateRequest: TaskUpdateRequest, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).patchTasksID(taskID, taskUpdateRequest, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a new task
         * @param {TaskCreateRequest} taskCreateRequest task to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasks(taskCreateRequest: TaskCreateRequest, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).postTasks(taskCreateRequest, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a task
         * @param {string} taskID ID of the task
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDLabels(taskID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).postTasksIDLabels(taskID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDMembers(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMember> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).postTasksIDMembers(taskID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDOwners(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwner> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).postTasksIDOwners(taskID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary manually start a run of the task now overriding the current schedule.
         * @param {string} taskID 
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {RunManually} [runManually] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDRuns(taskID: string, zapTraceSpan?: string, runManually?: RunManually, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).postTasksIDRuns(taskID, zapTraceSpan, runManually, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retry a task run
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDRunsIDRetry(taskID: string, runID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run> {
            const localVarAxiosArgs = TasksApiAxiosParamCreator(configuration).postTasksIDRunsIDRetry(taskID, runID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes a task and all associated records
         * @summary Delete a task
         * @param {string} taskID ID of task to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksID(taskID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).deleteTasksID(taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a task
         * @param {string} taskID ID of the task
         * @param {string} labelID the label id
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDLabelsID(taskID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).deleteTasksIDLabelsID(taskID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDMembersID(userID: string, taskID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).deleteTasksIDMembersID(userID, taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDOwnersID(userID: string, taskID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).deleteTasksIDOwnersID(userID, taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List tasks.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [after] returns tasks after specified ID
         * @param {string} [user] filter tasks to a specific user ID
         * @param {string} [org] filter tasks to a specific organization name
         * @param {string} [orgID] filter tasks to a specific organization ID
         * @param {number} [limit] the number of tasks to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(zapTraceSpan?: string, after?: string, user?: string, org?: string, orgID?: string, limit?: number, options?: any) {
            return TasksApiFp(configuration).getTasks(zapTraceSpan, after, user, org, orgID, limit, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve an task
         * @param {string} taskID ID of task to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksID(taskID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).getTasksID(taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a task
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDLabels(taskID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).getTasksIDLabels(taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve all logs for a task
         * @param {string} taskID ID of task to get logs for
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDLogs(taskID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).getTasksIDLogs(taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDMembers(taskID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).getTasksIDMembers(taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDOwners(taskID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).getTasksIDOwners(taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve list of run records for a task
         * @param {string} taskID ID of task to get runs for
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [after] returns runs after specified ID
         * @param {number} [limit] the number of runs to return
         * @param {Date} [afterTime] filter runs to those scheduled after this time, RFC3339
         * @param {Date} [beforeTime] filter runs to those scheduled before this time, RFC3339
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDRuns(taskID: string, zapTraceSpan?: string, after?: string, limit?: number, afterTime?: Date, beforeTime?: Date, options?: any) {
            return TasksApiFp(configuration).getTasksIDRuns(taskID, zapTraceSpan, after, limit, afterTime, beforeTime, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve a single run record for a task
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDRunsID(taskID: string, runID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).getTasksIDRunsID(taskID, runID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve all logs for a run
         * @param {string} taskID ID of task to get logs for.
         * @param {string} runID ID of run to get logs for.
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDRunsIDLogs(taskID: string, runID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).getTasksIDRunsIDLogs(taskID, runID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * Update a task. This will cancel all queued runs.
         * @summary Update a task
         * @param {string} taskID ID of task to get
         * @param {TaskUpdateRequest} taskUpdateRequest task update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTasksID(taskID: string, taskUpdateRequest: TaskUpdateRequest, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).patchTasksID(taskID, taskUpdateRequest, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a new task
         * @param {TaskCreateRequest} taskCreateRequest task to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasks(taskCreateRequest: TaskCreateRequest, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).postTasks(taskCreateRequest, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a task
         * @param {string} taskID ID of the task
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDLabels(taskID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).postTasksIDLabels(taskID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDMembers(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).postTasksIDMembers(taskID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDOwners(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).postTasksIDOwners(taskID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary manually start a run of the task now overriding the current schedule.
         * @param {string} taskID 
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {RunManually} [runManually] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDRuns(taskID: string, zapTraceSpan?: string, runManually?: RunManually, options?: any) {
            return TasksApiFp(configuration).postTasksIDRuns(taskID, zapTraceSpan, runManually, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retry a task run
         * @param {string} taskID task ID
         * @param {string} runID run ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDRunsIDRetry(taskID: string, runID: string, zapTraceSpan?: string, options?: any) {
            return TasksApiFp(configuration).postTasksIDRunsIDRetry(taskID, runID, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Deletes a task and all associated records
     * @summary Delete a task
     * @param {string} taskID ID of task to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTasksID(taskID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).deleteTasksID(taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a task
     * @param {string} taskID ID of the task
     * @param {string} labelID the label id
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTasksIDLabelsID(taskID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).deleteTasksIDLabelsID(taskID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an task
     * @param {string} userID ID of member to remove
     * @param {string} taskID ID of the task
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTasksIDMembersID(userID: string, taskID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).deleteTasksIDMembersID(userID, taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an task
     * @param {string} userID ID of owner to remove
     * @param {string} taskID ID of the task
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTasksIDOwnersID(userID: string, taskID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).deleteTasksIDOwnersID(userID, taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List tasks.
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [after] returns tasks after specified ID
     * @param {string} [user] filter tasks to a specific user ID
     * @param {string} [org] filter tasks to a specific organization name
     * @param {string} [orgID] filter tasks to a specific organization ID
     * @param {number} [limit] the number of tasks to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasks(zapTraceSpan?: string, after?: string, user?: string, org?: string, orgID?: string, limit?: number, options?: any) {
        return TasksApiFp(this.configuration).getTasks(zapTraceSpan, after, user, org, orgID, limit, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve an task
     * @param {string} taskID ID of task to get
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksID(taskID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).getTasksID(taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a task
     * @param {string} taskID ID of the task
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksIDLabels(taskID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).getTasksIDLabels(taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve all logs for a task
     * @param {string} taskID ID of task to get logs for
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksIDLogs(taskID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).getTasksIDLogs(taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all task members
     * @param {string} taskID ID of the task
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksIDMembers(taskID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).getTasksIDMembers(taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all task owners
     * @param {string} taskID ID of the task
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksIDOwners(taskID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).getTasksIDOwners(taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve list of run records for a task
     * @param {string} taskID ID of task to get runs for
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [after] returns runs after specified ID
     * @param {number} [limit] the number of runs to return
     * @param {Date} [afterTime] filter runs to those scheduled after this time, RFC3339
     * @param {Date} [beforeTime] filter runs to those scheduled before this time, RFC3339
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksIDRuns(taskID: string, zapTraceSpan?: string, after?: string, limit?: number, afterTime?: Date, beforeTime?: Date, options?: any) {
        return TasksApiFp(this.configuration).getTasksIDRuns(taskID, zapTraceSpan, after, limit, afterTime, beforeTime, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve a single run record for a task
     * @param {string} taskID task ID
     * @param {string} runID run ID
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksIDRunsID(taskID: string, runID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).getTasksIDRunsID(taskID, runID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve all logs for a run
     * @param {string} taskID ID of task to get logs for.
     * @param {string} runID ID of run to get logs for.
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksIDRunsIDLogs(taskID: string, runID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).getTasksIDRunsIDLogs(taskID, runID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * Update a task. This will cancel all queued runs.
     * @summary Update a task
     * @param {string} taskID ID of task to get
     * @param {TaskUpdateRequest} taskUpdateRequest task update to apply
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public patchTasksID(taskID: string, taskUpdateRequest: TaskUpdateRequest, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).patchTasksID(taskID, taskUpdateRequest, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a new task
     * @param {TaskCreateRequest} taskCreateRequest task to create
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public postTasks(taskCreateRequest: TaskCreateRequest, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).postTasks(taskCreateRequest, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a task
     * @param {string} taskID ID of the task
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public postTasksIDLabels(taskID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).postTasksIDLabels(taskID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add task member
     * @param {string} taskID ID of the task
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public postTasksIDMembers(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).postTasksIDMembers(taskID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add task owner
     * @param {string} taskID ID of the task
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public postTasksIDOwners(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).postTasksIDOwners(taskID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary manually start a run of the task now overriding the current schedule.
     * @param {string} taskID 
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {RunManually} [runManually] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public postTasksIDRuns(taskID: string, zapTraceSpan?: string, runManually?: RunManually, options?: any) {
        return TasksApiFp(this.configuration).postTasksIDRuns(taskID, zapTraceSpan, runManually, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retry a task run
     * @param {string} taskID task ID
     * @param {string} runID run ID
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public postTasksIDRunsIDRetry(taskID: string, runID: string, zapTraceSpan?: string, options?: any) {
        return TasksApiFp(this.configuration).postTasksIDRunsIDRetry(taskID, runID, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * TelegrafsApi - axios parameter creator
 * @export
 */
export const TelegrafsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsID(telegrafID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling deleteTelegrafsID.');
            }
            const localVarPath = `/telegrafs/{telegrafID}`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDLabelsID(telegrafID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling deleteTelegrafsIDLabelsID.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling deleteTelegrafsIDLabelsID.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/labels/{labelID}`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDMembersID(userID: string, telegrafID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteTelegrafsIDMembersID.');
            }
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling deleteTelegrafsIDMembersID.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDOwnersID(userID: string, telegrafID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteTelegrafsIDOwnersID.');
            }
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling deleteTelegrafsIDOwnersID.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [orgID] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafs(zapTraceSpan?: string, orgID?: string, options: any = {}): RequestArgs {
            const localVarPath = `/telegrafs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgID !== undefined) {
                localVarQueryParameter['orgID'] = orgID;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'application/toml' | 'application/json' | 'application/octet-stream'} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsID(telegrafID: string, zapTraceSpan?: string, accept?: 'application/toml' | 'application/json' | 'application/octet-stream', options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling getTelegrafsID.');
            }
            const localVarPath = `/telegrafs/{telegrafID}`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDLabels(telegrafID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling getTelegrafsIDLabels.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/labels`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDMembers(telegrafID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling getTelegrafsIDMembers.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDOwners(telegrafID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling getTelegrafsIDOwners.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafs(telegrafRequest: TelegrafRequest, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafRequest' is not null or undefined
            if (telegrafRequest === null || telegrafRequest === undefined) {
                throw new RequiredError('telegrafRequest','Required parameter telegrafRequest was null or undefined when calling postTelegrafs.');
            }
            const localVarPath = `/telegrafs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TelegrafRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(telegrafRequest || {}) : (telegrafRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDLabels(telegrafID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling postTelegrafsIDLabels.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling postTelegrafsIDLabels.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/labels`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDMembers(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling postTelegrafsIDMembers.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postTelegrafsIDMembers.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDOwners(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling postTelegrafsIDOwners.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postTelegrafsIDOwners.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTelegrafsID(telegrafID: string, telegrafRequest: TelegrafRequest, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling putTelegrafsID.');
            }
            // verify required parameter 'telegrafRequest' is not null or undefined
            if (telegrafRequest === null || telegrafRequest === undefined) {
                throw new RequiredError('telegrafRequest','Required parameter telegrafRequest was null or undefined when calling putTelegrafsID.');
            }
            const localVarPath = `/telegrafs/{telegrafID}`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TelegrafRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(telegrafRequest || {}) : (telegrafRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelegrafsApi - functional programming interface
 * @export
 */
export const TelegrafsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsID(telegrafID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).deleteTelegrafsID(telegrafID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDLabelsID(telegrafID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).deleteTelegrafsIDLabelsID(telegrafID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDMembersID(userID: string, telegrafID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).deleteTelegrafsIDMembersID(userID, telegrafID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDOwnersID(userID: string, telegrafID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).deleteTelegrafsIDOwnersID(userID, telegrafID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [orgID] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafs(zapTraceSpan?: string, orgID?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telegrafs> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).getTelegrafs(zapTraceSpan, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'application/toml' | 'application/json' | 'application/octet-stream'} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsID(telegrafID: string, zapTraceSpan?: string, accept?: 'application/toml' | 'application/json' | 'application/octet-stream', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).getTelegrafsID(telegrafID, zapTraceSpan, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDLabels(telegrafID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).getTelegrafsIDLabels(telegrafID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDMembers(telegrafID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMembers> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).getTelegrafsIDMembers(telegrafID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDOwners(telegrafID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).getTelegrafsIDOwners(telegrafID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafs(telegrafRequest: TelegrafRequest, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telegraf> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).postTelegrafs(telegrafRequest, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDLabels(telegrafID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).postTelegrafsIDLabels(telegrafID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDMembers(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMember> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).postTelegrafsIDMembers(telegrafID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDOwners(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwner> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).postTelegrafsIDOwners(telegrafID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTelegrafsID(telegrafID: string, telegrafRequest: TelegrafRequest, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telegraf> {
            const localVarAxiosArgs = TelegrafsApiAxiosParamCreator(configuration).putTelegrafsID(telegrafID, telegrafRequest, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * TelegrafsApi - factory interface
 * @export
 */
export const TelegrafsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary delete a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsID(telegrafID: string, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).deleteTelegrafsID(telegrafID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDLabelsID(telegrafID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).deleteTelegrafsIDLabelsID(telegrafID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDMembersID(userID: string, telegrafID: string, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).deleteTelegrafsIDMembersID(userID, telegrafID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDOwnersID(userID: string, telegrafID: string, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).deleteTelegrafsIDOwnersID(userID, telegrafID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [orgID] specifies the organization of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafs(zapTraceSpan?: string, orgID?: string, options?: any) {
            return TelegrafsApiFp(configuration).getTelegrafs(zapTraceSpan, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'application/toml' | 'application/json' | 'application/octet-stream'} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsID(telegrafID: string, zapTraceSpan?: string, accept?: 'application/toml' | 'application/json' | 'application/octet-stream', options?: any) {
            return TelegrafsApiFp(configuration).getTelegrafsID(telegrafID, zapTraceSpan, accept, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDLabels(telegrafID: string, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).getTelegrafsIDLabels(telegrafID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDMembers(telegrafID: string, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).getTelegrafsIDMembers(telegrafID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDOwners(telegrafID: string, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).getTelegrafsIDOwners(telegrafID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafs(telegrafRequest: TelegrafRequest, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).postTelegrafs(telegrafRequest, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDLabels(telegrafID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).postTelegrafsIDLabels(telegrafID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDMembers(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).postTelegrafsIDMembers(telegrafID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDOwners(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).postTelegrafsIDOwners(telegrafID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a telegraf config
         * @param {string} telegrafID ID of telegraf config
         * @param {TelegrafRequest} telegrafRequest telegraf config update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTelegrafsID(telegrafID: string, telegrafRequest: TelegrafRequest, zapTraceSpan?: string, options?: any) {
            return TelegrafsApiFp(configuration).putTelegrafsID(telegrafID, telegrafRequest, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * TelegrafsApi - object-oriented interface
 * @export
 * @class TelegrafsApi
 * @extends {BaseAPI}
 */
export class TelegrafsApi extends BaseAPI {
    /**
     * 
     * @summary delete a telegraf config
     * @param {string} telegrafID ID of telegraf config
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public deleteTelegrafsID(telegrafID: string, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).deleteTelegrafsID(telegrafID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {string} labelID the label ID
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public deleteTelegrafsIDLabelsID(telegrafID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).deleteTelegrafsIDLabelsID(telegrafID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from a telegraf config
     * @param {string} userID ID of member to remove
     * @param {string} telegrafID ID of the telegraf
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public deleteTelegrafsIDMembersID(userID: string, telegrafID: string, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).deleteTelegrafsIDMembersID(userID, telegrafID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a telegraf config
     * @param {string} userID ID of owner to remove
     * @param {string} telegrafID ID of the telegraf config
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public deleteTelegrafsIDOwnersID(userID: string, telegrafID: string, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).deleteTelegrafsIDOwnersID(userID, telegrafID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [orgID] specifies the organization of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public getTelegrafs(zapTraceSpan?: string, orgID?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).getTelegrafs(zapTraceSpan, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve a telegraf config
     * @param {string} telegrafID ID of telegraf config
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {'application/toml' | 'application/json' | 'application/octet-stream'} [accept] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public getTelegrafsID(telegrafID: string, zapTraceSpan?: string, accept?: 'application/toml' | 'application/json' | 'application/octet-stream', options?: any) {
        return TelegrafsApiFp(this.configuration).getTelegrafsID(telegrafID, zapTraceSpan, accept, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public getTelegrafsIDLabels(telegrafID: string, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).getTelegrafsIDLabels(telegrafID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users with member privileges for a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public getTelegrafsIDMembers(telegrafID: string, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).getTelegrafsIDMembers(telegrafID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public getTelegrafsIDOwners(telegrafID: string, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).getTelegrafsIDOwners(telegrafID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a telegraf config
     * @param {TelegrafRequest} telegrafRequest telegraf config to create
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public postTelegrafs(telegrafRequest: TelegrafRequest, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).postTelegrafs(telegrafRequest, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public postTelegrafsIDLabels(telegrafID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).postTelegrafsIDLabels(telegrafID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add telegraf config member
     * @param {string} telegrafID ID of the telegraf config
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public postTelegrafsIDMembers(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).postTelegrafsIDMembers(telegrafID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add telegraf config owner
     * @param {string} telegrafID ID of the telegraf config
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public postTelegrafsIDOwners(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).postTelegrafsIDOwners(telegrafID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a telegraf config
     * @param {string} telegrafID ID of telegraf config
     * @param {TelegrafRequest} telegrafRequest telegraf config update to apply
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelegrafsApi
     */
    public putTelegrafsID(telegrafID: string, telegrafRequest: TelegrafRequest, zapTraceSpan?: string, options?: any) {
        return TelegrafsApiFp(this.configuration).putTelegrafsID(telegrafID, telegrafRequest, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete a template document
         * @param {string} templateID ID of template
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentsTemplatesID(templateID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'templateID' is not null or undefined
            if (templateID === null || templateID === undefined) {
                throw new RequiredError('templateID','Required parameter templateID was null or undefined when calling deleteDocumentsTemplatesID.');
            }
            const localVarPath = `/documents/templates/{templateID}`
                .replace(`{${"templateID"}}`, encodeURIComponent(String(templateID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a template
         * @param {string} templateID ID of template
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentsTemplatesIDLabelsID(templateID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'templateID' is not null or undefined
            if (templateID === null || templateID === undefined) {
                throw new RequiredError('templateID','Required parameter templateID was null or undefined when calling deleteDocumentsTemplatesIDLabelsID.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling deleteDocumentsTemplatesIDLabelsID.');
            }
            const localVarPath = `/documents/templates/{templateID}/labels/{labelID}`
                .replace(`{${"templateID"}}`, encodeURIComponent(String(templateID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the name of the organization of the template
         * @param {string} [orgID] specifies the organization id of the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentsTemplates(zapTraceSpan?: string, org?: string, orgID?: string, options: any = {}): RequestArgs {
            const localVarPath = `/documents/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (orgID !== undefined) {
                localVarQueryParameter['orgID'] = orgID;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateID ID of template
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentsTemplatesID(templateID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'templateID' is not null or undefined
            if (templateID === null || templateID === undefined) {
                throw new RequiredError('templateID','Required parameter templateID was null or undefined when calling getDocumentsTemplatesID.');
            }
            const localVarPath = `/documents/templates/{templateID}`
                .replace(`{${"templateID"}}`, encodeURIComponent(String(templateID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a template
         * @param {string} templateID ID of template
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentsTemplatesIDLabels(templateID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'templateID' is not null or undefined
            if (templateID === null || templateID === undefined) {
                throw new RequiredError('templateID','Required parameter templateID was null or undefined when calling getDocumentsTemplatesIDLabels.');
            }
            const localVarPath = `/documents/templates/{templateID}/labels`
                .replace(`{${"templateID"}}`, encodeURIComponent(String(templateID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a template
         * @param {DocumentCreate} documentCreate template that will be created
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDocumentsTemplates(documentCreate: DocumentCreate, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'documentCreate' is not null or undefined
            if (documentCreate === null || documentCreate === undefined) {
                throw new RequiredError('documentCreate','Required parameter documentCreate was null or undefined when calling postDocumentsTemplates.');
            }
            const localVarPath = `/documents/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(documentCreate || {}) : (documentCreate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a template
         * @param {string} templateID ID of template
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDocumentsTemplatesIDLabels(templateID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'templateID' is not null or undefined
            if (templateID === null || templateID === undefined) {
                throw new RequiredError('templateID','Required parameter templateID was null or undefined when calling postDocumentsTemplatesIDLabels.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling postDocumentsTemplatesIDLabels.');
            }
            const localVarPath = `/documents/templates/{templateID}/labels`
                .replace(`{${"templateID"}}`, encodeURIComponent(String(templateID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateID ID of template
         * @param {DocumentUpdate} documentUpdate template that will be updated
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDocumentsTemplatesID(templateID: string, documentUpdate: DocumentUpdate, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'templateID' is not null or undefined
            if (templateID === null || templateID === undefined) {
                throw new RequiredError('templateID','Required parameter templateID was null or undefined when calling putDocumentsTemplatesID.');
            }
            // verify required parameter 'documentUpdate' is not null or undefined
            if (documentUpdate === null || documentUpdate === undefined) {
                throw new RequiredError('documentUpdate','Required parameter documentUpdate was null or undefined when calling putDocumentsTemplatesID.');
            }
            const localVarPath = `/documents/templates/{templateID}`
                .replace(`{${"templateID"}}`, encodeURIComponent(String(templateID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(documentUpdate || {}) : (documentUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete a template document
         * @param {string} templateID ID of template
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentsTemplatesID(templateID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TemplatesApiAxiosParamCreator(configuration).deleteDocumentsTemplatesID(templateID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a template
         * @param {string} templateID ID of template
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentsTemplatesIDLabelsID(templateID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TemplatesApiAxiosParamCreator(configuration).deleteDocumentsTemplatesIDLabelsID(templateID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the name of the organization of the template
         * @param {string} [orgID] specifies the organization id of the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentsTemplates(zapTraceSpan?: string, org?: string, orgID?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Documents> {
            const localVarAxiosArgs = TemplatesApiAxiosParamCreator(configuration).getDocumentsTemplates(zapTraceSpan, org, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} templateID ID of template
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentsTemplatesID(templateID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document> {
            const localVarAxiosArgs = TemplatesApiAxiosParamCreator(configuration).getDocumentsTemplatesID(templateID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a template
         * @param {string} templateID ID of template
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentsTemplatesIDLabels(templateID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = TemplatesApiAxiosParamCreator(configuration).getDocumentsTemplatesIDLabels(templateID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a template
         * @param {DocumentCreate} documentCreate template that will be created
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDocumentsTemplates(documentCreate: DocumentCreate, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document> {
            const localVarAxiosArgs = TemplatesApiAxiosParamCreator(configuration).postDocumentsTemplates(documentCreate, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a template
         * @param {string} templateID ID of template
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDocumentsTemplatesIDLabels(templateID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = TemplatesApiAxiosParamCreator(configuration).postDocumentsTemplatesIDLabels(templateID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} templateID ID of template
         * @param {DocumentUpdate} documentUpdate template that will be updated
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDocumentsTemplatesID(templateID: string, documentUpdate: DocumentUpdate, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document> {
            const localVarAxiosArgs = TemplatesApiAxiosParamCreator(configuration).putDocumentsTemplatesID(templateID, documentUpdate, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary delete a template document
         * @param {string} templateID ID of template
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentsTemplatesID(templateID: string, zapTraceSpan?: string, options?: any) {
            return TemplatesApiFp(configuration).deleteDocumentsTemplatesID(templateID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a template
         * @param {string} templateID ID of template
         * @param {string} labelID the label ID
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentsTemplatesIDLabelsID(templateID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return TemplatesApiFp(configuration).deleteDocumentsTemplatesIDLabelsID(templateID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the name of the organization of the template
         * @param {string} [orgID] specifies the organization id of the template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentsTemplates(zapTraceSpan?: string, org?: string, orgID?: string, options?: any) {
            return TemplatesApiFp(configuration).getDocumentsTemplates(zapTraceSpan, org, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} templateID ID of template
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentsTemplatesID(templateID: string, zapTraceSpan?: string, options?: any) {
            return TemplatesApiFp(configuration).getDocumentsTemplatesID(templateID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a template
         * @param {string} templateID ID of template
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentsTemplatesIDLabels(templateID: string, zapTraceSpan?: string, options?: any) {
            return TemplatesApiFp(configuration).getDocumentsTemplatesIDLabels(templateID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a template
         * @param {DocumentCreate} documentCreate template that will be created
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDocumentsTemplates(documentCreate: DocumentCreate, zapTraceSpan?: string, options?: any) {
            return TemplatesApiFp(configuration).postDocumentsTemplates(documentCreate, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a template
         * @param {string} templateID ID of template
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDocumentsTemplatesIDLabels(templateID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return TemplatesApiFp(configuration).postDocumentsTemplatesIDLabels(templateID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} templateID ID of template
         * @param {DocumentUpdate} documentUpdate template that will be updated
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDocumentsTemplatesID(templateID: string, documentUpdate: DocumentUpdate, zapTraceSpan?: string, options?: any) {
            return TemplatesApiFp(configuration).putDocumentsTemplatesID(templateID, documentUpdate, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @summary delete a template document
     * @param {string} templateID ID of template
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public deleteDocumentsTemplatesID(templateID: string, zapTraceSpan?: string, options?: any) {
        return TemplatesApiFp(this.configuration).deleteDocumentsTemplatesID(templateID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a template
     * @param {string} templateID ID of template
     * @param {string} labelID the label ID
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public deleteDocumentsTemplatesIDLabelsID(templateID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return TemplatesApiFp(this.configuration).deleteDocumentsTemplatesIDLabelsID(templateID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [org] specifies the name of the organization of the template
     * @param {string} [orgID] specifies the organization id of the template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getDocumentsTemplates(zapTraceSpan?: string, org?: string, orgID?: string, options?: any) {
        return TemplatesApiFp(this.configuration).getDocumentsTemplates(zapTraceSpan, org, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} templateID ID of template
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getDocumentsTemplatesID(templateID: string, zapTraceSpan?: string, options?: any) {
        return TemplatesApiFp(this.configuration).getDocumentsTemplatesID(templateID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a template
     * @param {string} templateID ID of template
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getDocumentsTemplatesIDLabels(templateID: string, zapTraceSpan?: string, options?: any) {
        return TemplatesApiFp(this.configuration).getDocumentsTemplatesIDLabels(templateID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a template
     * @param {DocumentCreate} documentCreate template that will be created
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public postDocumentsTemplates(documentCreate: DocumentCreate, zapTraceSpan?: string, options?: any) {
        return TemplatesApiFp(this.configuration).postDocumentsTemplates(documentCreate, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a template
     * @param {string} templateID ID of template
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public postDocumentsTemplatesIDLabels(templateID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return TemplatesApiFp(this.configuration).postDocumentsTemplatesIDLabels(templateID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} templateID ID of template
     * @param {DocumentUpdate} documentUpdate template that will be updated
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public putDocumentsTemplatesID(templateID: string, documentUpdate: DocumentUpdate, zapTraceSpan?: string, options?: any) {
        return TemplatesApiFp(this.configuration).putDocumentsTemplatesID(templateID, documentUpdate, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDMembersID(userID: string, bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteBucketsIDMembersID.');
            }
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling deleteBucketsIDMembersID.');
            }
            const localVarPath = `/buckets/{bucketID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDOwnersID(userID: string, bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteBucketsIDOwnersID.');
            }
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling deleteBucketsIDOwnersID.');
            }
            const localVarPath = `/buckets/{bucketID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDMembersID(userID: string, dashboardID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteDashboardsIDMembersID.');
            }
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling deleteDashboardsIDMembersID.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDOwnersID(userID: string, dashboardID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteDashboardsIDOwnersID.');
            }
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling deleteDashboardsIDOwnersID.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDMembersID(userID: string, orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteOrgsIDMembersID.');
            }
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling deleteOrgsIDMembersID.');
            }
            const localVarPath = `/orgs/{orgID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDOwnersID(userID: string, orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteOrgsIDOwnersID.');
            }
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling deleteOrgsIDOwnersID.');
            }
            const localVarPath = `/orgs/{orgID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from a scraper target
         * @param {string} userID ID of member to remove
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDMembersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteScrapersIDMembersID.');
            }
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling deleteScrapersIDMembersID.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a scraper target
         * @param {string} userID ID of owner to remove
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDOwnersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteScrapersIDOwnersID.');
            }
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling deleteScrapersIDOwnersID.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDMembersID(userID: string, taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteTasksIDMembersID.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling deleteTasksIDMembersID.');
            }
            const localVarPath = `/tasks/{taskID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDOwnersID(userID: string, taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteTasksIDOwnersID.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling deleteTasksIDOwnersID.');
            }
            const localVarPath = `/tasks/{taskID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDMembersID(userID: string, telegrafID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteTelegrafsIDMembersID.');
            }
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling deleteTelegrafsIDMembersID.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDOwnersID(userID: string, telegrafID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteTelegrafsIDOwnersID.');
            }
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling deleteTelegrafsIDOwnersID.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletes a user
         * @param {string} userID ID of user to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersID(userID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling deleteUsersID.');
            }
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDMembers(bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling getBucketsIDMembers.');
            }
            const localVarPath = `/buckets/{bucketID}/members`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDOwners(bucketID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling getBucketsIDOwners.');
            }
            const localVarPath = `/buckets/{bucketID}/owners`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDMembers(dashboardID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling getDashboardsIDMembers.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDOwners(dashboardID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling getDashboardsIDOwners.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns currently authenticated user
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(zapTraceSpan?: string, options: any = {}): RequestArgs {
            const localVarPath = `/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDMembers(orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling getOrgsIDMembers.');
            }
            const localVarPath = `/orgs/{orgID}/members`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDOwners(orgID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling getOrgsIDOwners.');
            }
            const localVarPath = `/orgs/{orgID}/owners`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDMembers(scraperTargetID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling getScrapersIDMembers.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/members`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDOwners(scraperTargetID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling getScrapersIDOwners.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/owners`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDMembers(taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling getTasksIDMembers.');
            }
            const localVarPath = `/tasks/{taskID}/members`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDOwners(taskID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling getTasksIDOwners.');
            }
            const localVarPath = `/tasks/{taskID}/owners`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDMembers(telegrafID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling getTelegrafsIDMembers.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDOwners(telegrafID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling getTelegrafsIDOwners.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(zapTraceSpan?: string, options: any = {}): RequestArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a user
         * @param {string} userID ID of user to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersID(userID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling getUsersID.');
            }
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for a user
         * @param {string} userID ID of the user
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersIDLogs(userID: string, zapTraceSpan?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling getUsersIDLogs.');
            }
            const localVarPath = `/users/{userID}/logs`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {string} userID ID of user to update
         * @param {User} user user update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUsersID(userID: string, user: User, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling patchUsersID.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling patchUsersID.');
            }
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDMembers(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling postBucketsIDMembers.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postBucketsIDMembers.');
            }
            const localVarPath = `/buckets/{bucketID}/members`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDOwners(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'bucketID' is not null or undefined
            if (bucketID === null || bucketID === undefined) {
                throw new RequiredError('bucketID','Required parameter bucketID was null or undefined when calling postBucketsIDOwners.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postBucketsIDOwners.');
            }
            const localVarPath = `/buckets/{bucketID}/owners`
                .replace(`{${"bucketID"}}`, encodeURIComponent(String(bucketID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDMembers(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling postDashboardsIDMembers.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postDashboardsIDMembers.');
            }
            const localVarPath = `/dashboards/{dashboardID}/members`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDOwners(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling postDashboardsIDOwners.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postDashboardsIDOwners.');
            }
            const localVarPath = `/dashboards/{dashboardID}/owners`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDMembers(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling postOrgsIDMembers.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postOrgsIDMembers.');
            }
            const localVarPath = `/orgs/{orgID}/members`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDOwners(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'orgID' is not null or undefined
            if (orgID === null || orgID === undefined) {
                throw new RequiredError('orgID','Required parameter orgID was null or undefined when calling postOrgsIDOwners.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postOrgsIDOwners.');
            }
            const localVarPath = `/orgs/{orgID}/owners`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add scraper target member
         * @param {string} scraperTargetID ID of the scraper target
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDMembers(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling postScrapersIDMembers.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postScrapersIDMembers.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/members`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add scraper target owner
         * @param {string} scraperTargetID ID of the scraper target
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDOwners(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'scraperTargetID' is not null or undefined
            if (scraperTargetID === null || scraperTargetID === undefined) {
                throw new RequiredError('scraperTargetID','Required parameter scraperTargetID was null or undefined when calling postScrapersIDOwners.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postScrapersIDOwners.');
            }
            const localVarPath = `/scrapers/{scraperTargetID}/owners`
                .replace(`{${"scraperTargetID"}}`, encodeURIComponent(String(scraperTargetID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDMembers(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling postTasksIDMembers.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postTasksIDMembers.');
            }
            const localVarPath = `/tasks/{taskID}/members`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDOwners(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling postTasksIDOwners.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postTasksIDOwners.');
            }
            const localVarPath = `/tasks/{taskID}/owners`
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDMembers(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling postTelegrafsIDMembers.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postTelegrafsIDMembers.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/members`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDOwners(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'telegrafID' is not null or undefined
            if (telegrafID === null || telegrafID === undefined) {
                throw new RequiredError('telegrafID','Required parameter telegrafID was null or undefined when calling postTelegrafsIDOwners.');
            }
            // verify required parameter 'addResourceMemberRequestBody' is not null or undefined
            if (addResourceMemberRequestBody === null || addResourceMemberRequestBody === undefined) {
                throw new RequiredError('addResourceMemberRequestBody','Required parameter addResourceMemberRequestBody was null or undefined when calling postTelegrafsIDOwners.');
            }
            const localVarPath = `/telegrafs/{telegrafID}/owners`
                .replace(`{${"telegrafID"}}`, encodeURIComponent(String(telegrafID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddResourceMemberRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addResourceMemberRequestBody || {}) : (addResourceMemberRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a user
         * @param {User} user user to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(user: User, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling postUsers.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update password
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMePassword(passwordResetBody: PasswordResetBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'passwordResetBody' is not null or undefined
            if (passwordResetBody === null || passwordResetBody === undefined) {
                throw new RequiredError('passwordResetBody','Required parameter passwordResetBody was null or undefined when calling putMePassword.');
            }
            const localVarPath = `/me/password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordResetBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(passwordResetBody || {}) : (passwordResetBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update password
         * @param {string} userID ID of the user
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersIDPassword(userID: string, passwordResetBody: PasswordResetBody, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID','Required parameter userID was null or undefined when calling putUsersIDPassword.');
            }
            // verify required parameter 'passwordResetBody' is not null or undefined
            if (passwordResetBody === null || passwordResetBody === undefined) {
                throw new RequiredError('passwordResetBody','Required parameter passwordResetBody was null or undefined when calling putUsersIDPassword.');
            }
            const localVarPath = `/users/{userID}/password`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordResetBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(passwordResetBody || {}) : (passwordResetBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDMembersID(userID: string, bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteBucketsIDMembersID(userID, bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDOwnersID(userID: string, bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteBucketsIDOwnersID(userID, bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDMembersID(userID: string, dashboardID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteDashboardsIDMembersID(userID, dashboardID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDOwnersID(userID: string, dashboardID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteDashboardsIDOwnersID(userID, dashboardID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDMembersID(userID: string, orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteOrgsIDMembersID(userID, orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDOwnersID(userID: string, orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteOrgsIDOwnersID(userID, orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from a scraper target
         * @param {string} userID ID of member to remove
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDMembersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteScrapersIDMembersID(userID, scraperTargetID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a scraper target
         * @param {string} userID ID of owner to remove
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDOwnersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteScrapersIDOwnersID(userID, scraperTargetID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDMembersID(userID: string, taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteTasksIDMembersID(userID, taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDOwnersID(userID: string, taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteTasksIDOwnersID(userID, taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDMembersID(userID: string, telegrafID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteTelegrafsIDMembersID(userID, telegrafID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDOwnersID(userID: string, telegrafID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteTelegrafsIDOwnersID(userID, telegrafID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary deletes a user
         * @param {string} userID ID of user to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersID(userID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteUsersID(userID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDMembers(bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMembers> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getBucketsIDMembers(bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDOwners(bucketID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getBucketsIDOwners(bucketID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDMembers(dashboardID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMembers> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getDashboardsIDMembers(dashboardID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDOwners(dashboardID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getDashboardsIDOwners(dashboardID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns currently authenticated user
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getMe(zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDMembers(orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMembers> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getOrgsIDMembers(orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDOwners(orgID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getOrgsIDOwners(orgID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDMembers(scraperTargetID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMembers> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getScrapersIDMembers(scraperTargetID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDOwners(scraperTargetID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getScrapersIDOwners(scraperTargetID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDMembers(taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMembers> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getTasksIDMembers(taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDOwners(taskID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getTasksIDOwners(taskID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDMembers(telegrafID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMembers> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getTelegrafsIDMembers(telegrafID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDOwners(telegrafID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwners> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getTelegrafsIDOwners(telegrafID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List all users
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getUsers(zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve a user
         * @param {string} userID ID of user to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersID(userID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getUsersID(userID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Retrieve operation logs for a user
         * @param {string} userID ID of the user
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersIDLogs(userID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationLogs> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getUsersIDLogs(userID, zapTraceSpan, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {string} userID ID of user to update
         * @param {User} user user update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUsersID(userID: string, user: User, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).patchUsersID(userID, user, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDMembers(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMember> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postBucketsIDMembers(bucketID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDOwners(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwner> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postBucketsIDOwners(bucketID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDMembers(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMember> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postDashboardsIDMembers(dashboardID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDOwners(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwner> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postDashboardsIDOwners(dashboardID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDMembers(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMember> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postOrgsIDMembers(orgID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDOwners(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwner> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postOrgsIDOwners(orgID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add scraper target member
         * @param {string} scraperTargetID ID of the scraper target
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDMembers(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMember> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postScrapersIDMembers(scraperTargetID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add scraper target owner
         * @param {string} scraperTargetID ID of the scraper target
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDOwners(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwner> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postScrapersIDOwners(scraperTargetID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDMembers(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMember> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postTasksIDMembers(taskID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDOwners(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwner> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postTasksIDOwners(taskID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDMembers(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceMember> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postTelegrafsIDMembers(telegrafID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDOwners(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceOwner> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postTelegrafsIDOwners(telegrafID, addResourceMemberRequestBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a user
         * @param {User} user user to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(user: User, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).postUsers(user, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update password
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMePassword(passwordResetBody: PasswordResetBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).putMePassword(passwordResetBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update password
         * @param {string} userID ID of the user
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersIDPassword(userID: string, passwordResetBody: PasswordResetBody, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).putUsersIDPassword(userID, passwordResetBody, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary removes a member from an bucket
         * @param {string} userID ID of member to remove
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDMembersID(userID: string, bucketID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteBucketsIDMembersID(userID, bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a bucket
         * @param {string} userID ID of owner to remove
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketsIDOwnersID(userID: string, bucketID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteBucketsIDOwnersID(userID, bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an dashboard
         * @param {string} userID ID of member to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDMembersID(userID: string, dashboardID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteDashboardsIDMembersID(userID, dashboardID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a dashboard
         * @param {string} userID ID of owner to remove
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardsIDOwnersID(userID: string, dashboardID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteDashboardsIDOwnersID(userID, dashboardID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an organization
         * @param {string} userID ID of member to remove
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDMembersID(userID: string, orgID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteOrgsIDMembersID(userID, orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an organization
         * @param {string} userID ID of owner to remove
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgsIDOwnersID(userID: string, orgID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteOrgsIDOwnersID(userID, orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from a scraper target
         * @param {string} userID ID of member to remove
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDMembersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteScrapersIDMembersID(userID, scraperTargetID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a scraper target
         * @param {string} userID ID of owner to remove
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScrapersIDOwnersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteScrapersIDOwnersID(userID, scraperTargetID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from an task
         * @param {string} userID ID of member to remove
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDMembersID(userID: string, taskID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteTasksIDMembersID(userID, taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from an task
         * @param {string} userID ID of owner to remove
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksIDOwnersID(userID: string, taskID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteTasksIDOwnersID(userID, taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes a member from a telegraf config
         * @param {string} userID ID of member to remove
         * @param {string} telegrafID ID of the telegraf
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDMembersID(userID: string, telegrafID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteTelegrafsIDMembersID(userID, telegrafID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary removes an owner from a telegraf config
         * @param {string} userID ID of owner to remove
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTelegrafsIDOwnersID(userID: string, telegrafID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteTelegrafsIDOwnersID(userID, telegrafID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary deletes a user
         * @param {string} userID ID of user to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersID(userID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).deleteUsersID(userID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users with member privileges for a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDMembers(bucketID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getBucketsIDMembers(bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a bucket
         * @param {string} bucketID ID of the bucket
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketsIDOwners(bucketID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getBucketsIDOwners(bucketID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all dashboard members
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDMembers(dashboardID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getDashboardsIDMembers(dashboardID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all dashboard owners
         * @param {string} dashboardID ID of the dashboard
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDOwners(dashboardID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getDashboardsIDOwners(dashboardID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns currently authenticated user
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getMe(zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all members of an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDMembers(orgID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getOrgsIDMembers(orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of an organization
         * @param {string} orgID ID of the organization
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgsIDOwners(orgID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getOrgsIDOwners(orgID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users with member privileges for a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDMembers(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getScrapersIDMembers(scraperTargetID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a scraper target
         * @param {string} scraperTargetID ID of the scraper target
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScrapersIDOwners(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getScrapersIDOwners(scraperTargetID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all task members
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDMembers(taskID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getTasksIDMembers(taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all task owners
         * @param {string} taskID ID of the task
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIDOwners(taskID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getTasksIDOwners(taskID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users with member privileges for a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDMembers(telegrafID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getTelegrafsIDMembers(telegrafID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all owners of a telegraf config
         * @param {string} telegrafID ID of the telegraf config
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelegrafsIDOwners(telegrafID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getTelegrafsIDOwners(telegrafID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary List all users
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getUsers(zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve a user
         * @param {string} userID ID of user to get
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersID(userID: string, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).getUsersID(userID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Retrieve operation logs for a user
         * @param {string} userID ID of the user
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersIDLogs(userID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
            return UsersApiFp(configuration).getUsersIDLogs(userID, zapTraceSpan, offset, limit, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a user
         * @param {string} userID ID of user to update
         * @param {User} user user update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUsersID(userID: string, user: User, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).patchUsersID(userID, user, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add bucket member
         * @param {string} bucketID ID of the bucket
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDMembers(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postBucketsIDMembers(bucketID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add bucket owner
         * @param {string} bucketID ID of the bucket
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBucketsIDOwners(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postBucketsIDOwners(bucketID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add dashboard member
         * @param {string} dashboardID ID of the dashboard
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDMembers(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postDashboardsIDMembers(dashboardID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add dashboard owner
         * @param {string} dashboardID ID of the dashboard
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboardsIDOwners(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postDashboardsIDOwners(dashboardID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add organization member
         * @param {string} orgID ID of the organization
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDMembers(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postOrgsIDMembers(orgID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add organization owner
         * @param {string} orgID ID of the organization
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrgsIDOwners(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postOrgsIDOwners(orgID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add scraper target member
         * @param {string} scraperTargetID ID of the scraper target
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDMembers(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postScrapersIDMembers(scraperTargetID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add scraper target owner
         * @param {string} scraperTargetID ID of the scraper target
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScrapersIDOwners(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postScrapersIDOwners(scraperTargetID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add task member
         * @param {string} taskID ID of the task
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDMembers(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postTasksIDMembers(taskID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add task owner
         * @param {string} taskID ID of the task
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksIDOwners(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postTasksIDOwners(taskID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add telegraf config member
         * @param {string} telegrafID ID of the telegraf config
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDMembers(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postTelegrafsIDMembers(telegrafID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Add telegraf config owner
         * @param {string} telegrafID ID of the telegraf config
         * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTelegrafsIDOwners(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postTelegrafsIDOwners(telegrafID, addResourceMemberRequestBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a user
         * @param {User} user user to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(user: User, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).postUsers(user, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update password
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMePassword(passwordResetBody: PasswordResetBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).putMePassword(passwordResetBody, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update password
         * @param {string} userID ID of the user
         * @param {PasswordResetBody} passwordResetBody new password
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersIDPassword(userID: string, passwordResetBody: PasswordResetBody, zapTraceSpan?: string, options?: any) {
            return UsersApiFp(configuration).putUsersIDPassword(userID, passwordResetBody, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary removes a member from an bucket
     * @param {string} userID ID of member to remove
     * @param {string} bucketID ID of the bucket
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteBucketsIDMembersID(userID: string, bucketID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteBucketsIDMembersID(userID, bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a bucket
     * @param {string} userID ID of owner to remove
     * @param {string} bucketID ID of the bucket
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteBucketsIDOwnersID(userID: string, bucketID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteBucketsIDOwnersID(userID, bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an dashboard
     * @param {string} userID ID of member to remove
     * @param {string} dashboardID ID of the dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteDashboardsIDMembersID(userID: string, dashboardID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteDashboardsIDMembersID(userID, dashboardID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a dashboard
     * @param {string} userID ID of owner to remove
     * @param {string} dashboardID ID of the dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteDashboardsIDOwnersID(userID: string, dashboardID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteDashboardsIDOwnersID(userID, dashboardID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an organization
     * @param {string} userID ID of member to remove
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteOrgsIDMembersID(userID: string, orgID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteOrgsIDMembersID(userID, orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an organization
     * @param {string} userID ID of owner to remove
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteOrgsIDOwnersID(userID: string, orgID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteOrgsIDOwnersID(userID, orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from a scraper target
     * @param {string} userID ID of member to remove
     * @param {string} scraperTargetID ID of the scraper target
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteScrapersIDMembersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteScrapersIDMembersID(userID, scraperTargetID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a scraper target
     * @param {string} userID ID of owner to remove
     * @param {string} scraperTargetID ID of the scraper target
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteScrapersIDOwnersID(userID: string, scraperTargetID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteScrapersIDOwnersID(userID, scraperTargetID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from an task
     * @param {string} userID ID of member to remove
     * @param {string} taskID ID of the task
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteTasksIDMembersID(userID: string, taskID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteTasksIDMembersID(userID, taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from an task
     * @param {string} userID ID of owner to remove
     * @param {string} taskID ID of the task
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteTasksIDOwnersID(userID: string, taskID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteTasksIDOwnersID(userID, taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes a member from a telegraf config
     * @param {string} userID ID of member to remove
     * @param {string} telegrafID ID of the telegraf
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteTelegrafsIDMembersID(userID: string, telegrafID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteTelegrafsIDMembersID(userID, telegrafID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary removes an owner from a telegraf config
     * @param {string} userID ID of owner to remove
     * @param {string} telegrafID ID of the telegraf config
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteTelegrafsIDOwnersID(userID: string, telegrafID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteTelegrafsIDOwnersID(userID, telegrafID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary deletes a user
     * @param {string} userID ID of user to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUsersID(userID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUsersID(userID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users with member privileges for a bucket
     * @param {string} bucketID ID of the bucket
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getBucketsIDMembers(bucketID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getBucketsIDMembers(bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a bucket
     * @param {string} bucketID ID of the bucket
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getBucketsIDOwners(bucketID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getBucketsIDOwners(bucketID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all dashboard members
     * @param {string} dashboardID ID of the dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getDashboardsIDMembers(dashboardID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getDashboardsIDMembers(dashboardID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all dashboard owners
     * @param {string} dashboardID ID of the dashboard
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getDashboardsIDOwners(dashboardID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getDashboardsIDOwners(dashboardID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns currently authenticated user
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getMe(zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getMe(zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all members of an organization
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getOrgsIDMembers(orgID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getOrgsIDMembers(orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of an organization
     * @param {string} orgID ID of the organization
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getOrgsIDOwners(orgID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getOrgsIDOwners(orgID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users with member privileges for a scraper target
     * @param {string} scraperTargetID ID of the scraper target
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getScrapersIDMembers(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getScrapersIDMembers(scraperTargetID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a scraper target
     * @param {string} scraperTargetID ID of the scraper target
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getScrapersIDOwners(scraperTargetID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getScrapersIDOwners(scraperTargetID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all task members
     * @param {string} taskID ID of the task
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getTasksIDMembers(taskID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getTasksIDMembers(taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all task owners
     * @param {string} taskID ID of the task
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getTasksIDOwners(taskID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getTasksIDOwners(taskID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users with member privileges for a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getTelegrafsIDMembers(telegrafID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getTelegrafsIDMembers(telegrafID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all owners of a telegraf config
     * @param {string} telegrafID ID of the telegraf config
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getTelegrafsIDOwners(telegrafID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getTelegrafsIDOwners(telegrafID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List all users
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsers(zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve a user
     * @param {string} userID ID of user to get
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersID(userID: string, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersID(userID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Retrieve operation logs for a user
     * @param {string} userID ID of the user
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersIDLogs(userID: string, zapTraceSpan?: string, offset?: number, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).getUsersIDLogs(userID, zapTraceSpan, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a user
     * @param {string} userID ID of user to update
     * @param {User} user user update to apply
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public patchUsersID(userID: string, user: User, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).patchUsersID(userID, user, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add bucket member
     * @param {string} bucketID ID of the bucket
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postBucketsIDMembers(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postBucketsIDMembers(bucketID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add bucket owner
     * @param {string} bucketID ID of the bucket
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postBucketsIDOwners(bucketID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postBucketsIDOwners(bucketID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add dashboard member
     * @param {string} dashboardID ID of the dashboard
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postDashboardsIDMembers(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postDashboardsIDMembers(dashboardID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add dashboard owner
     * @param {string} dashboardID ID of the dashboard
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postDashboardsIDOwners(dashboardID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postDashboardsIDOwners(dashboardID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add organization member
     * @param {string} orgID ID of the organization
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postOrgsIDMembers(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postOrgsIDMembers(orgID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add organization owner
     * @param {string} orgID ID of the organization
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postOrgsIDOwners(orgID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postOrgsIDOwners(orgID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add scraper target member
     * @param {string} scraperTargetID ID of the scraper target
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postScrapersIDMembers(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postScrapersIDMembers(scraperTargetID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add scraper target owner
     * @param {string} scraperTargetID ID of the scraper target
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postScrapersIDOwners(scraperTargetID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postScrapersIDOwners(scraperTargetID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add task member
     * @param {string} taskID ID of the task
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postTasksIDMembers(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postTasksIDMembers(taskID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add task owner
     * @param {string} taskID ID of the task
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postTasksIDOwners(taskID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postTasksIDOwners(taskID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add telegraf config member
     * @param {string} telegrafID ID of the telegraf config
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as member
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postTelegrafsIDMembers(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postTelegrafsIDMembers(telegrafID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add telegraf config owner
     * @param {string} telegrafID ID of the telegraf config
     * @param {AddResourceMemberRequestBody} addResourceMemberRequestBody user to add as owner
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postTelegrafsIDOwners(telegrafID: string, addResourceMemberRequestBody: AddResourceMemberRequestBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postTelegrafsIDOwners(telegrafID, addResourceMemberRequestBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a user
     * @param {User} user user to create
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsers(user: User, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).postUsers(user, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update password
     * @param {PasswordResetBody} passwordResetBody new password
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putMePassword(passwordResetBody: PasswordResetBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).putMePassword(passwordResetBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update password
     * @param {string} userID ID of the user
     * @param {PasswordResetBody} passwordResetBody new password
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putUsersIDPassword(userID: string, passwordResetBody: PasswordResetBody, zapTraceSpan?: string, options?: any) {
        return UsersApiFp(this.configuration).putUsersIDPassword(userID, passwordResetBody, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * VariablesApi - axios parameter creator
 * @export
 */
export const VariablesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete a variable
         * @param {string} variableID id of the variable
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariablesID(variableID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'variableID' is not null or undefined
            if (variableID === null || variableID === undefined) {
                throw new RequiredError('variableID','Required parameter variableID was null or undefined when calling deleteVariablesID.');
            }
            const localVarPath = `/variables/{variableID}`
                .replace(`{${"variableID"}}`, encodeURIComponent(String(variableID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a label from a variable
         * @param {string} variableID ID of the variable
         * @param {string} labelID the label id to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariablesIDLabelsID(variableID: string, labelID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'variableID' is not null or undefined
            if (variableID === null || variableID === undefined) {
                throw new RequiredError('variableID','Required parameter variableID was null or undefined when calling deleteVariablesIDLabelsID.');
            }
            // verify required parameter 'labelID' is not null or undefined
            if (labelID === null || labelID === undefined) {
                throw new RequiredError('labelID','Required parameter labelID was null or undefined when calling deleteVariablesIDLabelsID.');
            }
            const localVarPath = `/variables/{variableID}/labels/{labelID}`
                .replace(`{${"variableID"}}`, encodeURIComponent(String(variableID)))
                .replace(`{${"labelID"}}`, encodeURIComponent(String(labelID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all variables
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the organization name of the resource
         * @param {string} [orgID] specifies the organization id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(zapTraceSpan?: string, org?: string, orgID?: string, options: any = {}): RequestArgs {
            const localVarPath = `/variables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (orgID !== undefined) {
                localVarQueryParameter['orgID'] = orgID;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get a variable
         * @param {string} variableID ID of the variable
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariablesID(variableID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'variableID' is not null or undefined
            if (variableID === null || variableID === undefined) {
                throw new RequiredError('variableID','Required parameter variableID was null or undefined when calling getVariablesID.');
            }
            const localVarPath = `/variables/{variableID}`
                .replace(`{${"variableID"}}`, encodeURIComponent(String(variableID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all labels for a variable
         * @param {string} variableID ID of the variable
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariablesIDLabels(variableID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'variableID' is not null or undefined
            if (variableID === null || variableID === undefined) {
                throw new RequiredError('variableID','Required parameter variableID was null or undefined when calling getVariablesIDLabels.');
            }
            const localVarPath = `/variables/{variableID}/labels`
                .replace(`{${"variableID"}}`, encodeURIComponent(String(variableID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update a variable
         * @param {string} variableID id of the variable
         * @param {Variable} variable variable update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchVariablesID(variableID: string, variable: Variable, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'variableID' is not null or undefined
            if (variableID === null || variableID === undefined) {
                throw new RequiredError('variableID','Required parameter variableID was null or undefined when calling patchVariablesID.');
            }
            // verify required parameter 'variable' is not null or undefined
            if (variable === null || variable === undefined) {
                throw new RequiredError('variable','Required parameter variable was null or undefined when calling patchVariablesID.');
            }
            const localVarPath = `/variables/{variableID}`
                .replace(`{${"variableID"}}`, encodeURIComponent(String(variableID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Variable" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(variable || {}) : (variable || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create a variable
         * @param {Variable} variable variable to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariables(variable: Variable, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'variable' is not null or undefined
            if (variable === null || variable === undefined) {
                throw new RequiredError('variable','Required parameter variable was null or undefined when calling postVariables.');
            }
            const localVarPath = `/variables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Variable" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(variable || {}) : (variable || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a label to a variable
         * @param {string} variableID ID of the variable
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariablesIDLabels(variableID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'variableID' is not null or undefined
            if (variableID === null || variableID === undefined) {
                throw new RequiredError('variableID','Required parameter variableID was null or undefined when calling postVariablesIDLabels.');
            }
            // verify required parameter 'labelMapping' is not null or undefined
            if (labelMapping === null || labelMapping === undefined) {
                throw new RequiredError('labelMapping','Required parameter labelMapping was null or undefined when calling postVariablesIDLabels.');
            }
            const localVarPath = `/variables/{variableID}/labels`
                .replace(`{${"variableID"}}`, encodeURIComponent(String(variableID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LabelMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(labelMapping || {}) : (labelMapping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary replace a variable
         * @param {string} variableID id of the variable
         * @param {Variable} variable variable to replace
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVariablesID(variableID: string, variable: Variable, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'variableID' is not null or undefined
            if (variableID === null || variableID === undefined) {
                throw new RequiredError('variableID','Required parameter variableID was null or undefined when calling putVariablesID.');
            }
            // verify required parameter 'variable' is not null or undefined
            if (variable === null || variable === undefined) {
                throw new RequiredError('variable','Required parameter variable was null or undefined when calling putVariablesID.');
            }
            const localVarPath = `/variables/{variableID}`
                .replace(`{${"variableID"}}`, encodeURIComponent(String(variableID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Variable" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(variable || {}) : (variable || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariablesApi - functional programming interface
 * @export
 */
export const VariablesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete a variable
         * @param {string} variableID id of the variable
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariablesID(variableID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = VariablesApiAxiosParamCreator(configuration).deleteVariablesID(variableID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary delete a label from a variable
         * @param {string} variableID ID of the variable
         * @param {string} labelID the label id to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariablesIDLabelsID(variableID: string, labelID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = VariablesApiAxiosParamCreator(configuration).deleteVariablesIDLabelsID(variableID, labelID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary get all variables
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the organization name of the resource
         * @param {string} [orgID] specifies the organization id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(zapTraceSpan?: string, org?: string, orgID?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Variables> {
            const localVarAxiosArgs = VariablesApiAxiosParamCreator(configuration).getVariables(zapTraceSpan, org, orgID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary get a variable
         * @param {string} variableID ID of the variable
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariablesID(variableID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Variable> {
            const localVarAxiosArgs = VariablesApiAxiosParamCreator(configuration).getVariablesID(variableID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary list all labels for a variable
         * @param {string} variableID ID of the variable
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariablesIDLabels(variableID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelsResponse> {
            const localVarAxiosArgs = VariablesApiAxiosParamCreator(configuration).getVariablesIDLabels(variableID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary update a variable
         * @param {string} variableID id of the variable
         * @param {Variable} variable variable update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchVariablesID(variableID: string, variable: Variable, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Variable> {
            const localVarAxiosArgs = VariablesApiAxiosParamCreator(configuration).patchVariablesID(variableID, variable, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary create a variable
         * @param {Variable} variable variable to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariables(variable: Variable, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Variable> {
            const localVarAxiosArgs = VariablesApiAxiosParamCreator(configuration).postVariables(variable, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary add a label to a variable
         * @param {string} variableID ID of the variable
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariablesIDLabels(variableID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResponse> {
            const localVarAxiosArgs = VariablesApiAxiosParamCreator(configuration).postVariablesIDLabels(variableID, labelMapping, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary replace a variable
         * @param {string} variableID id of the variable
         * @param {Variable} variable variable to replace
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVariablesID(variableID: string, variable: Variable, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Variable> {
            const localVarAxiosArgs = VariablesApiAxiosParamCreator(configuration).putVariablesID(variableID, variable, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * VariablesApi - factory interface
 * @export
 */
export const VariablesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary delete a variable
         * @param {string} variableID id of the variable
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariablesID(variableID: string, zapTraceSpan?: string, options?: any) {
            return VariablesApiFp(configuration).deleteVariablesID(variableID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary delete a label from a variable
         * @param {string} variableID ID of the variable
         * @param {string} labelID the label id to delete
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariablesIDLabelsID(variableID: string, labelID: string, zapTraceSpan?: string, options?: any) {
            return VariablesApiFp(configuration).deleteVariablesIDLabelsID(variableID, labelID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary get all variables
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {string} [org] specifies the organization name of the resource
         * @param {string} [orgID] specifies the organization id of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(zapTraceSpan?: string, org?: string, orgID?: string, options?: any) {
            return VariablesApiFp(configuration).getVariables(zapTraceSpan, org, orgID, options)(axios, basePath);
        },
        /**
         * 
         * @summary get a variable
         * @param {string} variableID ID of the variable
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariablesID(variableID: string, zapTraceSpan?: string, options?: any) {
            return VariablesApiFp(configuration).getVariablesID(variableID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary list all labels for a variable
         * @param {string} variableID ID of the variable
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariablesIDLabels(variableID: string, zapTraceSpan?: string, options?: any) {
            return VariablesApiFp(configuration).getVariablesIDLabels(variableID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary update a variable
         * @param {string} variableID id of the variable
         * @param {Variable} variable variable update to apply
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchVariablesID(variableID: string, variable: Variable, zapTraceSpan?: string, options?: any) {
            return VariablesApiFp(configuration).patchVariablesID(variableID, variable, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary create a variable
         * @param {Variable} variable variable to create
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariables(variable: Variable, zapTraceSpan?: string, options?: any) {
            return VariablesApiFp(configuration).postVariables(variable, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary add a label to a variable
         * @param {string} variableID ID of the variable
         * @param {LabelMapping} labelMapping label to add
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariablesIDLabels(variableID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
            return VariablesApiFp(configuration).postVariablesIDLabels(variableID, labelMapping, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary replace a variable
         * @param {string} variableID id of the variable
         * @param {Variable} variable variable to replace
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVariablesID(variableID: string, variable: Variable, zapTraceSpan?: string, options?: any) {
            return VariablesApiFp(configuration).putVariablesID(variableID, variable, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * VariablesApi - object-oriented interface
 * @export
 * @class VariablesApi
 * @extends {BaseAPI}
 */
export class VariablesApi extends BaseAPI {
    /**
     * 
     * @summary delete a variable
     * @param {string} variableID id of the variable
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public deleteVariablesID(variableID: string, zapTraceSpan?: string, options?: any) {
        return VariablesApiFp(this.configuration).deleteVariablesID(variableID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary delete a label from a variable
     * @param {string} variableID ID of the variable
     * @param {string} labelID the label id to delete
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public deleteVariablesIDLabelsID(variableID: string, labelID: string, zapTraceSpan?: string, options?: any) {
        return VariablesApiFp(this.configuration).deleteVariablesIDLabelsID(variableID, labelID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary get all variables
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {string} [org] specifies the organization name of the resource
     * @param {string} [orgID] specifies the organization id of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariables(zapTraceSpan?: string, org?: string, orgID?: string, options?: any) {
        return VariablesApiFp(this.configuration).getVariables(zapTraceSpan, org, orgID, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary get a variable
     * @param {string} variableID ID of the variable
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariablesID(variableID: string, zapTraceSpan?: string, options?: any) {
        return VariablesApiFp(this.configuration).getVariablesID(variableID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary list all labels for a variable
     * @param {string} variableID ID of the variable
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariablesIDLabels(variableID: string, zapTraceSpan?: string, options?: any) {
        return VariablesApiFp(this.configuration).getVariablesIDLabels(variableID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary update a variable
     * @param {string} variableID id of the variable
     * @param {Variable} variable variable update to apply
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public patchVariablesID(variableID: string, variable: Variable, zapTraceSpan?: string, options?: any) {
        return VariablesApiFp(this.configuration).patchVariablesID(variableID, variable, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary create a variable
     * @param {Variable} variable variable to create
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public postVariables(variable: Variable, zapTraceSpan?: string, options?: any) {
        return VariablesApiFp(this.configuration).postVariables(variable, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary add a label to a variable
     * @param {string} variableID ID of the variable
     * @param {LabelMapping} labelMapping label to add
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public postVariablesIDLabels(variableID: string, labelMapping: LabelMapping, zapTraceSpan?: string, options?: any) {
        return VariablesApiFp(this.configuration).postVariablesIDLabels(variableID, labelMapping, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary replace a variable
     * @param {string} variableID id of the variable
     * @param {Variable} variable variable to replace
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public putVariablesID(variableID: string, variable: Variable, zapTraceSpan?: string, options?: any) {
        return VariablesApiFp(this.configuration).putVariablesID(variableID, variable, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * ViewsApi - axios parameter creator
 * @export
 */
export const ViewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDCellsIDView(dashboardID: string, cellID: string, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling getDashboardsIDCellsIDView.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling getDashboardsIDCellsIDView.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}/view`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsIDView(dashboardID: string, cellID: string, view: View, zapTraceSpan?: string, options: any = {}): RequestArgs {
            // verify required parameter 'dashboardID' is not null or undefined
            if (dashboardID === null || dashboardID === undefined) {
                throw new RequiredError('dashboardID','Required parameter dashboardID was null or undefined when calling patchDashboardsIDCellsIDView.');
            }
            // verify required parameter 'cellID' is not null or undefined
            if (cellID === null || cellID === undefined) {
                throw new RequiredError('cellID','Required parameter cellID was null or undefined when calling patchDashboardsIDCellsIDView.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling patchDashboardsIDCellsIDView.');
            }
            const localVarPath = `/dashboards/{dashboardID}/cells/{cellID}/view`
                .replace(`{${"dashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"cellID"}}`, encodeURIComponent(String(cellID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"View" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(view || {}) : (view || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewsApi - functional programming interface
 * @export
 */
export const ViewsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDCellsIDView(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).getDashboardsIDCellsIDView(dashboardID, cellID, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsIDView(dashboardID: string, cellID: string, view: View, zapTraceSpan?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<View> {
            const localVarAxiosArgs = ViewsApiAxiosParamCreator(configuration).patchDashboardsIDCellsIDView(dashboardID, cellID, view, zapTraceSpan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * ViewsApi - factory interface
 * @export
 */
export const ViewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Retrieve the view for a cell in a dashboard
         * @param {string} dashboardID ID of dashboard
         * @param {string} cellID ID of cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardsIDCellsIDView(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any) {
            return ViewsApiFp(configuration).getDashboardsIDCellsIDView(dashboardID, cellID, zapTraceSpan, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the view for a cell
         * @param {string} dashboardID ID of dashboard to update
         * @param {string} cellID ID of cell to update
         * @param {View} view updates the view for a cell
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboardsIDCellsIDView(dashboardID: string, cellID: string, view: View, zapTraceSpan?: string, options?: any) {
            return ViewsApiFp(configuration).patchDashboardsIDCellsIDView(dashboardID, cellID, view, zapTraceSpan, options)(axios, basePath);
        },
    };
};

/**
 * ViewsApi - object-oriented interface
 * @export
 * @class ViewsApi
 * @extends {BaseAPI}
 */
export class ViewsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the view for a cell in a dashboard
     * @param {string} dashboardID ID of dashboard
     * @param {string} cellID ID of cell
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public getDashboardsIDCellsIDView(dashboardID: string, cellID: string, zapTraceSpan?: string, options?: any) {
        return ViewsApiFp(this.configuration).getDashboardsIDCellsIDView(dashboardID, cellID, zapTraceSpan, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the view for a cell
     * @param {string} dashboardID ID of dashboard to update
     * @param {string} cellID ID of cell to update
     * @param {View} view updates the view for a cell
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public patchDashboardsIDCellsIDView(dashboardID: string, cellID: string, view: View, zapTraceSpan?: string, options?: any) {
        return ViewsApiFp(this.configuration).patchDashboardsIDCellsIDView(dashboardID, cellID, view, zapTraceSpan, options)(this.axios, this.basePath);
    }

}

/**
 * WriteApi - axios parameter creator
 * @export
 */
export const WriteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary write time-series data into influxdb
         * @param {string} org specifies the destination organization for writes
         * @param {string} bucket specifies the destination bucket for writes
         * @param {string} body line protocol body
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'gzip' | 'identity'} [contentEncoding] when present, its value indicates to the database that compression is applied to the line-protocol body.
         * @param {'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow'} [contentType] Content-Type is used to indicate the format of the data sent to the server.
         * @param {number} [contentLength] Content-Length is an entity header is indicating the size of the entity-body, in bytes, sent to the database. If the length is greater than the database max body configuration option, a 413 response is sent.
         * @param {'application/json'} [accept] specifies the return content format.
         * @param {WritePrecision} [precision] specifies the precision for the unix timestamps within the body line-protocol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWrite(org: string, bucket: string, body: string, zapTraceSpan?: string, contentEncoding?: 'gzip' | 'identity', contentType?: 'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow', contentLength?: number, accept?: 'application/json', precision?: WritePrecision, options: any = {}): RequestArgs {
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling postWrite.');
            }
            // verify required parameter 'bucket' is not null or undefined
            if (bucket === null || bucket === undefined) {
                throw new RequiredError('bucket','Required parameter bucket was null or undefined when calling postWrite.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postWrite.');
            }
            const localVarPath = `/write`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (bucket !== undefined) {
                localVarQueryParameter['bucket'] = bucket;
            }

            if (precision !== undefined) {
                localVarQueryParameter['precision'] = precision;
            }

            if (zapTraceSpan !== undefined && zapTraceSpan !== null) {
                localVarHeaderParameter['Zap-Trace-Span'] = String(zapTraceSpan);
            }

            if (contentEncoding !== undefined && contentEncoding !== null) {
                localVarHeaderParameter['Content-Encoding'] = String(contentEncoding);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (contentLength !== undefined && contentLength !== null) {
                localVarHeaderParameter['Content-Length'] = String(contentLength);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WriteApi - functional programming interface
 * @export
 */
export const WriteApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary write time-series data into influxdb
         * @param {string} org specifies the destination organization for writes
         * @param {string} bucket specifies the destination bucket for writes
         * @param {string} body line protocol body
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'gzip' | 'identity'} [contentEncoding] when present, its value indicates to the database that compression is applied to the line-protocol body.
         * @param {'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow'} [contentType] Content-Type is used to indicate the format of the data sent to the server.
         * @param {number} [contentLength] Content-Length is an entity header is indicating the size of the entity-body, in bytes, sent to the database. If the length is greater than the database max body configuration option, a 413 response is sent.
         * @param {'application/json'} [accept] specifies the return content format.
         * @param {WritePrecision} [precision] specifies the precision for the unix timestamps within the body line-protocol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWrite(org: string, bucket: string, body: string, zapTraceSpan?: string, contentEncoding?: 'gzip' | 'identity', contentType?: 'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow', contentLength?: number, accept?: 'application/json', precision?: WritePrecision, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = WriteApiAxiosParamCreator(configuration).postWrite(org, bucket, body, zapTraceSpan, contentEncoding, contentType, contentLength, accept, precision, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * WriteApi - factory interface
 * @export
 */
export const WriteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary write time-series data into influxdb
         * @param {string} org specifies the destination organization for writes
         * @param {string} bucket specifies the destination bucket for writes
         * @param {string} body line protocol body
         * @param {string} [zapTraceSpan] OpenTracing span context
         * @param {'gzip' | 'identity'} [contentEncoding] when present, its value indicates to the database that compression is applied to the line-protocol body.
         * @param {'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow'} [contentType] Content-Type is used to indicate the format of the data sent to the server.
         * @param {number} [contentLength] Content-Length is an entity header is indicating the size of the entity-body, in bytes, sent to the database. If the length is greater than the database max body configuration option, a 413 response is sent.
         * @param {'application/json'} [accept] specifies the return content format.
         * @param {WritePrecision} [precision] specifies the precision for the unix timestamps within the body line-protocol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWrite(org: string, bucket: string, body: string, zapTraceSpan?: string, contentEncoding?: 'gzip' | 'identity', contentType?: 'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow', contentLength?: number, accept?: 'application/json', precision?: WritePrecision, options?: any) {
            return WriteApiFp(configuration).postWrite(org, bucket, body, zapTraceSpan, contentEncoding, contentType, contentLength, accept, precision, options)(axios, basePath);
        },
    };
};

/**
 * WriteApi - object-oriented interface
 * @export
 * @class WriteApi
 * @extends {BaseAPI}
 */
export class WriteApi extends BaseAPI {
    /**
     * 
     * @summary write time-series data into influxdb
     * @param {string} org specifies the destination organization for writes
     * @param {string} bucket specifies the destination bucket for writes
     * @param {string} body line protocol body
     * @param {string} [zapTraceSpan] OpenTracing span context
     * @param {'gzip' | 'identity'} [contentEncoding] when present, its value indicates to the database that compression is applied to the line-protocol body.
     * @param {'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow'} [contentType] Content-Type is used to indicate the format of the data sent to the server.
     * @param {number} [contentLength] Content-Length is an entity header is indicating the size of the entity-body, in bytes, sent to the database. If the length is greater than the database max body configuration option, a 413 response is sent.
     * @param {'application/json'} [accept] specifies the return content format.
     * @param {WritePrecision} [precision] specifies the precision for the unix timestamps within the body line-protocol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApi
     */
    public postWrite(org: string, bucket: string, body: string, zapTraceSpan?: string, contentEncoding?: 'gzip' | 'identity', contentType?: 'text/plain' | 'text/plain; charset=utf-8' | 'application/vnd.influx.arrow', contentLength?: number, accept?: 'application/json', precision?: WritePrecision, options?: any) {
        return WriteApiFp(this.configuration).postWrite(org, bucket, body, zapTraceSpan, contentEncoding, contentType, contentLength, accept, precision, options)(this.axios, this.basePath);
    }

}

